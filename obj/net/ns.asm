
obj/net/ns：     文件格式 elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 df e4 00 00       	call   80e510 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 25 a5 00 00       	call   80a56d <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 6a a5 00 00       	call   80a5d7 <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	78 05                	js     800079 <start_timer+0x2c>
}
  800074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800077:	c9                   	leave  
  800078:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  800079:	83 ec 0c             	sub    $0xc,%esp
  80007c:	50                   	push   %eax
  80007d:	e8 87 a8 00 00       	call   80a909 <e2s>
  800082:	50                   	push   %eax
  800083:	68 20 0e 81 00       	push   $0x810e20
  800088:	6a 7a                	push   $0x7a
  80008a:	68 55 0f 81 00       	push   $0x810f55
  80008f:	e8 dc e4 00 00       	call   80e570 <_panic>

00800094 <net_timer>:
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  80009c:	e8 69 f1 00 00       	call   80f20a <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000a3:	e8 9c a4 00 00       	call   80a544 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 95 a4 00 00       	call   80a545 <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 c4 a6 00 00       	call   80a783 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 4f 01 00 00    	ja     80022b <serve_thread+0x167>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 00 10 81 00 	jmp    *0x811000(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 0e 0d 00 00       	call   800e0b <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 a7 ec 00 00       	call   80edb5 <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800111:	83 ff ff             	cmp    $0xffffffff,%edi
  800114:	0f 84 2f 01 00 00    	je     800249 <serve_thread+0x185>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  80011a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80011d:	0f 85 48 01 00 00    	jne    80026b <serve_thread+0x1a7>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800123:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800126:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  80012c:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80012f:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800136:	83 ec 08             	sub    $0x8,%esp
  800139:	52                   	push   %edx
  80013a:	6a 00                	push   $0x0
  80013c:	e8 5d ef 00 00       	call   80f09e <sys_page_unmap>
	free(args);
  800141:	89 1c 24             	mov    %ebx,(%esp)
  800144:	e8 8b 05 01 00       	call   8106d4 <free>
}
  800149:	83 c4 10             	add    $0x10,%esp
  80014c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80014f:	5b                   	pop    %ebx
  800150:	5e                   	pop    %esi
  800151:	5f                   	pop    %edi
  800152:	5d                   	pop    %ebp
  800153:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	83 ec 04             	sub    $0x4,%esp
  800157:	ff 76 14             	pushl  0x14(%esi)
  80015a:	8d 46 04             	lea    0x4(%esi),%eax
  80015d:	50                   	push   %eax
  80015e:	ff 36                	pushl  (%esi)
  800160:	e8 58 0e 00 00       	call   800fbd <lwip_bind>
  800165:	89 c7                	mov    %eax,%edi
		break;
  800167:	83 c4 10             	add    $0x10,%esp
  80016a:	eb a5                	jmp    800111 <serve_thread+0x4d>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  80016c:	83 ec 08             	sub    $0x8,%esp
  80016f:	ff 76 04             	pushl  0x4(%esi)
  800172:	ff 36                	pushl  (%esi)
  800174:	e8 95 19 00 00       	call   801b0e <lwip_shutdown>
  800179:	89 c7                	mov    %eax,%edi
		break;
  80017b:	83 c4 10             	add    $0x10,%esp
  80017e:	eb 91                	jmp    800111 <serve_thread+0x4d>
		r = lwip_close(req->close.req_s);
  800180:	83 ec 0c             	sub    $0xc,%esp
  800183:	ff 36                	pushl  (%esi)
  800185:	e8 e9 0e 00 00       	call   801073 <lwip_close>
  80018a:	89 c7                	mov    %eax,%edi
		break;
  80018c:	83 c4 10             	add    $0x10,%esp
  80018f:	eb 80                	jmp    800111 <serve_thread+0x4d>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800191:	83 ec 04             	sub    $0x4,%esp
  800194:	ff 76 14             	pushl  0x14(%esi)
  800197:	8d 46 04             	lea    0x4(%esi),%eax
  80019a:	50                   	push   %eax
  80019b:	ff 36                	pushl  (%esi)
  80019d:	e8 5a 0f 00 00       	call   8010fc <lwip_connect>
  8001a2:	89 c7                	mov    %eax,%edi
		break;
  8001a4:	83 c4 10             	add    $0x10,%esp
  8001a7:	e9 65 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001ac:	83 ec 08             	sub    $0x8,%esp
  8001af:	ff 76 04             	pushl  0x4(%esi)
  8001b2:	ff 36                	pushl  (%esi)
  8001b4:	e8 f9 0f 00 00       	call   8011b2 <lwip_listen>
  8001b9:	89 c7                	mov    %eax,%edi
		break;
  8001bb:	83 c4 10             	add    $0x10,%esp
  8001be:	e9 4e ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001c3:	ff 76 08             	pushl  0x8(%esi)
  8001c6:	ff 76 04             	pushl  0x4(%esi)
  8001c9:	56                   	push   %esi
  8001ca:	ff 36                	pushl  (%esi)
  8001cc:	e8 c6 12 00 00       	call   801497 <lwip_recv>
  8001d1:	89 c7                	mov    %eax,%edi
		break;
  8001d3:	83 c4 10             	add    $0x10,%esp
  8001d6:	e9 36 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001db:	ff 76 08             	pushl  0x8(%esi)
  8001de:	ff 76 04             	pushl  0x4(%esi)
  8001e1:	8d 46 0c             	lea    0xc(%esi),%eax
  8001e4:	50                   	push   %eax
  8001e5:	ff 36                	pushl  (%esi)
  8001e7:	e8 3d 14 00 00       	call   801629 <lwip_send>
  8001ec:	89 c7                	mov    %eax,%edi
		break;
  8001ee:	83 c4 10             	add    $0x10,%esp
  8001f1:	e9 1b ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001f6:	83 ec 04             	sub    $0x4,%esp
  8001f9:	ff 76 08             	pushl  0x8(%esi)
  8001fc:	ff 76 04             	pushl  0x4(%esi)
  8001ff:	ff 36                	pushl  (%esi)
  800201:	e8 b4 14 00 00       	call   8016ba <lwip_socket>
  800206:	89 c7                	mov    %eax,%edi
		break;
  800208:	83 c4 10             	add    $0x10,%esp
  80020b:	e9 01 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		jif_input(&nif, (void *)&req->pkt);
  800210:	83 ec 08             	sub    $0x8,%esp
  800213:	56                   	push   %esi
  800214:	68 00 b2 b3 00       	push   $0xb3b200
  800219:	e8 da a7 00 00       	call   80a9f8 <jif_input>
  80021e:	83 c4 10             	add    $0x10,%esp
		r = 0;
  800221:	bf 00 00 00 00       	mov    $0x0,%edi
  800226:	e9 ef fe ff ff       	jmp    80011a <serve_thread+0x56>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80022b:	83 ec 04             	sub    $0x4,%esp
  80022e:	56                   	push   %esi
  80022f:	ff 73 04             	pushl  0x4(%ebx)
  800232:	68 40 0e 81 00       	push   $0x810e40
  800237:	e8 0f e4 00 00       	call   80e64b <cprintf>
  80023c:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80023f:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800244:	e9 d1 fe ff ff       	jmp    80011a <serve_thread+0x56>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800249:	ff 33                	pushl  (%ebx)
  80024b:	68 60 0f 81 00       	push   $0x810f60
  800250:	6a 64                	push   $0x64
  800252:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800255:	56                   	push   %esi
  800256:	e8 79 e9 00 00       	call   80ebd4 <snprintf>
		perror(buf);
  80025b:	89 34 24             	mov    %esi,(%esp)
  80025e:	e8 82 a6 00 00       	call   80a8e5 <perror>
  800263:	83 c4 10             	add    $0x10,%esp
  800266:	e9 af fe ff ff       	jmp    80011a <serve_thread+0x56>
		ipc_send(args->whom, r, 0, 0);
  80026b:	6a 00                	push   $0x0
  80026d:	6a 00                	push   $0x0
  80026f:	57                   	push   %edi
  800270:	ff 73 04             	pushl  0x4(%ebx)
  800273:	e8 c9 f3 00 00       	call   80f641 <ipc_send>
  800278:	83 c4 10             	add    $0x10,%esp
  80027b:	e9 a3 fe ff ff       	jmp    800123 <serve_thread+0x5f>

00800280 <serve_init>:
{
  800280:	55                   	push   %ebp
  800281:	89 e5                	mov    %esp,%ebp
  800283:	56                   	push   %esi
  800284:	53                   	push   %ebx
  800285:	83 ec 10             	sub    $0x10,%esp
  800288:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80028b:	e8 b4 a2 00 00       	call   80a544 <lwip_core_lock>
	uint32_t done = 0;
  800290:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800297:	83 ec 08             	sub    $0x8,%esp
  80029a:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80029d:	53                   	push   %ebx
  80029e:	68 33 00 80 00       	push   $0x800033
  8002a3:	e8 f9 20 00 00       	call   8023a1 <tcpip_init>
	lwip_core_unlock();
  8002a8:	e8 98 a2 00 00       	call   80a545 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002ad:	83 c4 0c             	add    $0xc,%esp
  8002b0:	6a ff                	push   $0xffffffff
  8002b2:	6a 00                	push   $0x0
  8002b4:	53                   	push   %ebx
  8002b5:	e8 c9 a4 00 00       	call   80a783 <thread_wait>
	lwip_core_lock();
  8002ba:	e8 85 a2 00 00       	call   80a544 <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002bf:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002c8:	8b 45 10             	mov    0x10(%ebp),%eax
  8002cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002ce:	83 c4 0c             	add    $0xc,%esp
  8002d1:	68 fe 64 80 00       	push   $0x8064fe
  8002d6:	68 e3 aa 80 00       	push   $0x80aae3
  8002db:	68 14 50 81 00       	push   $0x815014
  8002e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002e3:	50                   	push   %eax
  8002e4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002e7:	50                   	push   %eax
  8002e8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002eb:	50                   	push   %eax
  8002ec:	68 00 b2 b3 00       	push   $0xb3b200
  8002f1:	e8 09 43 00 00       	call   8045ff <netif_add>
  8002f6:	83 c4 20             	add    $0x20,%esp
  8002f9:	85 c0                	test   %eax,%eax
  8002fb:	0f 84 cc 00 00 00    	je     8003cd <serve_init+0x14d>
	netif_set_default(nif);
  800301:	83 ec 0c             	sub    $0xc,%esp
  800304:	68 00 b2 b3 00       	push   $0xb3b200
  800309:	e8 a3 43 00 00       	call   8046b1 <netif_set_default>
	netif_set_up(nif);
  80030e:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  800315:	e8 a4 43 00 00       	call   8046be <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80031a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800321:	b9 6f 0f 81 00       	mov    $0x810f6f,%ecx
  800326:	ba c7 94 80 00       	mov    $0x8094c7,%edx
  80032b:	b8 34 50 81 00       	mov    $0x815034,%eax
  800330:	e8 18 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800335:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80033c:	b9 79 0f 81 00       	mov    $0x810f79,%ecx
  800341:	ba 8d 56 80 00       	mov    $0x80568d,%edx
  800346:	b8 28 50 81 00       	mov    $0x815028,%eax
  80034b:	e8 fd fc ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800350:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800357:	b9 85 0f 81 00       	mov    $0x810f85,%ecx
  80035c:	ba 46 5c 80 00       	mov    $0x805c46,%edx
  800361:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  800366:	e8 e2 fc ff ff       	call   80004d <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80036b:	89 34 24             	mov    %esi,(%esp)
  80036e:	e8 b2 72 00 00       	call   807625 <inet_ntoa>
  800373:	50                   	push   %eax
  800374:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  80037b:	50                   	push   %eax
  80037c:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  800383:	50                   	push   %eax
  800384:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  80038b:	50                   	push   %eax
  80038c:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  800393:	50                   	push   %eax
  800394:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  80039b:	50                   	push   %eax
  80039c:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  8003a3:	50                   	push   %eax
  8003a4:	68 84 0e 81 00       	push   $0x810e84
  8003a9:	e8 9d e2 00 00       	call   80e64b <cprintf>
	lwip_core_unlock();
  8003ae:	83 c4 30             	add    $0x30,%esp
  8003b1:	e8 8f a1 00 00       	call   80a545 <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003b6:	83 ec 0c             	sub    $0xc,%esp
  8003b9:	68 91 0f 81 00       	push   $0x810f91
  8003be:	e8 88 e2 00 00       	call   80e64b <cprintf>
}
  8003c3:	83 c4 10             	add    $0x10,%esp
  8003c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c9:	5b                   	pop    %ebx
  8003ca:	5e                   	pop    %esi
  8003cb:	5d                   	pop    %ebp
  8003cc:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003cd:	83 ec 04             	sub    $0x4,%esp
  8003d0:	68 64 0e 81 00       	push   $0x810e64
  8003d5:	6a 5c                	push   $0x5c
  8003d7:	68 55 0f 81 00       	push   $0x810f55
  8003dc:	e8 8f e1 00 00       	call   80e570 <_panic>

008003e1 <serve>:

void
serve(void) {
  8003e1:	55                   	push   %ebp
  8003e2:	89 e5                	mov    %esp,%ebp
  8003e4:	57                   	push   %edi
  8003e5:	56                   	push   %esi
  8003e6:	53                   	push   %ebx
  8003e7:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ea:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8003ed:	e9 9d 00 00 00       	jmp    80048f <serve+0xae>
		perm = 0;
  8003f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f9:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003fe:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800405:	74 1c                	je     800423 <serve+0x42>
	for (i = 0; i < QUEUE_SIZE; i++)
  800407:	83 c0 01             	add    $0x1,%eax
  80040a:	83 f8 14             	cmp    $0x14,%eax
  80040d:	75 ef                	jne    8003fe <serve+0x1d>
		panic("NS: buffer overflow");
  80040f:	83 ec 04             	sub    $0x4,%esp
  800412:	68 aa 0f 81 00       	push   $0x810faa
  800417:	6a 3f                	push   $0x3f
  800419:	68 55 0f 81 00       	push   $0x810f55
  80041e:	e8 4d e1 00 00       	call   80e570 <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800423:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  800429:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042c:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800433:	83 ec 04             	sub    $0x4,%esp
  800436:	57                   	push   %edi
  800437:	53                   	push   %ebx
  800438:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043b:	50                   	push   %eax
  80043c:	e8 8d f1 00 00       	call   80f5ce <ipc_recv>
  800441:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800443:	83 c4 10             	add    $0x10,%esp
  800446:	83 f8 0c             	cmp    $0xc,%eax
  800449:	74 69                	je     8004b4 <serve+0xd3>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80044b:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80044f:	0f 84 ba 00 00 00    	je     80050f <serve+0x12e>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800455:	83 ec 0c             	sub    $0xc,%esp
  800458:	6a 0c                	push   $0xc
  80045a:	e8 21 03 01 00       	call   810780 <malloc>
		if (!args)
  80045f:	83 c4 10             	add    $0x10,%esp
  800462:	85 c0                	test   %eax,%eax
  800464:	0f 84 bd 00 00 00    	je     800527 <serve+0x146>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80046a:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  80046c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80046f:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800472:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  800475:	50                   	push   %eax
  800476:	68 c4 00 80 00       	push   $0x8000c4
  80047b:	68 be 0f 81 00       	push   $0x810fbe
  800480:	6a 00                	push   $0x0
  800482:	e8 50 a1 00 00       	call   80a5d7 <thread_create>
		thread_yield(); // let the thread created run
  800487:	e8 74 a2 00 00       	call   80a700 <thread_yield>
  80048c:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80048f:	bb 00 00 00 00       	mov    $0x0,%ebx
  800494:	e8 f5 a0 00 00       	call   80a58e <thread_wakeups_pending>
  800499:	85 c0                	test   %eax,%eax
  80049b:	0f 84 51 ff ff ff    	je     8003f2 <serve+0x11>
  8004a1:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a4:	0f 8f 48 ff ff ff    	jg     8003f2 <serve+0x11>
			thread_yield();
  8004aa:	e8 51 a2 00 00       	call   80a700 <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004af:	83 c3 01             	add    $0x1,%ebx
  8004b2:	eb e0                	jmp    800494 <serve+0xb3>
			process_timer(whom);
  8004b4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004b7:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  8004bd:	74 23                	je     8004e2 <serve+0x101>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004bf:	83 ec 08             	sub    $0x8,%esp
  8004c2:	56                   	push   %esi
  8004c3:	68 c0 0e 81 00       	push   $0x810ec0
  8004c8:	e8 7e e1 00 00       	call   80e64b <cprintf>
  8004cd:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004d0:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004d6:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004d9:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)
  8004e0:	eb ad                	jmp    80048f <serve+0xae>
	start = sys_time_msec();
  8004e2:	e8 23 ed 00 00       	call   80f20a <sys_time_msec>
  8004e7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004ea:	e8 11 a2 00 00       	call   80a700 <thread_yield>
	now = sys_time_msec();
  8004ef:	e8 16 ed 00 00       	call   80f20a <sys_time_msec>
	ipc_send(envid, to, 0, 0);
  8004f4:	6a 00                	push   $0x0
  8004f6:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  8004f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8004fb:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800501:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  800503:	52                   	push   %edx
  800504:	56                   	push   %esi
  800505:	e8 37 f1 00 00       	call   80f641 <ipc_send>
  80050a:	83 c4 10             	add    $0x10,%esp
  80050d:	eb c1                	jmp    8004d0 <serve+0xef>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80050f:	83 ec 08             	sub    $0x8,%esp
  800512:	ff 75 e4             	pushl  -0x1c(%ebp)
  800515:	68 fc 0e 81 00       	push   $0x810efc
  80051a:	e8 2c e1 00 00       	call   80e64b <cprintf>
			continue; // just leave it hanging...
  80051f:	83 c4 10             	add    $0x10,%esp
  800522:	e9 68 ff ff ff       	jmp    80048f <serve+0xae>
			panic("could not allocate thread args structure");
  800527:	83 ec 04             	sub    $0x4,%esp
  80052a:	68 2c 0f 81 00       	push   $0x810f2c
  80052f:	68 27 01 00 00       	push   $0x127
  800534:	68 55 0f 81 00       	push   $0x810f55
  800539:	e8 32 e0 00 00       	call   80e570 <_panic>

0080053e <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80053e:	55                   	push   %ebp
  80053f:	89 e5                	mov    %esp,%ebp
  800541:	56                   	push   %esi
  800542:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800543:	83 ec 0c             	sub    $0xc,%esp
  800546:	68 cb 0f 81 00       	push   $0x810fcb
  80054b:	e8 84 73 00 00       	call   8078d4 <inet_addr>
  800550:	89 c6                	mov    %eax,%esi
  800552:	c7 04 24 d4 0f 81 00 	movl   $0x810fd4,(%esp)
  800559:	e8 76 73 00 00       	call   8078d4 <inet_addr>
  80055e:	89 c3                	mov    %eax,%ebx
  800560:	c7 04 24 e2 0f 81 00 	movl   $0x810fe2,(%esp)
  800567:	e8 68 73 00 00       	call   8078d4 <inet_addr>
  80056c:	83 c4 0c             	add    $0xc,%esp
  80056f:	56                   	push   %esi
  800570:	53                   	push   %ebx
  800571:	50                   	push   %eax
  800572:	e8 09 fd ff ff       	call   800280 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800577:	e8 65 fe ff ff       	call   8003e1 <serve>

0080057c <umain>:
}

void
umain(int argc, char **argv)
{
  80057c:	55                   	push   %ebp
  80057d:	89 e5                	mov    %esp,%ebp
  80057f:	53                   	push   %ebx
  800580:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  800583:	e8 53 ea 00 00       	call   80efdb <sys_getenvid>
  800588:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  80058a:	c7 05 e8 42 81 00 26 	movl   $0x813a26,0x8142e8
  800591:	3a 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800594:	e8 07 ee 00 00       	call   80f3a0 <fork>
  800599:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  80059e:	85 c0                	test   %eax,%eax
  8005a0:	78 43                	js     8005e5 <umain+0x69>
		panic("error forking");
	else if (timer_envid == 0) {
  8005a2:	74 58                	je     8005fc <umain+0x80>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005a4:	e8 f7 ed 00 00       	call   80f3a0 <fork>
	if (input_envid < 0)
  8005a9:	85 c0                	test   %eax,%eax
  8005ab:	78 65                	js     800612 <umain+0x96>
		panic("error forking");
	else if (input_envid == 0) {
  8005ad:	74 7a                	je     800629 <umain+0xad>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005af:	e8 ec ed 00 00       	call   80f3a0 <fork>
  8005b4:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005b9:	85 c0                	test   %eax,%eax
  8005bb:	78 7a                	js     800637 <umain+0xbb>
		panic("error forking");
	else if (output_envid == 0) {
  8005bd:	0f 84 8b 00 00 00    	je     80064e <umain+0xd2>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005c3:	e8 7e 9f 00 00       	call   80a546 <thread_init>
	thread_create(0, "main", tmain, 0);
  8005c8:	6a 00                	push   $0x0
  8005ca:	68 3e 05 80 00       	push   $0x80053e
  8005cf:	68 fa 0f 81 00       	push   $0x810ffa
  8005d4:	6a 00                	push   $0x0
  8005d6:	e8 fc 9f 00 00       	call   80a5d7 <thread_create>
	thread_yield();
  8005db:	e8 20 a1 00 00       	call   80a700 <thread_yield>
  8005e0:	83 c4 10             	add    $0x10,%esp
  8005e3:	eb 28                	jmp    80060d <umain+0x91>
		panic("error forking");
  8005e5:	83 ec 04             	sub    $0x4,%esp
  8005e8:	68 ec 0f 81 00       	push   $0x810fec
  8005ed:	68 44 01 00 00       	push   $0x144
  8005f2:	68 55 0f 81 00       	push   $0x810f55
  8005f7:	e8 74 df 00 00       	call   80e570 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  8005fc:	83 ec 08             	sub    $0x8,%esp
  8005ff:	68 fa 00 00 00       	push   $0xfa
  800604:	53                   	push   %ebx
  800605:	e8 52 00 00 00       	call   80065c <timer>
		return;
  80060a:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  80060d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800610:	c9                   	leave  
  800611:	c3                   	ret    
		panic("error forking");
  800612:	83 ec 04             	sub    $0x4,%esp
  800615:	68 ec 0f 81 00       	push   $0x810fec
  80061a:	68 4e 01 00 00       	push   $0x14e
  80061f:	68 55 0f 81 00       	push   $0x810f55
  800624:	e8 47 df 00 00       	call   80e570 <_panic>
		input(ns_envid);
  800629:	83 ec 0c             	sub    $0xc,%esp
  80062c:	53                   	push   %ebx
  80062d:	e8 bd 00 00 00       	call   8006ef <input>
		return;
  800632:	83 c4 10             	add    $0x10,%esp
  800635:	eb d6                	jmp    80060d <umain+0x91>
		panic("error forking");
  800637:	83 ec 04             	sub    $0x4,%esp
  80063a:	68 ec 0f 81 00       	push   $0x810fec
  80063f:	68 58 01 00 00       	push   $0x158
  800644:	68 55 0f 81 00       	push   $0x810f55
  800649:	e8 22 df 00 00       	call   80e570 <_panic>
		output(ns_envid);
  80064e:	83 ec 0c             	sub    $0xc,%esp
  800651:	53                   	push   %ebx
  800652:	e8 a3 00 00 00       	call   8006fa <output>
		return;
  800657:	83 c4 10             	add    $0x10,%esp
  80065a:	eb b1                	jmp    80060d <umain+0x91>

0080065c <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80065c:	55                   	push   %ebp
  80065d:	89 e5                	mov    %esp,%ebp
  80065f:	57                   	push   %edi
  800660:	56                   	push   %esi
  800661:	53                   	push   %ebx
  800662:	83 ec 1c             	sub    $0x1c,%esp
  800665:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800668:	e8 9d eb 00 00       	call   80f20a <sys_time_msec>
  80066d:	03 45 0c             	add    0xc(%ebp),%eax
  800670:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800672:	c7 05 e8 42 81 00 2c 	movl   $0x81102c,0x8142e8
  800679:	10 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80067c:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  80067f:	eb 33                	jmp    8006b4 <timer+0x58>
		if (r < 0)
  800681:	85 c0                	test   %eax,%eax
  800683:	78 45                	js     8006ca <timer+0x6e>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800685:	6a 00                	push   $0x0
  800687:	6a 00                	push   $0x0
  800689:	6a 0c                	push   $0xc
  80068b:	56                   	push   %esi
  80068c:	e8 b0 ef 00 00       	call   80f641 <ipc_send>
  800691:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800694:	83 ec 04             	sub    $0x4,%esp
  800697:	6a 00                	push   $0x0
  800699:	6a 00                	push   $0x0
  80069b:	57                   	push   %edi
  80069c:	e8 2d ef 00 00       	call   80f5ce <ipc_recv>
  8006a1:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006a6:	83 c4 10             	add    $0x10,%esp
  8006a9:	39 f0                	cmp    %esi,%eax
  8006ab:	75 2f                	jne    8006dc <timer+0x80>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006ad:	e8 58 eb 00 00       	call   80f20a <sys_time_msec>
  8006b2:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006b4:	e8 51 eb 00 00       	call   80f20a <sys_time_msec>
  8006b9:	89 c2                	mov    %eax,%edx
  8006bb:	85 c0                	test   %eax,%eax
  8006bd:	78 c2                	js     800681 <timer+0x25>
  8006bf:	39 d8                	cmp    %ebx,%eax
  8006c1:	73 be                	jae    800681 <timer+0x25>
			sys_yield();
  8006c3:	e8 32 e9 00 00       	call   80effa <sys_yield>
  8006c8:	eb ea                	jmp    8006b4 <timer+0x58>
			panic("sys_time_msec: %e", r);
  8006ca:	52                   	push   %edx
  8006cb:	68 35 10 81 00       	push   $0x811035
  8006d0:	6a 0f                	push   $0xf
  8006d2:	68 47 10 81 00       	push   $0x811047
  8006d7:	e8 94 de 00 00       	call   80e570 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006dc:	83 ec 08             	sub    $0x8,%esp
  8006df:	50                   	push   %eax
  8006e0:	68 54 10 81 00       	push   $0x811054
  8006e5:	e8 61 df 00 00       	call   80e64b <cprintf>
				continue;
  8006ea:	83 c4 10             	add    $0x10,%esp
  8006ed:	eb a5                	jmp    800694 <timer+0x38>

008006ef <input>:
extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
	binaryname = "ns_input";
  8006ef:	c7 05 e8 42 81 00 8f 	movl   $0x81108f,0x8142e8
  8006f6:	10 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  8006f9:	c3                   	ret    

008006fa <output>:
extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
	binaryname = "ns_output";
  8006fa:	c7 05 e8 42 81 00 98 	movl   $0x811098,0x8142e8
  800701:	10 81 00 

	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
}
  800704:	c3                   	ret    

00800705 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800705:	89 c2                	mov    %eax,%edx
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800707:	83 f8 1f             	cmp    $0x1f,%eax
  80070a:	77 18                	ja     800724 <get_socket+0x1f>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  80070c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80070f:	8d 04 85 60 50 81 00 	lea    0x815060(,%eax,4),%eax

  if (!sock->conn) {
  800716:	8d 14 92             	lea    (%edx,%edx,4),%edx
  800719:	83 3c 95 60 50 81 00 	cmpl   $0x0,0x815060(,%edx,4)
  800720:	00 
  800721:	74 11                	je     800734 <get_socket+0x2f>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  800723:	c3                   	ret    
    set_errno(EBADF);
  800724:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80072b:	00 00 00 
    return NULL;
  80072e:	b8 00 00 00 00       	mov    $0x0,%eax
  800733:	c3                   	ret    
    set_errno(EBADF);
  800734:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80073b:	00 00 00 
    return NULL;
  80073e:	b8 00 00 00 00       	mov    $0x0,%eax
  800743:	eb de                	jmp    800723 <get_socket+0x1e>

00800745 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800745:	55                   	push   %ebp
  800746:	89 e5                	mov    %esp,%ebp
  800748:	57                   	push   %edi
  800749:	56                   	push   %esi
  80074a:	53                   	push   %ebx
  80074b:	83 ec 40             	sub    $0x40,%esp
  80074e:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800751:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800754:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800757:	6a 04                	push   $0x4
  800759:	6a 00                	push   $0x0
  80075b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80075e:	50                   	push   %eax
  80075f:	e8 09 e6 00 00       	call   80ed6d <memset>
  FD_ZERO(&lwriteset);
  800764:	83 c4 0c             	add    $0xc,%esp
  800767:	6a 04                	push   $0x4
  800769:	6a 00                	push   $0x0
  80076b:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80076e:	50                   	push   %eax
  80076f:	e8 f9 e5 00 00       	call   80ed6d <memset>
  FD_ZERO(&lexceptset);
  800774:	83 c4 0c             	add    $0xc,%esp
  800777:	6a 04                	push   $0x4
  800779:	6a 00                	push   $0x0
  80077b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80077e:	50                   	push   %eax
  80077f:	e8 e9 e5 00 00       	call   80ed6d <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800784:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  800787:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  80078e:	bf 00 00 00 00       	mov    $0x0,%edi
  800793:	eb 33                	jmp    8007c8 <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  800795:	89 f8                	mov    %edi,%eax
  800797:	e8 69 ff ff ff       	call   800705 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  80079c:	85 c0                	test   %eax,%eax
  80079e:	74 4c                	je     8007ec <lwip_selscan+0xa7>
  8007a0:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8007a4:	74 16                	je     8007bc <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  8007a6:	b8 01 00 00 00       	mov    $0x1,%eax
  8007ab:	89 f1                	mov    %esi,%ecx
  8007ad:	d3 e0                	shl    %cl,%eax
  8007af:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8007b2:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8007b6:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8007ba:	eb 30                	jmp    8007ec <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8007bc:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8007c1:	74 29                	je     8007ec <lwip_selscan+0xa7>
  8007c3:	eb e1                	jmp    8007a6 <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  8007c5:	83 c7 01             	add    $0x1,%edi
  8007c8:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  8007cb:	7d 53                	jge    800820 <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  8007cd:	8d 5f 07             	lea    0x7(%edi),%ebx
  8007d0:	85 ff                	test   %edi,%edi
  8007d2:	0f 49 df             	cmovns %edi,%ebx
  8007d5:	c1 fb 03             	sar    $0x3,%ebx
  8007d8:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8007db:	89 fe                	mov    %edi,%esi
  8007dd:	83 e6 07             	and    $0x7,%esi
  8007e0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8007e3:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007e7:	0f a3 f0             	bt     %esi,%eax
  8007ea:	72 a9                	jb     800795 <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  8007ec:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8007ef:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007f3:	0f a3 f0             	bt     %esi,%eax
  8007f6:	73 cd                	jae    8007c5 <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  8007f8:	89 f8                	mov    %edi,%eax
  8007fa:	e8 06 ff ff ff       	call   800705 <get_socket>
      if (p_sock && p_sock->sendevent) {
  8007ff:	85 c0                	test   %eax,%eax
  800801:	74 c2                	je     8007c5 <lwip_selscan+0x80>
  800803:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800808:	74 bb                	je     8007c5 <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  80080a:	b8 01 00 00 00       	mov    $0x1,%eax
  80080f:	89 f1                	mov    %esi,%ecx
  800811:	d3 e0                	shl    %cl,%eax
  800813:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800816:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  80081a:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  80081e:	eb a5                	jmp    8007c5 <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  800820:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800823:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800826:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800828:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80082b:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80082e:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800830:	83 ec 04             	sub    $0x4,%esp
  800833:	6a 04                	push   $0x4
  800835:	6a 00                	push   $0x0
  800837:	ff 75 08             	pushl  0x8(%ebp)
  80083a:	e8 2e e5 00 00       	call   80ed6d <memset>
  
  return nready;
}
  80083f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800842:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800845:	5b                   	pop    %ebx
  800846:	5e                   	pop    %esi
  800847:	5f                   	pop    %edi
  800848:	5d                   	pop    %ebp
  800849:	c3                   	ret    

0080084a <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  80084a:	55                   	push   %ebp
  80084b:	89 e5                	mov    %esp,%ebp
  80084d:	57                   	push   %edi
  80084e:	56                   	push   %esi
  80084f:	53                   	push   %ebx
  800850:	83 ec 3c             	sub    $0x3c,%esp
  800853:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800856:	89 cf                	mov    %ecx,%edi
  800858:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  80085b:	e8 a5 fe ff ff       	call   800705 <get_socket>
  if (!sock)
  800860:	85 c0                	test   %eax,%eax
  800862:	0f 84 86 00 00 00    	je     8008ee <lwip_getaddrname+0xa4>
  800868:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  80086a:	83 ec 04             	sub    $0x4,%esp
  80086d:	6a 10                	push   $0x10
  80086f:	6a 00                	push   $0x0
  800871:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800874:	50                   	push   %eax
  800875:	e8 f3 e4 00 00       	call   80ed6d <memset>
  sin.sin_len = sizeof(sin);
  80087a:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  80087e:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800882:	89 f0                	mov    %esi,%eax
  800884:	0f b6 f0             	movzbl %al,%esi
  800887:	56                   	push   %esi
  800888:	8d 45 da             	lea    -0x26(%ebp),%eax
  80088b:	50                   	push   %eax
  80088c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80088f:	50                   	push   %eax
  800890:	ff 33                	pushl  (%ebx)
  800892:	e8 3d a4 00 00       	call   80acd4 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800897:	83 c4 14             	add    $0x14,%esp
  80089a:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80089e:	50                   	push   %eax
  80089f:	e8 21 6e 00 00       	call   8076c5 <htons>
  8008a4:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8008a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8008ab:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8008ae:	83 c4 10             	add    $0x10,%esp
  8008b1:	83 3f 10             	cmpl   $0x10,(%edi)
  8008b4:	76 06                	jbe    8008bc <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8008b6:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8008bc:	83 ec 04             	sub    $0x4,%esp
  8008bf:	ff 37                	pushl  (%edi)
  8008c1:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8008c4:	50                   	push   %eax
  8008c5:	ff 75 c4             	pushl  -0x3c(%ebp)
  8008c8:	e8 4a e5 00 00       	call   80ee17 <memcpy>
  sock_set_errno(sock, 0);
  8008cd:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8008d4:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8008db:	00 00 00 
  return 0;
  8008de:	83 c4 10             	add    $0x10,%esp
  8008e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8008e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8008e9:	5b                   	pop    %ebx
  8008ea:	5e                   	pop    %esi
  8008eb:	5f                   	pop    %edi
  8008ec:	5d                   	pop    %ebp
  8008ed:	c3                   	ret    
    return -1;
  8008ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8008f3:	eb f1                	jmp    8008e6 <lwip_getaddrname+0x9c>

008008f5 <event_callback>:
{
  8008f5:	55                   	push   %ebp
  8008f6:	89 e5                	mov    %esp,%ebp
  8008f8:	57                   	push   %edi
  8008f9:	56                   	push   %esi
  8008fa:	53                   	push   %ebx
  8008fb:	83 ec 1c             	sub    $0x1c,%esp
  8008fe:	8b 7d 08             	mov    0x8(%ebp),%edi
  800901:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  800904:	85 ff                	test   %edi,%edi
  800906:	0f 84 8b 01 00 00    	je     800a97 <event_callback+0x1a2>
    s = conn->socket;
  80090c:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  80090f:	85 db                	test   %ebx,%ebx
  800911:	78 4d                	js     800960 <event_callback+0x6b>
    sock = get_socket(s);
  800913:	89 d8                	mov    %ebx,%eax
  800915:	e8 eb fd ff ff       	call   800705 <get_socket>
  80091a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  80091d:	85 c0                	test   %eax,%eax
  80091f:	0f 84 72 01 00 00    	je     800a97 <event_callback+0x1a2>
  sys_sem_wait(selectsem);
  800925:	83 ec 0c             	sub    $0xc,%esp
  800928:	ff 35 40 50 81 00    	pushl  0x815040
  80092e:	e8 8e 47 00 00       	call   8050c1 <sys_sem_wait>
  switch (evt) {
  800933:	83 c4 10             	add    $0x10,%esp
  800936:	83 fe 01             	cmp    $0x1,%esi
  800939:	0f 84 a1 00 00 00    	je     8009e0 <event_callback+0xeb>
  80093f:	85 f6                	test   %esi,%esi
  800941:	74 68                	je     8009ab <event_callback+0xb6>
  800943:	83 fe 02             	cmp    $0x2,%esi
  800946:	0f 84 9e 00 00 00    	je     8009ea <event_callback+0xf5>
  80094c:	83 fe 03             	cmp    $0x3,%esi
  80094f:	0f 85 a0 00 00 00    	jne    8009f5 <event_callback+0x100>
      sock->sendevent = 0;
  800955:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800958:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  80095e:	eb 53                	jmp    8009b3 <event_callback+0xbe>
      sys_sem_wait(socksem);
  800960:	83 ec 0c             	sub    $0xc,%esp
  800963:	ff 35 44 50 81 00    	pushl  0x815044
  800969:	e8 53 47 00 00       	call   8050c1 <sys_sem_wait>
      if (conn->socket < 0) {
  80096e:	8b 47 1c             	mov    0x1c(%edi),%eax
  800971:	83 c4 10             	add    $0x10,%esp
  800974:	85 c0                	test   %eax,%eax
  800976:	78 13                	js     80098b <event_callback+0x96>
      sys_sem_signal(socksem);
  800978:	83 ec 0c             	sub    $0xc,%esp
  80097b:	ff 35 44 50 81 00    	pushl  0x815044
  800981:	e8 d8 96 00 00       	call   80a05e <sys_sem_signal>
  800986:	83 c4 10             	add    $0x10,%esp
  800989:	eb 88                	jmp    800913 <event_callback+0x1e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  80098b:	85 f6                	test   %esi,%esi
  80098d:	75 06                	jne    800995 <event_callback+0xa0>
          conn->socket--;
  80098f:	83 e8 01             	sub    $0x1,%eax
  800992:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  800995:	83 ec 0c             	sub    $0xc,%esp
  800998:	ff 35 44 50 81 00    	pushl  0x815044
  80099e:	e8 bb 96 00 00       	call   80a05e <sys_sem_signal>
        return;
  8009a3:	83 c4 10             	add    $0x10,%esp
  8009a6:	e9 ec 00 00 00       	jmp    800a97 <event_callback+0x1a2>
      sock->rcvevent++;
  8009ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009ae:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  8009b3:	83 ec 0c             	sub    $0xc,%esp
  8009b6:	ff 35 40 50 81 00    	pushl  0x815040
  8009bc:	e8 9d 96 00 00       	call   80a05e <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  8009c1:	8d 73 07             	lea    0x7(%ebx),%esi
  8009c4:	83 c4 10             	add    $0x10,%esp
  8009c7:	85 db                	test   %ebx,%ebx
  8009c9:	0f 49 f3             	cmovns %ebx,%esi
  8009cc:	c1 fe 03             	sar    $0x3,%esi
  8009cf:	89 d9                	mov    %ebx,%ecx
  8009d1:	83 e1 07             	and    $0x7,%ecx
  8009d4:	bf 01 00 00 00       	mov    $0x1,%edi
  8009d9:	d3 e7                	shl    %cl,%edi
  8009db:	e9 8d 00 00 00       	jmp    800a6d <event_callback+0x178>
      sock->rcvevent--;
  8009e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009e3:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  8009e8:	eb c9                	jmp    8009b3 <event_callback+0xbe>
      sock->sendevent = 1;
  8009ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009ed:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  8009f3:	eb be                	jmp    8009b3 <event_callback+0xbe>
      LWIP_ASSERT("unknown event", 0);
  8009f5:	83 ec 04             	sub    $0x4,%esp
  8009f8:	68 a2 10 81 00       	push   $0x8110a2
  8009fd:	68 17 04 00 00       	push   $0x417
  800a02:	68 b0 10 81 00       	push   $0x8110b0
  800a07:	e8 64 db 00 00       	call   80e570 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a0c:	8b 1b                	mov    (%ebx),%ebx
  800a0e:	85 db                	test   %ebx,%ebx
  800a10:	74 74                	je     800a86 <event_callback+0x191>
      if (scb->sem_signalled == 0) {
  800a12:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800a16:	75 f4                	jne    800a0c <event_callback+0x117>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a18:	8b 43 04             	mov    0x4(%ebx),%eax
  800a1b:	85 c0                	test   %eax,%eax
  800a1d:	74 12                	je     800a31 <event_callback+0x13c>
  800a1f:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a23:	85 f8                	test   %edi,%eax
  800a25:	74 0a                	je     800a31 <event_callback+0x13c>
          if (sock->rcvevent)
  800a27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a2a:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a2f:	75 19                	jne    800a4a <event_callback+0x155>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800a31:	8b 43 08             	mov    0x8(%ebx),%eax
  800a34:	85 c0                	test   %eax,%eax
  800a36:	74 d4                	je     800a0c <event_callback+0x117>
  800a38:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a3c:	85 f8                	test   %edi,%eax
  800a3e:	74 cc                	je     800a0c <event_callback+0x117>
          if (sock->sendevent)
  800a40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a43:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a48:	74 c2                	je     800a0c <event_callback+0x117>
      scb->sem_signalled = 1;
  800a4a:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800a51:	83 ec 0c             	sub    $0xc,%esp
  800a54:	ff 35 40 50 81 00    	pushl  0x815040
  800a5a:	e8 ff 95 00 00       	call   80a05e <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800a5f:	83 c4 04             	add    $0x4,%esp
  800a62:	ff 73 14             	pushl  0x14(%ebx)
  800a65:	e8 f4 95 00 00       	call   80a05e <sys_sem_signal>
    sys_sem_wait(selectsem);
  800a6a:	83 c4 10             	add    $0x10,%esp
  800a6d:	83 ec 0c             	sub    $0xc,%esp
  800a70:	ff 35 40 50 81 00    	pushl  0x815040
  800a76:	e8 46 46 00 00       	call   8050c1 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a7b:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800a81:	83 c4 10             	add    $0x10,%esp
  800a84:	eb 88                	jmp    800a0e <event_callback+0x119>
      sys_sem_signal(selectsem);
  800a86:	83 ec 0c             	sub    $0xc,%esp
  800a89:	ff 35 40 50 81 00    	pushl  0x815040
  800a8f:	e8 ca 95 00 00       	call   80a05e <sys_sem_signal>
      break;
  800a94:	83 c4 10             	add    $0x10,%esp
}
  800a97:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800a9a:	5b                   	pop    %ebx
  800a9b:	5e                   	pop    %esi
  800a9c:	5f                   	pop    %edi
  800a9d:	5d                   	pop    %ebp
  800a9e:	c3                   	ret    

00800a9f <alloc_socket>:
{
  800a9f:	55                   	push   %ebp
  800aa0:	89 e5                	mov    %esp,%ebp
  800aa2:	56                   	push   %esi
  800aa3:	53                   	push   %ebx
  800aa4:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800aa6:	83 ec 0c             	sub    $0xc,%esp
  800aa9:	ff 35 44 50 81 00    	pushl  0x815044
  800aaf:	e8 0d 46 00 00       	call   8050c1 <sys_sem_wait>
  800ab4:	b8 60 50 81 00       	mov    $0x815060,%eax
  800ab9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800abc:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800ac1:	83 38 00             	cmpl   $0x0,(%eax)
  800ac4:	74 23                	je     800ae9 <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800ac6:	83 c3 01             	add    $0x1,%ebx
  800ac9:	83 c0 14             	add    $0x14,%eax
  800acc:	83 fb 20             	cmp    $0x20,%ebx
  800acf:	75 f0                	jne    800ac1 <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800ad1:	83 ec 0c             	sub    $0xc,%esp
  800ad4:	ff 35 44 50 81 00    	pushl  0x815044
  800ada:	e8 7f 95 00 00       	call   80a05e <sys_sem_signal>
  return -1;
  800adf:	83 c4 10             	add    $0x10,%esp
  800ae2:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800ae7:	eb 55                	jmp    800b3e <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800ae9:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800aec:	c1 e2 02             	shl    $0x2,%edx
  800aef:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800af5:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800afc:	00 00 00 
      sockets[i].lastoffset = 0;
  800aff:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800b06:	00 00 
      sockets[i].rcvevent   = 0;
  800b08:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800b0f:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800b11:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800b18:	01 00 
      sockets[i].flags      = 0;
  800b1a:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800b21:	00 00 
      sockets[i].err        = 0;
  800b23:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800b2a:	00 00 00 
      sys_sem_signal(socksem);
  800b2d:	83 ec 0c             	sub    $0xc,%esp
  800b30:	ff 35 44 50 81 00    	pushl  0x815044
  800b36:	e8 23 95 00 00       	call   80a05e <sys_sem_signal>
      return i;
  800b3b:	83 c4 10             	add    $0x10,%esp
}
  800b3e:	89 d8                	mov    %ebx,%eax
  800b40:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800b43:	5b                   	pop    %ebx
  800b44:	5e                   	pop    %esi
  800b45:	5d                   	pop    %ebp
  800b46:	c3                   	ret    

00800b47 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800b47:	55                   	push   %ebp
  800b48:	89 e5                	mov    %esp,%ebp
  800b4a:	53                   	push   %ebx
  800b4b:	83 ec 04             	sub    $0x4,%esp
  800b4e:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b51:	85 c0                	test   %eax,%eax
  800b53:	74 39                	je     800b8e <lwip_getsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800b55:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800b57:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800b5a:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800b5d:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800b60:	83 fa 06             	cmp    $0x6,%edx
  800b63:	0f 84 37 01 00 00    	je     800ca0 <lwip_getsockopt_internal+0x159>
  800b69:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800b6f:	74 34                	je     800ba5 <lwip_getsockopt_internal+0x5e>
  800b71:	85 d2                	test   %edx,%edx
  800b73:	0f 84 f9 00 00 00    	je     800c72 <lwip_getsockopt_internal+0x12b>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800b79:	83 ec 0c             	sub    $0xc,%esp
  800b7c:	8b 03                	mov    (%ebx),%eax
  800b7e:	ff 70 10             	pushl  0x10(%eax)
  800b81:	e8 d8 94 00 00       	call   80a05e <sys_sem_signal>
}
  800b86:	83 c4 10             	add    $0x10,%esp
  800b89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800b8c:	c9                   	leave  
  800b8d:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b8e:	83 ec 04             	sub    $0x4,%esp
  800b91:	68 c7 10 81 00       	push   $0x8110c7
  800b96:	68 38 05 00 00       	push   $0x538
  800b9b:	68 b0 10 81 00       	push   $0x8110b0
  800ba0:	e8 cb d9 00 00       	call   80e570 <_panic>
  800ba5:	83 f9 20             	cmp    $0x20,%ecx
  800ba8:	74 65                	je     800c0f <lwip_getsockopt_internal+0xc8>
  800baa:	7e 55                	jle    800c01 <lwip_getsockopt_internal+0xba>
  800bac:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800bb2:	74 6d                	je     800c21 <lwip_getsockopt_internal+0xda>
  800bb4:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800bba:	0f 84 9f 00 00 00    	je     800c5f <lwip_getsockopt_internal+0x118>
  800bc0:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800bc6:	75 b1                	jne    800b79 <lwip_getsockopt_internal+0x32>
      if (sock->err == 0) {
  800bc8:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800bcc:	75 22                	jne    800bf0 <lwip_getsockopt_internal+0xa9>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800bce:	8b 13                	mov    (%ebx),%edx
  800bd0:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  800bd4:	f7 da                	neg    %edx
  800bd6:	b9 05 00 00 00       	mov    $0x5,%ecx
  800bdb:	83 fa 0e             	cmp    $0xe,%edx
  800bde:	77 07                	ja     800be7 <lwip_getsockopt_internal+0xa0>
  800be0:	8b 0c 95 80 11 81 00 	mov    0x811180(,%edx,4),%ecx
  800be7:	89 4b 10             	mov    %ecx,0x10(%ebx)
  800bea:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
      *(int *)optval = sock->err;
  800bf0:	8b 53 10             	mov    0x10(%ebx),%edx
  800bf3:	89 10                	mov    %edx,(%eax)
      sock->err = 0;
  800bf5:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800bfc:	e9 78 ff ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
  800c01:	83 f9 02             	cmp    $0x2,%ecx
  800c04:	74 09                	je     800c0f <lwip_getsockopt_internal+0xc8>
  800c06:	83 f9 08             	cmp    $0x8,%ecx
  800c09:	0f 85 6a ff ff ff    	jne    800b79 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800c0f:	8b 13                	mov    (%ebx),%edx
  800c11:	8b 52 08             	mov    0x8(%edx),%edx
  800c14:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  800c18:	21 d1                	and    %edx,%ecx
  800c1a:	89 08                	mov    %ecx,(%eax)
      break;
  800c1c:	e9 58 ff ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800c21:	8b 13                	mov    (%ebx),%edx
  800c23:	8b 12                	mov    (%edx),%edx
  800c25:	89 d1                	mov    %edx,%ecx
  800c27:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
  800c2d:	83 f9 20             	cmp    $0x20,%ecx
  800c30:	74 22                	je     800c54 <lwip_getsockopt_internal+0x10d>
  800c32:	83 f9 40             	cmp    $0x40,%ecx
  800c35:	74 12                	je     800c49 <lwip_getsockopt_internal+0x102>
        *(int*)optval = sock->conn->type;
  800c37:	83 f9 10             	cmp    $0x10,%ecx
  800c3a:	b9 01 00 00 00       	mov    $0x1,%ecx
  800c3f:	0f 44 d1             	cmove  %ecx,%edx
  800c42:	89 10                	mov    %edx,(%eax)
  800c44:	e9 30 ff ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_RAW;
  800c49:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        break;
  800c4f:	e9 25 ff ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_DGRAM;
  800c54:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
  800c5a:	e9 1a ff ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800c5f:	8b 13                	mov    (%ebx),%edx
  800c61:	8b 52 08             	mov    0x8(%edx),%edx
  800c64:	0f b6 52 10          	movzbl 0x10(%edx),%edx
  800c68:	83 e2 01             	and    $0x1,%edx
  800c6b:	89 10                	mov    %edx,(%eax)
      break;
  800c6d:	e9 07 ff ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
  800c72:	83 f9 01             	cmp    $0x1,%ecx
  800c75:	74 19                	je     800c90 <lwip_getsockopt_internal+0x149>
  800c77:	83 f9 02             	cmp    $0x2,%ecx
  800c7a:	0f 85 f9 fe ff ff    	jne    800b79 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800c80:	8b 13                	mov    (%ebx),%edx
  800c82:	8b 52 08             	mov    0x8(%edx),%edx
  800c85:	0f b6 52 0b          	movzbl 0xb(%edx),%edx
  800c89:	89 10                	mov    %edx,(%eax)
      break;
  800c8b:	e9 e9 fe ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800c90:	8b 13                	mov    (%ebx),%edx
  800c92:	8b 52 08             	mov    0x8(%edx),%edx
  800c95:	0f b6 52 0a          	movzbl 0xa(%edx),%edx
  800c99:	89 10                	mov    %edx,(%eax)
      break;
  800c9b:	e9 d9 fe ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
  800ca0:	83 f9 01             	cmp    $0x1,%ecx
  800ca3:	74 1b                	je     800cc0 <lwip_getsockopt_internal+0x179>
  800ca5:	83 f9 02             	cmp    $0x2,%ecx
  800ca8:	0f 85 cb fe ff ff    	jne    800b79 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800cae:	8b 13                	mov    (%ebx),%edx
  800cb0:	8b 52 08             	mov    0x8(%edx),%edx
  800cb3:	8b 92 9c 00 00 00    	mov    0x9c(%edx),%edx
  800cb9:	89 10                	mov    %edx,(%eax)
      break;
  800cbb:	e9 b9 fe ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800cc0:	8b 13                	mov    (%ebx),%edx
  800cc2:	8b 52 08             	mov    0x8(%edx),%edx
  800cc5:	0f b6 52 20          	movzbl 0x20(%edx),%edx
  800cc9:	83 e2 40             	and    $0x40,%edx
  800ccc:	0f b6 d2             	movzbl %dl,%edx
  800ccf:	89 10                	mov    %edx,(%eax)
      break;
  800cd1:	e9 a3 fe ff ff       	jmp    800b79 <lwip_getsockopt_internal+0x32>

00800cd6 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800cd6:	55                   	push   %ebp
  800cd7:	89 e5                	mov    %esp,%ebp
  800cd9:	53                   	push   %ebx
  800cda:	83 ec 04             	sub    $0x4,%esp
  800cdd:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800ce0:	85 c0                	test   %eax,%eax
  800ce2:	74 35                	je     800d19 <lwip_setsockopt_internal+0x43>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800ce4:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800ce6:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800ce9:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800cec:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800cef:	83 fa 06             	cmp    $0x6,%edx
  800cf2:	0f 84 aa 00 00 00    	je     800da2 <lwip_setsockopt_internal+0xcc>
  800cf8:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800cfe:	74 30                	je     800d30 <lwip_setsockopt_internal+0x5a>
  800d00:	85 d2                	test   %edx,%edx
  800d02:	74 76                	je     800d7a <lwip_setsockopt_internal+0xa4>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800d04:	83 ec 0c             	sub    $0xc,%esp
  800d07:	8b 03                	mov    (%ebx),%eax
  800d09:	ff 70 10             	pushl  0x10(%eax)
  800d0c:	e8 4d 93 00 00       	call   80a05e <sys_sem_signal>
}
  800d11:	83 c4 10             	add    $0x10,%esp
  800d14:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800d17:	c9                   	leave  
  800d18:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d19:	83 ec 04             	sub    $0x4,%esp
  800d1c:	68 c7 10 81 00       	push   $0x8110c7
  800d21:	68 ae 06 00 00       	push   $0x6ae
  800d26:	68 b0 10 81 00       	push   $0x8110b0
  800d2b:	e8 40 d8 00 00       	call   80e570 <_panic>
  800d30:	83 f9 20             	cmp    $0x20,%ecx
  800d33:	74 0d                	je     800d42 <lwip_setsockopt_internal+0x6c>
  800d35:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800d3b:	74 22                	je     800d5f <lwip_setsockopt_internal+0x89>
  800d3d:	83 f9 08             	cmp    $0x8,%ecx
  800d40:	75 c2                	jne    800d04 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800d42:	83 38 00             	cmpl   $0x0,(%eax)
  800d45:	74 0b                	je     800d52 <lwip_setsockopt_internal+0x7c>
        sock->conn->pcb.ip->so_options |= optname;
  800d47:	8b 03                	mov    (%ebx),%eax
  800d49:	8b 40 08             	mov    0x8(%eax),%eax
  800d4c:	66 09 48 08          	or     %cx,0x8(%eax)
  800d50:	eb b2                	jmp    800d04 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.ip->so_options &= ~optname;
  800d52:	8b 03                	mov    (%ebx),%eax
  800d54:	8b 40 08             	mov    0x8(%eax),%eax
  800d57:	f7 d1                	not    %ecx
  800d59:	66 21 48 08          	and    %cx,0x8(%eax)
  800d5d:	eb a5                	jmp    800d04 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800d5f:	83 38 00             	cmpl   $0x0,(%eax)
  800d62:	74 0b                	je     800d6f <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800d64:	8b 03                	mov    (%ebx),%eax
  800d66:	8b 40 08             	mov    0x8(%eax),%eax
  800d69:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800d6d:	eb 95                	jmp    800d04 <lwip_setsockopt_internal+0x2e>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800d6f:	8b 03                	mov    (%ebx),%eax
  800d71:	8b 40 08             	mov    0x8(%eax),%eax
  800d74:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800d78:	eb 8a                	jmp    800d04 <lwip_setsockopt_internal+0x2e>
  800d7a:	83 f9 01             	cmp    $0x1,%ecx
  800d7d:	74 14                	je     800d93 <lwip_setsockopt_internal+0xbd>
  800d7f:	83 f9 02             	cmp    $0x2,%ecx
  800d82:	75 80                	jne    800d04 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800d84:	8b 13                	mov    (%ebx),%edx
  800d86:	8b 52 08             	mov    0x8(%edx),%edx
  800d89:	8b 00                	mov    (%eax),%eax
  800d8b:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800d8e:	e9 71 ff ff ff       	jmp    800d04 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800d93:	8b 13                	mov    (%ebx),%edx
  800d95:	8b 52 08             	mov    0x8(%edx),%edx
  800d98:	8b 00                	mov    (%eax),%eax
  800d9a:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800d9d:	e9 62 ff ff ff       	jmp    800d04 <lwip_setsockopt_internal+0x2e>
  800da2:	83 f9 01             	cmp    $0x1,%ecx
  800da5:	74 1b                	je     800dc2 <lwip_setsockopt_internal+0xec>
  800da7:	83 f9 02             	cmp    $0x2,%ecx
  800daa:	0f 85 54 ff ff ff    	jne    800d04 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800db0:	8b 13                	mov    (%ebx),%edx
  800db2:	8b 52 08             	mov    0x8(%edx),%edx
  800db5:	8b 00                	mov    (%eax),%eax
  800db7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800dbd:	e9 42 ff ff ff       	jmp    800d04 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800dc2:	83 38 00             	cmpl   $0x0,(%eax)
  800dc5:	74 0e                	je     800dd5 <lwip_setsockopt_internal+0xff>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800dc7:	8b 03                	mov    (%ebx),%eax
  800dc9:	8b 40 08             	mov    0x8(%eax),%eax
  800dcc:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800dd0:	e9 2f ff ff ff       	jmp    800d04 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800dd5:	8b 03                	mov    (%ebx),%eax
  800dd7:	8b 40 08             	mov    0x8(%eax),%eax
  800dda:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800dde:	e9 21 ff ff ff       	jmp    800d04 <lwip_setsockopt_internal+0x2e>

00800de3 <lwip_socket_init>:
{
  800de3:	55                   	push   %ebp
  800de4:	89 e5                	mov    %esp,%ebp
  800de6:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800de9:	6a 01                	push   $0x1
  800deb:	e8 b1 8f 00 00       	call   809da1 <sys_sem_new>
  800df0:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800df5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800dfc:	e8 a0 8f 00 00       	call   809da1 <sys_sem_new>
  800e01:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800e06:	83 c4 10             	add    $0x10,%esp
  800e09:	c9                   	leave  
  800e0a:	c3                   	ret    

00800e0b <lwip_accept>:
{
  800e0b:	55                   	push   %ebp
  800e0c:	89 e5                	mov    %esp,%ebp
  800e0e:	57                   	push   %edi
  800e0f:	56                   	push   %esi
  800e10:	53                   	push   %ebx
  800e11:	83 ec 3c             	sub    $0x3c,%esp
  800e14:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800e17:	8b 45 08             	mov    0x8(%ebp),%eax
  800e1a:	e8 e6 f8 ff ff       	call   800705 <get_socket>
  if (!sock)
  800e1f:	85 c0                	test   %eax,%eax
  800e21:	0f 84 8c 01 00 00    	je     800fb3 <lwip_accept+0x1a8>
  800e27:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800e29:	83 ec 0c             	sub    $0xc,%esp
  800e2c:	ff 30                	pushl  (%eax)
  800e2e:	e8 57 a0 00 00       	call   80ae8a <netconn_accept>
  800e33:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800e35:	83 c4 10             	add    $0x10,%esp
  800e38:	85 c0                	test   %eax,%eax
  800e3a:	0f 84 de 00 00 00    	je     800f1e <lwip_accept+0x113>
  err = netconn_peer(newconn, &naddr, &port);
  800e40:	6a 00                	push   $0x0
  800e42:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800e45:	50                   	push   %eax
  800e46:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800e49:	50                   	push   %eax
  800e4a:	53                   	push   %ebx
  800e4b:	e8 84 9e 00 00       	call   80acd4 <netconn_getaddr>
  800e50:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800e53:	83 c4 10             	add    $0x10,%esp
  800e56:	84 c0                	test   %al,%al
  800e58:	0f 85 e9 00 00 00    	jne    800f47 <lwip_accept+0x13c>
  memset(&sin, 0, sizeof(sin));
  800e5e:	83 ec 04             	sub    $0x4,%esp
  800e61:	6a 10                	push   $0x10
  800e63:	6a 00                	push   $0x0
  800e65:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800e68:	50                   	push   %eax
  800e69:	e8 ff de 00 00       	call   80ed6d <memset>
  sin.sin_len = sizeof(sin);
  800e6e:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800e72:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800e76:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800e7a:	89 04 24             	mov    %eax,(%esp)
  800e7d:	e8 43 68 00 00       	call   8076c5 <htons>
  800e82:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800e86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800e89:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800e8c:	83 c4 10             	add    $0x10,%esp
  800e8f:	83 3f 10             	cmpl   $0x10,(%edi)
  800e92:	76 06                	jbe    800e9a <lwip_accept+0x8f>
    *addrlen = sizeof(sin);
  800e94:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800e9a:	83 ec 04             	sub    $0x4,%esp
  800e9d:	ff 37                	pushl  (%edi)
  800e9f:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800ea2:	50                   	push   %eax
  800ea3:	ff 75 0c             	pushl  0xc(%ebp)
  800ea6:	e8 6c df 00 00       	call   80ee17 <memcpy>
  newsock = alloc_socket(newconn);
  800eab:	89 d8                	mov    %ebx,%eax
  800ead:	e8 ed fb ff ff       	call   800a9f <alloc_socket>
  800eb2:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800eb4:	83 c4 10             	add    $0x10,%esp
  800eb7:	83 f8 ff             	cmp    $0xffffffff,%eax
  800eba:	0f 84 ba 00 00 00    	je     800f7a <lwip_accept+0x16f>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800ec0:	83 f8 1f             	cmp    $0x1f,%eax
  800ec3:	0f 87 d3 00 00 00    	ja     800f9c <lwip_accept+0x191>
  newconn->callback = event_callback;
  800ec9:	c7 43 2c f5 08 80 00 	movl   $0x8008f5,0x2c(%ebx)
  sys_sem_wait(socksem);
  800ed0:	83 ec 0c             	sub    $0xc,%esp
  800ed3:	ff 35 44 50 81 00    	pushl  0x815044
  800ed9:	e8 e3 41 00 00       	call   8050c1 <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  800ede:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800ee1:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  800ee5:	f7 d2                	not    %edx
  800ee7:	66 01 14 85 6a 50 81 	add    %dx,0x81506a(,%eax,4)
  800eee:	00 
  newconn->socket = newsock;
  800eef:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  800ef2:	83 c4 04             	add    $0x4,%esp
  800ef5:	ff 35 44 50 81 00    	pushl  0x815044
  800efb:	e8 5e 91 00 00       	call   80a05e <sys_sem_signal>
  sock_set_errno(sock, 0);
  800f00:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  800f07:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800f0e:	00 00 00 
  return newsock;
  800f11:	83 c4 10             	add    $0x10,%esp
}
  800f14:	89 f8                	mov    %edi,%eax
  800f16:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800f19:	5b                   	pop    %ebx
  800f1a:	5e                   	pop    %esi
  800f1b:	5f                   	pop    %edi
  800f1c:	5d                   	pop    %ebp
  800f1d:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800f1e:	8b 06                	mov    (%esi),%eax
  800f20:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800f24:	f7 d8                	neg    %eax
  800f26:	ba 05 00 00 00       	mov    $0x5,%edx
  800f2b:	83 f8 0e             	cmp    $0xe,%eax
  800f2e:	77 07                	ja     800f37 <lwip_accept+0x12c>
  800f30:	8b 14 85 80 11 81 00 	mov    0x811180(,%eax,4),%edx
  800f37:	89 56 10             	mov    %edx,0x10(%esi)
  800f3a:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f40:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800f45:	eb cd                	jmp    800f14 <lwip_accept+0x109>
    netconn_delete(newconn);
  800f47:	83 ec 0c             	sub    $0xc,%esp
  800f4a:	53                   	push   %ebx
  800f4b:	e8 1c 9d 00 00       	call   80ac6c <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800f50:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800f54:	f7 d8                	neg    %eax
  800f56:	83 c4 10             	add    $0x10,%esp
  800f59:	ba 05 00 00 00       	mov    $0x5,%edx
  800f5e:	83 f8 0e             	cmp    $0xe,%eax
  800f61:	77 07                	ja     800f6a <lwip_accept+0x15f>
  800f63:	8b 14 85 80 11 81 00 	mov    0x811180(,%eax,4),%edx
  800f6a:	89 56 10             	mov    %edx,0x10(%esi)
  800f6d:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f73:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800f78:	eb 9a                	jmp    800f14 <lwip_accept+0x109>
    netconn_delete(newconn);
  800f7a:	83 ec 0c             	sub    $0xc,%esp
  800f7d:	53                   	push   %ebx
  800f7e:	e8 e9 9c 00 00       	call   80ac6c <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800f83:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  800f8a:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  800f91:	00 00 00 
    return -1;
  800f94:	83 c4 10             	add    $0x10,%esp
  800f97:	e9 78 ff ff ff       	jmp    800f14 <lwip_accept+0x109>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800f9c:	83 ec 04             	sub    $0x4,%esp
  800f9f:	68 d3 10 81 00       	push   $0x8110d3
  800fa4:	68 25 01 00 00       	push   $0x125
  800fa9:	68 b0 10 81 00       	push   $0x8110b0
  800fae:	e8 bd d5 00 00       	call   80e570 <_panic>
    return -1;
  800fb3:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800fb8:	e9 57 ff ff ff       	jmp    800f14 <lwip_accept+0x109>

00800fbd <lwip_bind>:
{
  800fbd:	55                   	push   %ebp
  800fbe:	89 e5                	mov    %esp,%ebp
  800fc0:	56                   	push   %esi
  800fc1:	53                   	push   %ebx
  800fc2:	83 ec 10             	sub    $0x10,%esp
  800fc5:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  800fc8:	8b 45 08             	mov    0x8(%ebp),%eax
  800fcb:	e8 35 f7 ff ff       	call   800705 <get_socket>
  if (!sock)
  800fd0:	85 c0                	test   %eax,%eax
  800fd2:	0f 84 94 00 00 00    	je     80106c <lwip_bind+0xaf>
  800fd8:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  800fda:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  800fde:	75 4f                	jne    80102f <lwip_bind+0x72>
  800fe0:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  800fe4:	75 49                	jne    80102f <lwip_bind+0x72>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  800fe6:	8b 46 04             	mov    0x4(%esi),%eax
  800fe9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  800fec:	83 ec 0c             	sub    $0xc,%esp
  800fef:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  800ff3:	50                   	push   %eax
  800ff4:	e8 d9 66 00 00       	call   8076d2 <ntohs>
  800ff9:	83 c4 0c             	add    $0xc,%esp
  800ffc:	0f b7 c0             	movzwl %ax,%eax
  800fff:	50                   	push   %eax
  801000:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801003:	50                   	push   %eax
  801004:	ff 33                	pushl  (%ebx)
  801006:	e8 55 9d 00 00       	call   80ad60 <netconn_bind>
  if (err != ERR_OK) {
  80100b:	83 c4 10             	add    $0x10,%esp
  80100e:	84 c0                	test   %al,%al
  801010:	75 34                	jne    801046 <lwip_bind+0x89>
  sock_set_errno(sock, 0);
  801012:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801019:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801020:	00 00 00 
  return 0;
  801023:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801028:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80102b:	5b                   	pop    %ebx
  80102c:	5e                   	pop    %esi
  80102d:	5d                   	pop    %ebp
  80102e:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80102f:	83 ec 04             	sub    $0x4,%esp
  801032:	68 e8 10 81 00       	push   $0x8110e8
  801037:	68 4a 01 00 00       	push   $0x14a
  80103c:	68 b0 10 81 00       	push   $0x8110b0
  801041:	e8 2a d5 00 00       	call   80e570 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801046:	0f be c0             	movsbl %al,%eax
  801049:	f7 d8                	neg    %eax
  80104b:	ba 05 00 00 00       	mov    $0x5,%edx
  801050:	83 f8 0e             	cmp    $0xe,%eax
  801053:	77 07                	ja     80105c <lwip_bind+0x9f>
  801055:	8b 14 85 80 11 81 00 	mov    0x811180(,%eax,4),%edx
  80105c:	89 53 10             	mov    %edx,0x10(%ebx)
  80105f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801065:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80106a:	eb bc                	jmp    801028 <lwip_bind+0x6b>
    return -1;
  80106c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801071:	eb b5                	jmp    801028 <lwip_bind+0x6b>

00801073 <lwip_close>:
{
  801073:	55                   	push   %ebp
  801074:	89 e5                	mov    %esp,%ebp
  801076:	53                   	push   %ebx
  801077:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  80107a:	8b 45 08             	mov    0x8(%ebp),%eax
  80107d:	e8 83 f6 ff ff       	call   800705 <get_socket>
  if (!sock) {
  801082:	85 c0                	test   %eax,%eax
  801084:	74 6f                	je     8010f5 <lwip_close+0x82>
  801086:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  801088:	83 ec 0c             	sub    $0xc,%esp
  80108b:	ff 30                	pushl  (%eax)
  80108d:	e8 da 9b 00 00       	call   80ac6c <netconn_delete>
  sys_sem_wait(socksem);
  801092:	83 c4 04             	add    $0x4,%esp
  801095:	ff 35 44 50 81 00    	pushl  0x815044
  80109b:	e8 21 40 00 00       	call   8050c1 <sys_sem_wait>
  if (sock->lastdata) {
  8010a0:	8b 43 04             	mov    0x4(%ebx),%eax
  8010a3:	83 c4 10             	add    $0x10,%esp
  8010a6:	85 c0                	test   %eax,%eax
  8010a8:	74 0c                	je     8010b6 <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  8010aa:	83 ec 0c             	sub    $0xc,%esp
  8010ad:	50                   	push   %eax
  8010ae:	e8 8f 13 00 00       	call   802442 <netbuf_delete>
  8010b3:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  8010b6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8010bd:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8010c3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8010c9:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8010d0:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8010d7:	00 00 00 
  sys_sem_signal(socksem);
  8010da:	83 ec 0c             	sub    $0xc,%esp
  8010dd:	ff 35 44 50 81 00    	pushl  0x815044
  8010e3:	e8 76 8f 00 00       	call   80a05e <sys_sem_signal>
  return 0;
  8010e8:	83 c4 10             	add    $0x10,%esp
  8010eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8010f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8010f3:	c9                   	leave  
  8010f4:	c3                   	ret    
    return -1;
  8010f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010fa:	eb f4                	jmp    8010f0 <lwip_close+0x7d>

008010fc <lwip_connect>:
{
  8010fc:	55                   	push   %ebp
  8010fd:	89 e5                	mov    %esp,%ebp
  8010ff:	56                   	push   %esi
  801100:	53                   	push   %ebx
  801101:	83 ec 10             	sub    $0x10,%esp
  801104:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  801107:	8b 45 08             	mov    0x8(%ebp),%eax
  80110a:	e8 f6 f5 ff ff       	call   800705 <get_socket>
  if (!sock)
  80110f:	85 c0                	test   %eax,%eax
  801111:	0f 84 94 00 00 00    	je     8011ab <lwip_connect+0xaf>
  801117:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801119:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80111d:	75 4f                	jne    80116e <lwip_connect+0x72>
  80111f:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801123:	75 49                	jne    80116e <lwip_connect+0x72>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801125:	8b 46 04             	mov    0x4(%esi),%eax
  801128:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80112b:	83 ec 0c             	sub    $0xc,%esp
  80112e:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801132:	50                   	push   %eax
  801133:	e8 9a 65 00 00       	call   8076d2 <ntohs>
  801138:	83 c4 0c             	add    $0xc,%esp
  80113b:	0f b7 c0             	movzwl %ax,%eax
  80113e:	50                   	push   %eax
  80113f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801142:	50                   	push   %eax
  801143:	ff 33                	pushl  (%ebx)
  801145:	e8 67 9c 00 00       	call   80adb1 <netconn_connect>
  if (err != ERR_OK) {
  80114a:	83 c4 10             	add    $0x10,%esp
  80114d:	84 c0                	test   %al,%al
  80114f:	75 34                	jne    801185 <lwip_connect+0x89>
  sock_set_errno(sock, 0);
  801151:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801158:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80115f:	00 00 00 
  return 0;
  801162:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801167:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80116a:	5b                   	pop    %ebx
  80116b:	5e                   	pop    %esi
  80116c:	5d                   	pop    %ebp
  80116d:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80116e:	83 ec 04             	sub    $0x4,%esp
  801171:	68 03 11 81 00       	push   $0x811103
  801176:	68 86 01 00 00       	push   $0x186
  80117b:	68 b0 10 81 00       	push   $0x8110b0
  801180:	e8 eb d3 00 00       	call   80e570 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801185:	0f be c0             	movsbl %al,%eax
  801188:	f7 d8                	neg    %eax
  80118a:	ba 05 00 00 00       	mov    $0x5,%edx
  80118f:	83 f8 0e             	cmp    $0xe,%eax
  801192:	77 07                	ja     80119b <lwip_connect+0x9f>
  801194:	8b 14 85 80 11 81 00 	mov    0x811180(,%eax,4),%edx
  80119b:	89 53 10             	mov    %edx,0x10(%ebx)
  80119e:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8011a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011a9:	eb bc                	jmp    801167 <lwip_connect+0x6b>
    return -1;
  8011ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011b0:	eb b5                	jmp    801167 <lwip_connect+0x6b>

008011b2 <lwip_listen>:
{
  8011b2:	55                   	push   %ebp
  8011b3:	89 e5                	mov    %esp,%ebp
  8011b5:	56                   	push   %esi
  8011b6:	53                   	push   %ebx
  8011b7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  8011ba:	8b 45 08             	mov    0x8(%ebp),%eax
  8011bd:	e8 43 f5 ff ff       	call   800705 <get_socket>
  if (!sock)
  8011c2:	85 c0                	test   %eax,%eax
  8011c4:	74 6f                	je     801235 <lwip_listen+0x83>
  8011c6:	89 c6                	mov    %eax,%esi
  8011c8:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8011ce:	b8 ff 00 00 00       	mov    $0xff,%eax
  8011d3:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  8011d6:	83 ec 08             	sub    $0x8,%esp
  8011d9:	85 db                	test   %ebx,%ebx
  8011db:	b8 00 00 00 00       	mov    $0x0,%eax
  8011e0:	0f 48 d8             	cmovs  %eax,%ebx
  8011e3:	53                   	push   %ebx
  8011e4:	ff 36                	pushl  (%esi)
  8011e6:	e8 5b 9c 00 00       	call   80ae46 <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  8011eb:	83 c4 10             	add    $0x10,%esp
  8011ee:	84 c0                	test   %al,%al
  8011f0:	75 1d                	jne    80120f <lwip_listen+0x5d>
  sock_set_errno(sock, 0);
  8011f2:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8011f9:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801200:	00 00 00 
  return 0;
  801203:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801208:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80120b:	5b                   	pop    %ebx
  80120c:	5e                   	pop    %esi
  80120d:	5d                   	pop    %ebp
  80120e:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  80120f:	0f be c0             	movsbl %al,%eax
  801212:	f7 d8                	neg    %eax
  801214:	ba 05 00 00 00       	mov    $0x5,%edx
  801219:	83 f8 0e             	cmp    $0xe,%eax
  80121c:	77 07                	ja     801225 <lwip_listen+0x73>
  80121e:	8b 14 85 80 11 81 00 	mov    0x811180(,%eax,4),%edx
  801225:	89 56 10             	mov    %edx,0x10(%esi)
  801228:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80122e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801233:	eb d3                	jmp    801208 <lwip_listen+0x56>
    return -1;
  801235:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80123a:	eb cc                	jmp    801208 <lwip_listen+0x56>

0080123c <lwip_recvfrom>:
{
  80123c:	55                   	push   %ebp
  80123d:	89 e5                	mov    %esp,%ebp
  80123f:	57                   	push   %edi
  801240:	56                   	push   %esi
  801241:	53                   	push   %ebx
  801242:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  801245:	8b 45 08             	mov    0x8(%ebp),%eax
  801248:	e8 b8 f4 ff ff       	call   800705 <get_socket>
  if (!sock)
  80124d:	85 c0                	test   %eax,%eax
  80124f:	0f 84 1c 02 00 00    	je     801471 <lwip_recvfrom+0x235>
  801255:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  801257:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80125d:	8b 45 14             	mov    0x14(%ebp),%eax
  801260:	83 e0 08             	and    $0x8,%eax
  801263:	89 45 b8             	mov    %eax,-0x48(%ebp)
  801266:	e9 a7 00 00 00       	jmp    801312 <lwip_recvfrom+0xd6>
  80126b:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  80126f:	75 06                	jne    801277 <lwip_recvfrom+0x3b>
  801271:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  801275:	74 07                	je     80127e <lwip_recvfrom+0x42>
  801277:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  80127c:	74 56                	je     8012d4 <lwip_recvfrom+0x98>
      sock->lastdata = buf = netconn_recv(sock->conn);
  80127e:	83 ec 0c             	sub    $0xc,%esp
  801281:	ff 37                	pushl  (%edi)
  801283:	e8 74 9c 00 00       	call   80aefc <netconn_recv>
  801288:	89 c6                	mov    %eax,%esi
  80128a:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  80128d:	83 c4 10             	add    $0x10,%esp
  801290:	85 c0                	test   %eax,%eax
  801292:	0f 85 85 00 00 00    	jne    80131d <lwip_recvfrom+0xe1>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801298:	8b 17                	mov    (%edi),%edx
  80129a:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80129e:	74 0b                	je     8012ab <lwip_recvfrom+0x6f>
  8012a0:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8012a5:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8012a9:	74 17                	je     8012c2 <lwip_recvfrom+0x86>
  8012ab:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8012af:	f7 da                	neg    %edx
  8012b1:	b8 05 00 00 00       	mov    $0x5,%eax
  8012b6:	83 fa 0e             	cmp    $0xe,%edx
  8012b9:	77 07                	ja     8012c2 <lwip_recvfrom+0x86>
  8012bb:	8b 04 95 80 11 81 00 	mov    0x811180(,%edx,4),%eax
  8012c2:	89 47 10             	mov    %eax,0x10(%edi)
  8012c5:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  8012ca:	b8 00 00 00 00       	mov    $0x0,%eax
  8012cf:	e9 05 01 00 00       	jmp    8013d9 <lwip_recvfrom+0x19d>
        sock_set_errno(sock, EWOULDBLOCK);
  8012d4:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  8012db:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  8012e2:	00 00 00 
        return -1;
  8012e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012ea:	e9 ea 00 00 00       	jmp    8013d9 <lwip_recvfrom+0x19d>
        sock->lastdata = NULL;
  8012ef:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  8012f6:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  8012fc:	83 ec 0c             	sub    $0xc,%esp
  8012ff:	56                   	push   %esi
  801300:	e8 3d 11 00 00       	call   802442 <netbuf_delete>
  801305:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  801308:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80130c:	0f 85 a6 00 00 00    	jne    8013b8 <lwip_recvfrom+0x17c>
    if (sock->lastdata) {
  801312:	8b 77 04             	mov    0x4(%edi),%esi
  801315:	85 f6                	test   %esi,%esi
  801317:	0f 84 4e ff ff ff    	je     80126b <lwip_recvfrom+0x2f>
    buflen = netbuf_len(buf);
  80131d:	8b 16                	mov    (%esi),%edx
  80131f:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  801323:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  801327:	89 cb                	mov    %ecx,%ebx
  801329:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  80132b:	0f b7 db             	movzwl %bx,%ebx
  80132e:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  801331:	29 c1                	sub    %eax,%ecx
  801333:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  801336:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  80133b:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80133d:	0f b7 c9             	movzwl %cx,%ecx
  801340:	0f b7 c0             	movzwl %ax,%eax
  801343:	50                   	push   %eax
  801344:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801347:	51                   	push   %ecx
  801348:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80134c:	03 45 0c             	add    0xc(%ebp),%eax
  80134f:	50                   	push   %eax
  801350:	52                   	push   %edx
  801351:	e8 09 3c 00 00       	call   804f5f <pbuf_copy_partial>
    off += copylen;
  801356:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80135a:	83 c4 04             	add    $0x4,%esp
  80135d:	ff 37                	pushl  (%edi)
  80135f:	e8 48 99 00 00       	call   80acac <netconn_type>
  801364:	83 c4 10             	add    $0x10,%esp
      done = 1;
  801367:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80136b:	83 f8 10             	cmp    $0x10,%eax
  80136e:	75 1d                	jne    80138d <lwip_recvfrom+0x151>
      len -= copylen;
  801370:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  801373:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801376:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80137a:	7e 11                	jle    80138d <lwip_recvfrom+0x151>
  80137c:	8b 06                	mov    (%esi),%eax
  80137e:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  801382:	75 09                	jne    80138d <lwip_recvfrom+0x151>
  801384:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801389:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  80138d:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  801391:	75 25                	jne    8013b8 <lwip_recvfrom+0x17c>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  801393:	8b 07                	mov    (%edi),%eax
  801395:	83 38 10             	cmpl   $0x10,(%eax)
  801398:	0f 85 51 ff ff ff    	jne    8012ef <lwip_recvfrom+0xb3>
  80139e:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8013a1:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8013a4:	85 c0                	test   %eax,%eax
  8013a6:	0f 8e 43 ff ff ff    	jle    8012ef <lwip_recvfrom+0xb3>
        sock->lastdata = buf;
  8013ac:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8013af:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8013b3:	e9 50 ff ff ff       	jmp    801308 <lwip_recvfrom+0xcc>
  if (from && fromlen) {
  8013b8:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8013bc:	74 06                	je     8013c4 <lwip_recvfrom+0x188>
  8013be:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8013c2:	75 1d                	jne    8013e1 <lwip_recvfrom+0x1a5>
  sock_set_errno(sock, 0);
  8013c4:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8013cb:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8013d2:	00 00 00 
  return off;
  8013d5:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  8013d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8013dc:	5b                   	pop    %ebx
  8013dd:	5e                   	pop    %esi
  8013de:	5f                   	pop    %edi
  8013df:	5d                   	pop    %ebp
  8013e0:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8013e1:	83 ec 0c             	sub    $0xc,%esp
  8013e4:	ff 37                	pushl  (%edi)
  8013e6:	e8 c1 98 00 00       	call   80acac <netconn_type>
  8013eb:	83 c4 10             	add    $0x10,%esp
  8013ee:	83 f8 10             	cmp    $0x10,%eax
  8013f1:	74 65                	je     801458 <lwip_recvfrom+0x21c>
      addr = netbuf_fromaddr(buf);
  8013f3:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  8013f6:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8013fa:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  8013fe:	83 ec 04             	sub    $0x4,%esp
  801401:	6a 10                	push   $0x10
  801403:	6a 00                	push   $0x0
  801405:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801408:	50                   	push   %eax
  801409:	e8 5f d9 00 00       	call   80ed6d <memset>
    sin.sin_len = sizeof(sin);
  80140e:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801412:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  801416:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80141a:	89 04 24             	mov    %eax,(%esp)
  80141d:	e8 a3 62 00 00       	call   8076c5 <htons>
  801422:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  801426:	8b 03                	mov    (%ebx),%eax
  801428:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  80142b:	83 c4 10             	add    $0x10,%esp
  80142e:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801431:	83 38 10             	cmpl   $0x10,(%eax)
  801434:	76 06                	jbe    80143c <lwip_recvfrom+0x200>
      *fromlen = sizeof(sin);
  801436:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  80143c:	83 ec 04             	sub    $0x4,%esp
  80143f:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801442:	ff 30                	pushl  (%eax)
  801444:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801447:	50                   	push   %eax
  801448:	ff 75 18             	pushl  0x18(%ebp)
  80144b:	e8 c7 d9 00 00       	call   80ee17 <memcpy>
  801450:	83 c4 10             	add    $0x10,%esp
  801453:	e9 6c ff ff ff       	jmp    8013c4 <lwip_recvfrom+0x188>
      netconn_getaddr(sock->conn, addr, &port, 0);
  801458:	6a 00                	push   $0x0
  80145a:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  80145d:	50                   	push   %eax
  80145e:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801461:	50                   	push   %eax
  801462:	ff 37                	pushl  (%edi)
  801464:	e8 6b 98 00 00       	call   80acd4 <netconn_getaddr>
  801469:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80146c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  80146f:	eb 8d                	jmp    8013fe <lwip_recvfrom+0x1c2>
    return -1;
  801471:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801476:	e9 5e ff ff ff       	jmp    8013d9 <lwip_recvfrom+0x19d>

0080147b <lwip_read>:
{
  80147b:	55                   	push   %ebp
  80147c:	89 e5                	mov    %esp,%ebp
  80147e:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801481:	6a 00                	push   $0x0
  801483:	6a 00                	push   $0x0
  801485:	6a 00                	push   $0x0
  801487:	ff 75 10             	pushl  0x10(%ebp)
  80148a:	ff 75 0c             	pushl  0xc(%ebp)
  80148d:	ff 75 08             	pushl  0x8(%ebp)
  801490:	e8 a7 fd ff ff       	call   80123c <lwip_recvfrom>
}
  801495:	c9                   	leave  
  801496:	c3                   	ret    

00801497 <lwip_recv>:
{
  801497:	55                   	push   %ebp
  801498:	89 e5                	mov    %esp,%ebp
  80149a:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  80149d:	6a 00                	push   $0x0
  80149f:	6a 00                	push   $0x0
  8014a1:	ff 75 14             	pushl  0x14(%ebp)
  8014a4:	ff 75 10             	pushl  0x10(%ebp)
  8014a7:	ff 75 0c             	pushl  0xc(%ebp)
  8014aa:	ff 75 08             	pushl  0x8(%ebp)
  8014ad:	e8 8a fd ff ff       	call   80123c <lwip_recvfrom>
}
  8014b2:	c9                   	leave  
  8014b3:	c3                   	ret    

008014b4 <lwip_sendto>:
{
  8014b4:	55                   	push   %ebp
  8014b5:	89 e5                	mov    %esp,%ebp
  8014b7:	57                   	push   %edi
  8014b8:	56                   	push   %esi
  8014b9:	53                   	push   %ebx
  8014ba:	83 ec 2c             	sub    $0x2c,%esp
  8014bd:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8014c0:	8b 7d 18             	mov    0x18(%ebp),%edi
  sock = get_socket(s);
  8014c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8014c6:	e8 3a f2 ff ff       	call   800705 <get_socket>
  if (!sock)
  8014cb:	85 c0                	test   %eax,%eax
  8014cd:	0f 84 28 01 00 00    	je     8015fb <lwip_sendto+0x147>
  8014d3:	89 c6                	mov    %eax,%esi
  if (sock->conn->type==NETCONN_TCP) {
  8014d5:	8b 00                	mov    (%eax),%eax
  8014d7:	83 38 10             	cmpl   $0x10,(%eax)
  8014da:	0f 84 be 00 00 00    	je     80159e <lwip_sendto+0xea>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8014e0:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8014e6:	0f 87 c8 00 00 00    	ja     8015b4 <lwip_sendto+0x100>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8014ec:	89 f8                	mov    %edi,%eax
  8014ee:	0b 45 1c             	or     0x1c(%ebp),%eax
  8014f1:	0f 84 0b 01 00 00    	je     801602 <lwip_sendto+0x14e>
  8014f7:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8014fb:	0f 85 ca 00 00 00    	jne    8015cb <lwip_sendto+0x117>
  801501:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  801505:	0f 85 c0 00 00 00    	jne    8015cb <lwip_sendto+0x117>
  buf.p = buf.ptr = NULL;
  80150b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801512:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801519:	8b 47 04             	mov    0x4(%edi),%eax
  80151c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80151f:	83 ec 0c             	sub    $0xc,%esp
  801522:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  801526:	50                   	push   %eax
  801527:	e8 a6 61 00 00       	call   8076d2 <ntohs>
    buf.addr         = &remote_addr;
  80152c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80152f:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801532:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801536:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801539:	83 ec 04             	sub    $0x4,%esp
  80153c:	0f b7 c3             	movzwl %bx,%eax
  80153f:	50                   	push   %eax
  801540:	ff 75 0c             	pushl  0xc(%ebp)
  801543:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801546:	50                   	push   %eax
  801547:	e8 f8 0f 00 00       	call   802544 <netbuf_ref>
  80154c:	0f be f8             	movsbl %al,%edi
  80154f:	83 c4 10             	add    $0x10,%esp
  801552:	85 ff                	test   %edi,%edi
  801554:	0f 84 88 00 00 00    	je     8015e2 <lwip_sendto+0x12e>
  if (buf.p != NULL) {
  80155a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80155d:	85 c0                	test   %eax,%eax
  80155f:	74 0c                	je     80156d <lwip_sendto+0xb9>
    pbuf_free(buf.p);
  801561:	83 ec 0c             	sub    $0xc,%esp
  801564:	50                   	push   %eax
  801565:	e8 79 32 00 00       	call   8047e3 <pbuf_free>
  80156a:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  80156d:	89 fa                	mov    %edi,%edx
  80156f:	f7 da                	neg    %edx
  801571:	b8 05 00 00 00       	mov    $0x5,%eax
  801576:	83 fa 0e             	cmp    $0xe,%edx
  801579:	77 07                	ja     801582 <lwip_sendto+0xce>
  80157b:	8b 04 95 80 11 81 00 	mov    0x811180(,%edx,4),%eax
  801582:	89 46 10             	mov    %eax,0x10(%esi)
  801585:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  80158a:	85 ff                	test   %edi,%edi
  80158c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801591:	0f 45 d8             	cmovne %eax,%ebx
}
  801594:	89 d8                	mov    %ebx,%eax
  801596:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801599:	5b                   	pop    %ebx
  80159a:	5e                   	pop    %esi
  80159b:	5f                   	pop    %edi
  80159c:	5d                   	pop    %ebp
  80159d:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  80159e:	ff 75 14             	pushl  0x14(%ebp)
  8015a1:	53                   	push   %ebx
  8015a2:	ff 75 0c             	pushl  0xc(%ebp)
  8015a5:	ff 75 08             	pushl  0x8(%ebp)
  8015a8:	e8 7c 00 00 00       	call   801629 <lwip_send>
  8015ad:	89 c3                	mov    %eax,%ebx
  8015af:	83 c4 10             	add    $0x10,%esp
  8015b2:	eb e0                	jmp    801594 <lwip_sendto+0xe0>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8015b4:	83 ec 04             	sub    $0x4,%esp
  8015b7:	68 40 11 81 00       	push   $0x811140
  8015bc:	68 97 02 00 00       	push   $0x297
  8015c1:	68 b0 10 81 00       	push   $0x8110b0
  8015c6:	e8 a5 cf 00 00       	call   80e570 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8015cb:	83 ec 04             	sub    $0x4,%esp
  8015ce:	68 21 11 81 00       	push   $0x811121
  8015d3:	68 9b 02 00 00       	push   $0x29b
  8015d8:	68 b0 10 81 00       	push   $0x8110b0
  8015dd:	e8 8e cf 00 00       	call   80e570 <_panic>
    err = netconn_send(sock->conn, &buf);
  8015e2:	83 ec 08             	sub    $0x8,%esp
  8015e5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8015e8:	50                   	push   %eax
  8015e9:	ff 36                	pushl  (%esi)
  8015eb:	e8 a1 9a 00 00       	call   80b091 <netconn_send>
  8015f0:	0f be f8             	movsbl %al,%edi
  8015f3:	83 c4 10             	add    $0x10,%esp
  8015f6:	e9 5f ff ff ff       	jmp    80155a <lwip_sendto+0xa6>
    return -1;
  8015fb:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801600:	eb 92                	jmp    801594 <lwip_sendto+0xe0>
  buf.p = buf.ptr = NULL;
  801602:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801609:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  801610:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  801617:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  80161e:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  801624:	e9 10 ff ff ff       	jmp    801539 <lwip_sendto+0x85>

00801629 <lwip_send>:
{
  801629:	55                   	push   %ebp
  80162a:	89 e5                	mov    %esp,%ebp
  80162c:	57                   	push   %edi
  80162d:	56                   	push   %esi
  80162e:	53                   	push   %ebx
  80162f:	83 ec 0c             	sub    $0xc,%esp
  801632:	8b 7d 08             	mov    0x8(%ebp),%edi
  801635:	8b 5d 10             	mov    0x10(%ebp),%ebx
  sock = get_socket(s);
  801638:	89 f8                	mov    %edi,%eax
  80163a:	e8 c6 f0 ff ff       	call   800705 <get_socket>
  if (!sock)
  80163f:	85 c0                	test   %eax,%eax
  801641:	74 70                	je     8016b3 <lwip_send+0x8a>
  801643:	89 c6                	mov    %eax,%esi
  if (sock->conn->type!=NETCONN_TCP) {
  801645:	8b 00                	mov    (%eax),%eax
  801647:	83 38 10             	cmpl   $0x10,(%eax)
  80164a:	74 1f                	je     80166b <lwip_send+0x42>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  80164c:	83 ec 08             	sub    $0x8,%esp
  80164f:	6a 00                	push   $0x0
  801651:	6a 00                	push   $0x0
  801653:	ff 75 14             	pushl  0x14(%ebp)
  801656:	53                   	push   %ebx
  801657:	ff 75 0c             	pushl  0xc(%ebp)
  80165a:	57                   	push   %edi
  80165b:	e8 54 fe ff ff       	call   8014b4 <lwip_sendto>
  801660:	83 c4 20             	add    $0x20,%esp
}
  801663:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801666:	5b                   	pop    %ebx
  801667:	5e                   	pop    %esi
  801668:	5f                   	pop    %edi
  801669:	5d                   	pop    %ebp
  80166a:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  80166b:	8b 55 14             	mov    0x14(%ebp),%edx
  80166e:	c1 ea 03             	shr    $0x3,%edx
  801671:	83 e2 02             	and    $0x2,%edx
  801674:	83 ca 01             	or     $0x1,%edx
  801677:	0f b6 d2             	movzbl %dl,%edx
  80167a:	52                   	push   %edx
  80167b:	53                   	push   %ebx
  80167c:	ff 75 0c             	pushl  0xc(%ebp)
  80167f:	50                   	push   %eax
  801680:	e8 88 9a 00 00       	call   80b10d <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  801685:	0f be d0             	movsbl %al,%edx
  801688:	f7 da                	neg    %edx
  80168a:	83 c4 10             	add    $0x10,%esp
  80168d:	b9 05 00 00 00       	mov    $0x5,%ecx
  801692:	83 fa 0e             	cmp    $0xe,%edx
  801695:	77 07                	ja     80169e <lwip_send+0x75>
  801697:	8b 0c 95 80 11 81 00 	mov    0x811180(,%edx,4),%ecx
  80169e:	89 4e 10             	mov    %ecx,0x10(%esi)
  8016a1:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8016a7:	84 c0                	test   %al,%al
  8016a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016ae:	0f 44 c3             	cmove  %ebx,%eax
  8016b1:	eb b0                	jmp    801663 <lwip_send+0x3a>
    return -1;
  8016b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016b8:	eb a9                	jmp    801663 <lwip_send+0x3a>

008016ba <lwip_socket>:
{
  8016ba:	55                   	push   %ebp
  8016bb:	89 e5                	mov    %esp,%ebp
  8016bd:	56                   	push   %esi
  8016be:	53                   	push   %ebx
  8016bf:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  8016c2:	83 f8 02             	cmp    $0x2,%eax
  8016c5:	74 5c                	je     801723 <lwip_socket+0x69>
  8016c7:	83 f8 03             	cmp    $0x3,%eax
  8016ca:	74 16                	je     8016e2 <lwip_socket+0x28>
  8016cc:	83 f8 01             	cmp    $0x1,%eax
  8016cf:	74 79                	je     80174a <lwip_socket+0x90>
    set_errno(EINVAL);
  8016d1:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  8016d8:	00 00 00 
    return -1;
  8016db:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  8016e0:	eb 38                	jmp    80171a <lwip_socket+0x60>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8016e2:	83 ec 04             	sub    $0x4,%esp
  8016e5:	68 f5 08 80 00       	push   $0x8008f5
  8016ea:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  8016ee:	50                   	push   %eax
  8016ef:	6a 40                	push   $0x40
  8016f1:	e8 99 94 00 00       	call   80ab8f <netconn_new_with_proto_and_callback>
  8016f6:	89 c6                	mov    %eax,%esi
    break;
  8016f8:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  8016fb:	85 f6                	test   %esi,%esi
  8016fd:	74 63                	je     801762 <lwip_socket+0xa8>
  i = alloc_socket(conn);
  8016ff:	89 f0                	mov    %esi,%eax
  801701:	e8 99 f3 ff ff       	call   800a9f <alloc_socket>
  801706:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  801708:	83 f8 ff             	cmp    $0xffffffff,%eax
  80170b:	74 66                	je     801773 <lwip_socket+0xb9>
  conn->socket = i;
  80170d:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  801710:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801717:	00 00 00 
}
  80171a:	89 d8                	mov    %ebx,%eax
  80171c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80171f:	5b                   	pop    %ebx
  801720:	5e                   	pop    %esi
  801721:	5d                   	pop    %ebp
  801722:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801723:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  80172a:	0f 94 c0             	sete   %al
  80172d:	0f b6 c0             	movzbl %al,%eax
  801730:	83 c0 20             	add    $0x20,%eax
  801733:	83 ec 04             	sub    $0x4,%esp
  801736:	68 f5 08 80 00       	push   $0x8008f5
  80173b:	6a 00                	push   $0x0
  80173d:	50                   	push   %eax
  80173e:	e8 4c 94 00 00       	call   80ab8f <netconn_new_with_proto_and_callback>
  801743:	89 c6                	mov    %eax,%esi
    break;
  801745:	83 c4 10             	add    $0x10,%esp
  801748:	eb b1                	jmp    8016fb <lwip_socket+0x41>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  80174a:	83 ec 04             	sub    $0x4,%esp
  80174d:	68 f5 08 80 00       	push   $0x8008f5
  801752:	6a 00                	push   $0x0
  801754:	6a 10                	push   $0x10
  801756:	e8 34 94 00 00       	call   80ab8f <netconn_new_with_proto_and_callback>
  80175b:	89 c6                	mov    %eax,%esi
    break;
  80175d:	83 c4 10             	add    $0x10,%esp
  801760:	eb 99                	jmp    8016fb <lwip_socket+0x41>
    set_errno(ENOBUFS);
  801762:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  801769:	00 00 00 
    return -1;
  80176c:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801771:	eb a7                	jmp    80171a <lwip_socket+0x60>
    netconn_delete(conn);
  801773:	83 ec 0c             	sub    $0xc,%esp
  801776:	56                   	push   %esi
  801777:	e8 f0 94 00 00       	call   80ac6c <netconn_delete>
    set_errno(ENFILE);
  80177c:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801783:	00 00 00 
    return -1;
  801786:	83 c4 10             	add    $0x10,%esp
  801789:	eb 8f                	jmp    80171a <lwip_socket+0x60>

0080178b <lwip_write>:
{
  80178b:	55                   	push   %ebp
  80178c:	89 e5                	mov    %esp,%ebp
  80178e:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  801791:	6a 00                	push   $0x0
  801793:	ff 75 10             	pushl  0x10(%ebp)
  801796:	ff 75 0c             	pushl  0xc(%ebp)
  801799:	ff 75 08             	pushl  0x8(%ebp)
  80179c:	e8 88 fe ff ff       	call   801629 <lwip_send>
}
  8017a1:	c9                   	leave  
  8017a2:	c3                   	ret    

008017a3 <lwip_select>:
{
  8017a3:	55                   	push   %ebp
  8017a4:	89 e5                	mov    %esp,%ebp
  8017a6:	57                   	push   %edi
  8017a7:	56                   	push   %esi
  8017a8:	53                   	push   %ebx
  8017a9:	83 ec 58             	sub    $0x58,%esp
  8017ac:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8017af:	8b 75 10             	mov    0x10(%ebp),%esi
  8017b2:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  8017b5:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  8017bc:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  8017bf:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  8017c2:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  8017c5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  8017cc:	ff 35 40 50 81 00    	pushl  0x815040
  8017d2:	e8 ea 38 00 00       	call   8050c1 <sys_sem_wait>
  if (readset)
  8017d7:	83 c4 10             	add    $0x10,%esp
  8017da:	85 db                	test   %ebx,%ebx
  8017dc:	0f 84 07 01 00 00    	je     8018e9 <lwip_select+0x146>
    lreadset = *readset;
  8017e2:	8b 03                	mov    (%ebx),%eax
  8017e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  8017e7:	85 f6                	test   %esi,%esi
  8017e9:	0f 84 12 01 00 00    	je     801901 <lwip_select+0x15e>
    lwriteset = *writeset;
  8017ef:	8b 06                	mov    (%esi),%eax
  8017f1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  8017f4:	85 ff                	test   %edi,%edi
  8017f6:	0f 84 1d 01 00 00    	je     801919 <lwip_select+0x176>
    lexceptset = *exceptset;
  8017fc:	8b 07                	mov    (%edi),%eax
  8017fe:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801801:	83 ec 0c             	sub    $0xc,%esp
  801804:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801807:	50                   	push   %eax
  801808:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  80180b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80180e:	8b 45 08             	mov    0x8(%ebp),%eax
  801811:	e8 2f ef ff ff       	call   800745 <lwip_selscan>
  801816:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  801819:	83 c4 10             	add    $0x10,%esp
  80181c:	85 c0                	test   %eax,%eax
  80181e:	0f 85 9c 02 00 00    	jne    801ac0 <lwip_select+0x31d>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801824:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801828:	0f 84 a8 02 00 00    	je     801ad6 <lwip_select+0x333>
  80182e:	8b 45 18             	mov    0x18(%ebp),%eax
  801831:	83 38 00             	cmpl   $0x0,(%eax)
  801834:	75 0a                	jne    801840 <lwip_select+0x9d>
  801836:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80183a:	0f 84 f1 00 00 00    	je     801931 <lwip_select+0x18e>
    select_cb.sem = sys_sem_new(0);
  801840:	83 ec 0c             	sub    $0xc,%esp
  801843:	6a 00                	push   $0x0
  801845:	e8 57 85 00 00       	call   809da1 <sys_sem_new>
  80184a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  80184d:	a1 48 50 81 00       	mov    0x815048,%eax
  801852:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801855:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801858:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  80185d:	83 c4 04             	add    $0x4,%esp
  801860:	ff 35 40 50 81 00    	pushl  0x815040
  801866:	e8 f3 87 00 00       	call   80a05e <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  80186b:	8b 45 18             	mov    0x18(%ebp),%eax
  80186e:	8b 40 04             	mov    0x4(%eax),%eax
  801871:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801874:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  80187a:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80187f:	89 c8                	mov    %ecx,%eax
  801881:	f7 ea                	imul   %edx
  801883:	c1 fa 06             	sar    $0x6,%edx
  801886:	c1 f9 1f             	sar    $0x1f,%ecx
  801889:	29 ca                	sub    %ecx,%edx
  80188b:	8b 45 18             	mov    0x18(%ebp),%eax
  80188e:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  801894:	83 c4 10             	add    $0x10,%esp
  801897:	01 d0                	add    %edx,%eax
        msectimeout = 1;
  801899:	ba 01 00 00 00       	mov    $0x1,%edx
  80189e:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  8018a1:	83 ec 08             	sub    $0x8,%esp
  8018a4:	50                   	push   %eax
  8018a5:	ff 75 d8             	pushl  -0x28(%ebp)
  8018a8:	e8 e4 39 00 00       	call   805291 <sys_sem_wait_timeout>
  8018ad:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  8018b0:	83 c4 04             	add    $0x4,%esp
  8018b3:	ff 35 40 50 81 00    	pushl  0x815040
  8018b9:	e8 03 38 00 00       	call   8050c1 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  8018be:	a1 48 50 81 00       	mov    0x815048,%eax
  8018c3:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8018c6:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  8018c9:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  8018cb:	39 d0                	cmp    %edx,%eax
  8018cd:	0f 84 ba 00 00 00    	je     80198d <lwip_select+0x1ea>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8018d3:	85 c0                	test   %eax,%eax
  8018d5:	0f 84 c1 00 00 00    	je     80199c <lwip_select+0x1f9>
        if (p_selcb->next == &select_cb) {
  8018db:	8b 10                	mov    (%eax),%edx
  8018dd:	39 ca                	cmp    %ecx,%edx
  8018df:	0f 84 b2 00 00 00    	je     801997 <lwip_select+0x1f4>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8018e5:	89 d0                	mov    %edx,%eax
  8018e7:	eb ea                	jmp    8018d3 <lwip_select+0x130>
    FD_ZERO(&lreadset);
  8018e9:	83 ec 04             	sub    $0x4,%esp
  8018ec:	6a 04                	push   $0x4
  8018ee:	6a 00                	push   $0x0
  8018f0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8018f3:	50                   	push   %eax
  8018f4:	e8 74 d4 00 00       	call   80ed6d <memset>
  8018f9:	83 c4 10             	add    $0x10,%esp
  8018fc:	e9 e6 fe ff ff       	jmp    8017e7 <lwip_select+0x44>
    FD_ZERO(&lwriteset);
  801901:	83 ec 04             	sub    $0x4,%esp
  801904:	6a 04                	push   $0x4
  801906:	6a 00                	push   $0x0
  801908:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80190b:	50                   	push   %eax
  80190c:	e8 5c d4 00 00       	call   80ed6d <memset>
  801911:	83 c4 10             	add    $0x10,%esp
  801914:	e9 db fe ff ff       	jmp    8017f4 <lwip_select+0x51>
    FD_ZERO(&lexceptset);
  801919:	83 ec 04             	sub    $0x4,%esp
  80191c:	6a 04                	push   $0x4
  80191e:	6a 00                	push   $0x0
  801920:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801923:	50                   	push   %eax
  801924:	e8 44 d4 00 00       	call   80ed6d <memset>
  801929:	83 c4 10             	add    $0x10,%esp
  80192c:	e9 d0 fe ff ff       	jmp    801801 <lwip_select+0x5e>
      sys_sem_signal(selectsem);
  801931:	83 ec 0c             	sub    $0xc,%esp
  801934:	ff 35 40 50 81 00    	pushl  0x815040
  80193a:	e8 1f 87 00 00       	call   80a05e <sys_sem_signal>
      if (readset)
  80193f:	83 c4 10             	add    $0x10,%esp
  801942:	85 db                	test   %ebx,%ebx
  801944:	74 10                	je     801956 <lwip_select+0x1b3>
        FD_ZERO(readset);
  801946:	83 ec 04             	sub    $0x4,%esp
  801949:	6a 04                	push   $0x4
  80194b:	6a 00                	push   $0x0
  80194d:	53                   	push   %ebx
  80194e:	e8 1a d4 00 00       	call   80ed6d <memset>
  801953:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801956:	85 f6                	test   %esi,%esi
  801958:	74 10                	je     80196a <lwip_select+0x1c7>
        FD_ZERO(writeset);
  80195a:	83 ec 04             	sub    $0x4,%esp
  80195d:	6a 04                	push   $0x4
  80195f:	6a 00                	push   $0x0
  801961:	56                   	push   %esi
  801962:	e8 06 d4 00 00       	call   80ed6d <memset>
  801967:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  80196a:	85 ff                	test   %edi,%edi
  80196c:	74 10                	je     80197e <lwip_select+0x1db>
        FD_ZERO(exceptset);
  80196e:	83 ec 04             	sub    $0x4,%esp
  801971:	6a 04                	push   $0x4
  801973:	6a 00                	push   $0x0
  801975:	57                   	push   %edi
  801976:	e8 f2 d3 00 00       	call   80ed6d <memset>
  80197b:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  80197e:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801985:	00 00 00 
      return 0;
  801988:	e9 98 00 00 00       	jmp    801a25 <lwip_select+0x282>
      select_cb_list = select_cb.next;
  80198d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801990:	a3 48 50 81 00       	mov    %eax,0x815048
  801995:	eb 05                	jmp    80199c <lwip_select+0x1f9>
          p_selcb->next = select_cb.next;
  801997:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  80199a:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  80199c:	83 ec 0c             	sub    $0xc,%esp
  80199f:	ff 35 40 50 81 00    	pushl  0x815040
  8019a5:	e8 b4 86 00 00       	call   80a05e <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  8019aa:	83 c4 04             	add    $0x4,%esp
  8019ad:	ff 75 d8             	pushl  -0x28(%ebp)
  8019b0:	e8 6d 84 00 00       	call   809e22 <sys_sem_free>
    if (i == 0)  {
  8019b5:	83 c4 10             	add    $0x10,%esp
  8019b8:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8019bc:	74 72                	je     801a30 <lwip_select+0x28d>
    if (readset)
  8019be:	85 db                	test   %ebx,%ebx
  8019c0:	0f 84 b2 00 00 00    	je     801a78 <lwip_select+0x2d5>
      lreadset = *readset;
  8019c6:	8b 03                	mov    (%ebx),%eax
  8019c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  8019cb:	85 f6                	test   %esi,%esi
  8019cd:	0f 84 bd 00 00 00    	je     801a90 <lwip_select+0x2ed>
      lwriteset = *writeset;
  8019d3:	8b 06                	mov    (%esi),%eax
  8019d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  8019d8:	85 ff                	test   %edi,%edi
  8019da:	0f 84 c8 00 00 00    	je     801aa8 <lwip_select+0x305>
      lexceptset = *exceptset;
  8019e0:	8b 07                	mov    (%edi),%eax
  8019e2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8019e5:	83 ec 0c             	sub    $0xc,%esp
  8019e8:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8019eb:	50                   	push   %eax
  8019ec:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8019ef:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8019f2:	8b 45 08             	mov    0x8(%ebp),%eax
  8019f5:	e8 4b ed ff ff       	call   800745 <lwip_selscan>
  8019fa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8019fd:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801a00:	85 db                	test   %ebx,%ebx
  801a02:	74 05                	je     801a09 <lwip_select+0x266>
    *readset = lreadset;
  801a04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a07:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801a09:	85 f6                	test   %esi,%esi
  801a0b:	74 05                	je     801a12 <lwip_select+0x26f>
    *writeset = lwriteset;
  801a0d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801a10:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801a12:	85 ff                	test   %edi,%edi
  801a14:	74 05                	je     801a1b <lwip_select+0x278>
    *exceptset = lexceptset;
  801a16:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801a19:	89 07                	mov    %eax,(%edi)
  set_errno(0);
  801a1b:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a22:	00 00 00 
}
  801a25:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801a28:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801a2b:	5b                   	pop    %ebx
  801a2c:	5e                   	pop    %esi
  801a2d:	5f                   	pop    %edi
  801a2e:	5d                   	pop    %ebp
  801a2f:	c3                   	ret    
      if (readset)
  801a30:	85 db                	test   %ebx,%ebx
  801a32:	74 10                	je     801a44 <lwip_select+0x2a1>
        FD_ZERO(readset);
  801a34:	83 ec 04             	sub    $0x4,%esp
  801a37:	6a 04                	push   $0x4
  801a39:	6a 00                	push   $0x0
  801a3b:	53                   	push   %ebx
  801a3c:	e8 2c d3 00 00       	call   80ed6d <memset>
  801a41:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801a44:	85 f6                	test   %esi,%esi
  801a46:	74 10                	je     801a58 <lwip_select+0x2b5>
        FD_ZERO(writeset);
  801a48:	83 ec 04             	sub    $0x4,%esp
  801a4b:	6a 04                	push   $0x4
  801a4d:	6a 00                	push   $0x0
  801a4f:	56                   	push   %esi
  801a50:	e8 18 d3 00 00       	call   80ed6d <memset>
  801a55:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801a58:	85 ff                	test   %edi,%edi
  801a5a:	74 10                	je     801a6c <lwip_select+0x2c9>
        FD_ZERO(exceptset);
  801a5c:	83 ec 04             	sub    $0x4,%esp
  801a5f:	6a 04                	push   $0x4
  801a61:	6a 00                	push   $0x0
  801a63:	57                   	push   %edi
  801a64:	e8 04 d3 00 00       	call   80ed6d <memset>
  801a69:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801a6c:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a73:	00 00 00 
      return 0;
  801a76:	eb ad                	jmp    801a25 <lwip_select+0x282>
      FD_ZERO(&lreadset);
  801a78:	83 ec 04             	sub    $0x4,%esp
  801a7b:	6a 04                	push   $0x4
  801a7d:	6a 00                	push   $0x0
  801a7f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a82:	50                   	push   %eax
  801a83:	e8 e5 d2 00 00       	call   80ed6d <memset>
  801a88:	83 c4 10             	add    $0x10,%esp
  801a8b:	e9 3b ff ff ff       	jmp    8019cb <lwip_select+0x228>
      FD_ZERO(&lwriteset);
  801a90:	83 ec 04             	sub    $0x4,%esp
  801a93:	6a 04                	push   $0x4
  801a95:	6a 00                	push   $0x0
  801a97:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801a9a:	50                   	push   %eax
  801a9b:	e8 cd d2 00 00       	call   80ed6d <memset>
  801aa0:	83 c4 10             	add    $0x10,%esp
  801aa3:	e9 30 ff ff ff       	jmp    8019d8 <lwip_select+0x235>
      FD_ZERO(&lexceptset);
  801aa8:	83 ec 04             	sub    $0x4,%esp
  801aab:	6a 04                	push   $0x4
  801aad:	6a 00                	push   $0x0
  801aaf:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801ab2:	50                   	push   %eax
  801ab3:	e8 b5 d2 00 00       	call   80ed6d <memset>
  801ab8:	83 c4 10             	add    $0x10,%esp
  801abb:	e9 25 ff ff ff       	jmp    8019e5 <lwip_select+0x242>
    sys_sem_signal(selectsem);
  801ac0:	83 ec 0c             	sub    $0xc,%esp
  801ac3:	ff 35 40 50 81 00    	pushl  0x815040
  801ac9:	e8 90 85 00 00       	call   80a05e <sys_sem_signal>
  801ace:	83 c4 10             	add    $0x10,%esp
  801ad1:	e9 2a ff ff ff       	jmp    801a00 <lwip_select+0x25d>
    select_cb.sem = sys_sem_new(0);
  801ad6:	83 ec 0c             	sub    $0xc,%esp
  801ad9:	6a 00                	push   $0x0
  801adb:	e8 c1 82 00 00       	call   809da1 <sys_sem_new>
  801ae0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801ae3:	a1 48 50 81 00       	mov    0x815048,%eax
  801ae8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801aeb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801aee:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801af3:	83 c4 04             	add    $0x4,%esp
  801af6:	ff 35 40 50 81 00    	pushl  0x815040
  801afc:	e8 5d 85 00 00       	call   80a05e <sys_sem_signal>
  801b01:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801b04:	b8 00 00 00 00       	mov    $0x0,%eax
  801b09:	e9 93 fd ff ff       	jmp    8018a1 <lwip_select+0xfe>

00801b0e <lwip_shutdown>:
{
  801b0e:	55                   	push   %ebp
  801b0f:	89 e5                	mov    %esp,%ebp
  801b11:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801b14:	ff 75 08             	pushl  0x8(%ebp)
  801b17:	e8 57 f5 ff ff       	call   801073 <lwip_close>
}
  801b1c:	c9                   	leave  
  801b1d:	c3                   	ret    

00801b1e <lwip_getpeername>:
{
  801b1e:	55                   	push   %ebp
  801b1f:	89 e5                	mov    %esp,%ebp
  801b21:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801b24:	6a 00                	push   $0x0
  801b26:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b29:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b2c:	8b 45 08             	mov    0x8(%ebp),%eax
  801b2f:	e8 16 ed ff ff       	call   80084a <lwip_getaddrname>
}
  801b34:	c9                   	leave  
  801b35:	c3                   	ret    

00801b36 <lwip_getsockname>:
{
  801b36:	55                   	push   %ebp
  801b37:	89 e5                	mov    %esp,%ebp
  801b39:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801b3c:	6a 01                	push   $0x1
  801b3e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b41:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b44:	8b 45 08             	mov    0x8(%ebp),%eax
  801b47:	e8 fe ec ff ff       	call   80084a <lwip_getaddrname>
}
  801b4c:	c9                   	leave  
  801b4d:	c3                   	ret    

00801b4e <lwip_getsockopt>:
{
  801b4e:	55                   	push   %ebp
  801b4f:	89 e5                	mov    %esp,%ebp
  801b51:	57                   	push   %edi
  801b52:	56                   	push   %esi
  801b53:	53                   	push   %ebx
  801b54:	83 ec 2c             	sub    $0x2c,%esp
  801b57:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801b5a:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801b5d:	8b 45 08             	mov    0x8(%ebp),%eax
  801b60:	e8 a0 eb ff ff       	call   800705 <get_socket>
  if (!sock)
  801b65:	85 c0                	test   %eax,%eax
  801b67:	0f 84 af 01 00 00    	je     801d1c <lwip_getsockopt+0x1ce>
  801b6d:	89 c6                	mov    %eax,%esi
  if ((NULL == optval) || (NULL == optlen)) {
  801b6f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801b73:	74 39                	je     801bae <lwip_getsockopt+0x60>
  801b75:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801b79:	74 33                	je     801bae <lwip_getsockopt+0x60>
  switch (level) {
  801b7b:	83 fb 06             	cmp    $0x6,%ebx
  801b7e:	0f 84 36 01 00 00    	je     801cba <lwip_getsockopt+0x16c>
  801b84:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801b8a:	74 3d                	je     801bc9 <lwip_getsockopt+0x7b>
      err = ENOPROTOOPT;
  801b8c:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801b91:	85 db                	test   %ebx,%ebx
  801b93:	0f 84 a9 00 00 00    	je     801c42 <lwip_getsockopt+0xf4>
    sock_set_errno(sock, err);
  801b99:	0f be c0             	movsbl %al,%eax
  801b9c:	89 46 10             	mov    %eax,0x10(%esi)
  801b9f:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801ba4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ba9:	e9 04 01 00 00       	jmp    801cb2 <lwip_getsockopt+0x164>
    sock_set_errno(sock, EFAULT);
  801bae:	c7 46 10 0e 00 00 00 	movl   $0xe,0x10(%esi)
  801bb5:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801bbc:	00 00 00 
    return -1;
  801bbf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801bc4:	e9 e9 00 00 00       	jmp    801cb2 <lwip_getsockopt+0x164>
  801bc9:	83 ff 20             	cmp    $0x20,%edi
  801bcc:	74 62                	je     801c30 <lwip_getsockopt+0xe2>
  801bce:	7e 4d                	jle    801c1d <lwip_getsockopt+0xcf>
  801bd0:	81 ff 07 10 00 00    	cmp    $0x1007,%edi
  801bd6:	0f 8c 04 01 00 00    	jl     801ce0 <lwip_getsockopt+0x192>
  801bdc:	81 ff 08 10 00 00    	cmp    $0x1008,%edi
  801be2:	7e 4c                	jle    801c30 <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801be4:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801be9:	81 ff 0a 10 00 00    	cmp    $0x100a,%edi
  801bef:	75 a8                	jne    801b99 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801bf1:	8b 45 18             	mov    0x18(%ebp),%eax
  801bf4:	83 38 04             	cmpl   $0x4,(%eax)
  801bf7:	19 c0                	sbb    %eax,%eax
  801bf9:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801bfc:	8b 16                	mov    (%esi),%edx
  801bfe:	83 3a 20             	cmpl   $0x20,(%edx)
  801c01:	0f 85 e3 00 00 00    	jne    801cea <lwip_getsockopt+0x19c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801c07:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801c0a:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801c0e:	0f 85 e0 00 00 00    	jne    801cf4 <lwip_getsockopt+0x1a6>
  if (err != ERR_OK) {
  801c14:	84 c0                	test   %al,%al
  801c16:	74 42                	je     801c5a <lwip_getsockopt+0x10c>
  801c18:	e9 7c ff ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
  801c1d:	83 ff 02             	cmp    $0x2,%edi
  801c20:	74 0e                	je     801c30 <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801c22:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c27:	83 ff 08             	cmp    $0x8,%edi
  801c2a:	0f 85 69 ff ff ff    	jne    801b99 <lwip_getsockopt+0x4b>
      if (*optlen < sizeof(int)) {
  801c30:	8b 45 18             	mov    0x18(%ebp),%eax
  801c33:	83 38 03             	cmpl   $0x3,(%eax)
  801c36:	77 22                	ja     801c5a <lwip_getsockopt+0x10c>
        err = EINVAL;
  801c38:	b8 16 00 00 00       	mov    $0x16,%eax
  801c3d:	e9 57 ff ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
  801c42:	8d 47 ff             	lea    -0x1(%edi),%eax
  801c45:	83 f8 01             	cmp    $0x1,%eax
  801c48:	0f 87 b0 00 00 00    	ja     801cfe <lwip_getsockopt+0x1b0>
      if (*optlen < sizeof(int)) {
  801c4e:	8b 45 18             	mov    0x18(%ebp),%eax
  801c51:	83 38 03             	cmpl   $0x3,(%eax)
  801c54:	0f 86 ae 00 00 00    	jbe    801d08 <lwip_getsockopt+0x1ba>
  data.sock = sock;
  801c5a:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801c5d:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801c60:	89 7d d8             	mov    %edi,-0x28(%ebp)
  data.optval = optval;
  801c63:	8b 45 14             	mov    0x14(%ebp),%eax
  801c66:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801c69:	8b 45 18             	mov    0x18(%ebp),%eax
  801c6c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801c6f:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801c73:	83 ec 04             	sub    $0x4,%esp
  801c76:	6a 01                	push   $0x1
  801c78:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801c7b:	50                   	push   %eax
  801c7c:	68 47 0b 80 00       	push   $0x800b47
  801c81:	e8 dc 05 00 00       	call   802262 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801c86:	83 c4 08             	add    $0x8,%esp
  801c89:	6a 00                	push   $0x0
  801c8b:	8b 06                	mov    (%esi),%eax
  801c8d:	ff 70 10             	pushl  0x10(%eax)
  801c90:	e8 39 84 00 00       	call   80a0ce <sys_arch_sem_wait>
  err = data.err;
  801c95:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801c99:	0f be d0             	movsbl %al,%edx
  801c9c:	89 56 10             	mov    %edx,0x10(%esi)
  801c9f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801ca5:	83 c4 10             	add    $0x10,%esp
  801ca8:	84 c0                	test   %al,%al
  801caa:	0f 95 c0             	setne  %al
  801cad:	0f b6 c0             	movzbl %al,%eax
  801cb0:	f7 d8                	neg    %eax
}
  801cb2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801cb5:	5b                   	pop    %ebx
  801cb6:	5e                   	pop    %esi
  801cb7:	5f                   	pop    %edi
  801cb8:	5d                   	pop    %ebp
  801cb9:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801cba:	8b 45 18             	mov    0x18(%ebp),%eax
  801cbd:	83 38 03             	cmpl   $0x3,(%eax)
  801cc0:	76 50                	jbe    801d12 <lwip_getsockopt+0x1c4>
    if (sock->conn->type != NETCONN_TCP)
  801cc2:	8b 16                	mov    (%esi),%edx
      return 0;
  801cc4:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801cc9:	83 3a 10             	cmpl   $0x10,(%edx)
  801ccc:	75 e4                	jne    801cb2 <lwip_getsockopt+0x164>
  801cce:	8d 47 ff             	lea    -0x1(%edi),%eax
  801cd1:	83 f8 01             	cmp    $0x1,%eax
  801cd4:	76 84                	jbe    801c5a <lwip_getsockopt+0x10c>
      err = ENOPROTOOPT;
  801cd6:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cdb:	e9 b9 fe ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801ce0:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ce5:	e9 af fe ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
  801cea:	b8 61 00 00 00       	mov    $0x61,%eax
  801cef:	e9 a5 fe ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
  801cf4:	b8 61 00 00 00       	mov    $0x61,%eax
  801cf9:	e9 9b fe ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801cfe:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d03:	e9 91 fe ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801d08:	b8 16 00 00 00       	mov    $0x16,%eax
  801d0d:	e9 87 fe ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
      err = EINVAL;
  801d12:	b8 16 00 00 00       	mov    $0x16,%eax
  801d17:	e9 7d fe ff ff       	jmp    801b99 <lwip_getsockopt+0x4b>
    return -1;
  801d1c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d21:	eb 8f                	jmp    801cb2 <lwip_getsockopt+0x164>

00801d23 <lwip_setsockopt>:
{
  801d23:	55                   	push   %ebp
  801d24:	89 e5                	mov    %esp,%ebp
  801d26:	57                   	push   %edi
  801d27:	56                   	push   %esi
  801d28:	53                   	push   %ebx
  801d29:	83 ec 2c             	sub    $0x2c,%esp
  801d2c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801d2f:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801d32:	8b 45 08             	mov    0x8(%ebp),%eax
  801d35:	e8 cb e9 ff ff       	call   800705 <get_socket>
  if (!sock)
  801d3a:	85 c0                	test   %eax,%eax
  801d3c:	0f 84 69 01 00 00    	je     801eab <lwip_setsockopt+0x188>
  801d42:	89 c6                	mov    %eax,%esi
  if (NULL == optval) {
  801d44:	85 ff                	test   %edi,%edi
  801d46:	74 2c                	je     801d74 <lwip_setsockopt+0x51>
  switch (level) {
  801d48:	83 fb 06             	cmp    $0x6,%ebx
  801d4b:	0f 84 01 01 00 00    	je     801e52 <lwip_setsockopt+0x12f>
  801d51:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801d57:	74 36                	je     801d8f <lwip_setsockopt+0x6c>
    err = ENOPROTOOPT;
  801d59:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801d5e:	85 db                	test   %ebx,%ebx
  801d60:	74 7b                	je     801ddd <lwip_setsockopt+0xba>
    sock_set_errno(sock, err);
  801d62:	89 46 10             	mov    %eax,0x10(%esi)
  801d65:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801d6a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d6f:	e9 d6 00 00 00       	jmp    801e4a <lwip_setsockopt+0x127>
    sock_set_errno(sock, EFAULT);
  801d74:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801d7b:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801d82:	00 00 00 
    return -1;
  801d85:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d8a:	e9 bb 00 00 00       	jmp    801e4a <lwip_setsockopt+0x127>
  801d8f:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801d93:	74 14                	je     801da9 <lwip_setsockopt+0x86>
  801d95:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801d9c:	74 18                	je     801db6 <lwip_setsockopt+0x93>
      err = ENOPROTOOPT;
  801d9e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801da3:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801da7:	75 b9                	jne    801d62 <lwip_setsockopt+0x3f>
      if (optlen < sizeof(int)) {
  801da9:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801dad:	77 47                	ja     801df6 <lwip_setsockopt+0xd3>
        err = EINVAL;
  801daf:	b8 16 00 00 00       	mov    $0x16,%eax
  801db4:	eb ac                	jmp    801d62 <lwip_setsockopt+0x3f>
        err = EINVAL;
  801db6:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801dba:	19 c0                	sbb    %eax,%eax
  801dbc:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801dbf:	8b 16                	mov    (%esi),%edx
  801dc1:	83 3a 20             	cmpl   $0x20,(%edx)
  801dc4:	0f 85 af 00 00 00    	jne    801e79 <lwip_setsockopt+0x156>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801dca:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801dcd:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801dd1:	0f 85 ac 00 00 00    	jne    801e83 <lwip_setsockopt+0x160>
  if (err != ERR_OK) {
  801dd7:	85 c0                	test   %eax,%eax
  801dd9:	74 1b                	je     801df6 <lwip_setsockopt+0xd3>
  801ddb:	eb 85                	jmp    801d62 <lwip_setsockopt+0x3f>
  801ddd:	8b 45 10             	mov    0x10(%ebp),%eax
  801de0:	83 e8 01             	sub    $0x1,%eax
  801de3:	83 f8 01             	cmp    $0x1,%eax
  801de6:	0f 87 a1 00 00 00    	ja     801e8d <lwip_setsockopt+0x16a>
      if (optlen < sizeof(int)) {
  801dec:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801df0:	0f 86 a1 00 00 00    	jbe    801e97 <lwip_setsockopt+0x174>
  data.sock = sock;
  801df6:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801df9:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801dfc:	8b 45 10             	mov    0x10(%ebp),%eax
  801dff:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801e02:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801e05:	8d 45 18             	lea    0x18(%ebp),%eax
  801e08:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801e0b:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801e0f:	83 ec 04             	sub    $0x4,%esp
  801e12:	6a 01                	push   $0x1
  801e14:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801e17:	50                   	push   %eax
  801e18:	68 d6 0c 80 00       	push   $0x800cd6
  801e1d:	e8 40 04 00 00       	call   802262 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801e22:	83 c4 08             	add    $0x8,%esp
  801e25:	6a 00                	push   $0x0
  801e27:	8b 06                	mov    (%esi),%eax
  801e29:	ff 70 10             	pushl  0x10(%eax)
  801e2c:	e8 9d 82 00 00       	call   80a0ce <sys_arch_sem_wait>
  err = data.err;
  801e31:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801e35:	89 46 10             	mov    %eax,0x10(%esi)
  801e38:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801e3d:	83 c4 10             	add    $0x10,%esp
  801e40:	85 c0                	test   %eax,%eax
  801e42:	0f 95 c0             	setne  %al
  801e45:	0f b6 c0             	movzbl %al,%eax
  801e48:	f7 d8                	neg    %eax
}
  801e4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801e4d:	5b                   	pop    %ebx
  801e4e:	5e                   	pop    %esi
  801e4f:	5f                   	pop    %edi
  801e50:	5d                   	pop    %ebp
  801e51:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801e52:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e56:	76 49                	jbe    801ea1 <lwip_setsockopt+0x17e>
    if (sock->conn->type != NETCONN_TCP)
  801e58:	8b 10                	mov    (%eax),%edx
      return 0;
  801e5a:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801e5f:	83 3a 10             	cmpl   $0x10,(%edx)
  801e62:	75 e6                	jne    801e4a <lwip_setsockopt+0x127>
  801e64:	8b 45 10             	mov    0x10(%ebp),%eax
  801e67:	83 e8 01             	sub    $0x1,%eax
  801e6a:	83 f8 01             	cmp    $0x1,%eax
  801e6d:	76 87                	jbe    801df6 <lwip_setsockopt+0xd3>
      err = ENOPROTOOPT;
  801e6f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e74:	e9 e9 fe ff ff       	jmp    801d62 <lwip_setsockopt+0x3f>
  801e79:	b8 61 00 00 00       	mov    $0x61,%eax
  801e7e:	e9 df fe ff ff       	jmp    801d62 <lwip_setsockopt+0x3f>
  801e83:	b8 61 00 00 00       	mov    $0x61,%eax
  801e88:	e9 d5 fe ff ff       	jmp    801d62 <lwip_setsockopt+0x3f>
        err = ENOPROTOOPT;
  801e8d:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e92:	e9 cb fe ff ff       	jmp    801d62 <lwip_setsockopt+0x3f>
        err = EINVAL;
  801e97:	b8 16 00 00 00       	mov    $0x16,%eax
  801e9c:	e9 c1 fe ff ff       	jmp    801d62 <lwip_setsockopt+0x3f>
      err = EINVAL;
  801ea1:	b8 16 00 00 00       	mov    $0x16,%eax
  801ea6:	e9 b7 fe ff ff       	jmp    801d62 <lwip_setsockopt+0x3f>
    return -1;
  801eab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801eb0:	eb 98                	jmp    801e4a <lwip_setsockopt+0x127>

00801eb2 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801eb2:	55                   	push   %ebp
  801eb3:	89 e5                	mov    %esp,%ebp
  801eb5:	56                   	push   %esi
  801eb6:	53                   	push   %ebx
  801eb7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801eba:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801ebd:	8b 45 08             	mov    0x8(%ebp),%eax
  801ec0:	e8 40 e8 ff ff       	call   800705 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801ec5:	85 c0                	test   %eax,%eax
  801ec7:	0f 84 b4 00 00 00    	je     801f81 <lwip_ioctl+0xcf>
    return -1;

  switch (cmd) {
  801ecd:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801ed3:	74 5d                	je     801f32 <lwip_ioctl+0x80>
  801ed5:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801edb:	0f 85 88 00 00 00    	jne    801f69 <lwip_ioctl+0xb7>
  case FIONREAD:
    if (!argp) {
  801ee1:	85 f6                	test   %esi,%esi
  801ee3:	74 35                	je     801f1a <lwip_ioctl+0x68>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801ee5:	8b 10                	mov    (%eax),%edx
  801ee7:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801eeb:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801eee:	8b 48 04             	mov    0x4(%eax),%ecx
  801ef1:	85 c9                	test   %ecx,%ecx
  801ef3:	74 0d                	je     801f02 <lwip_ioctl+0x50>
      buflen = netbuf_len(sock->lastdata);
  801ef5:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801ef7:	66 2b 50 08          	sub    0x8(%eax),%dx
  801efb:	66 03 51 08          	add    0x8(%ecx),%dx
  801eff:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801f02:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f09:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f10:	00 00 00 
    return 0;
  801f13:	b8 00 00 00 00       	mov    $0x0,%eax
  801f18:	eb 4b                	jmp    801f65 <lwip_ioctl+0xb3>
      sock_set_errno(sock, EINVAL);
  801f1a:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801f21:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801f28:	00 00 00 
      return -1;
  801f2b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f30:	eb 33                	jmp    801f65 <lwip_ioctl+0xb3>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801f32:	85 f6                	test   %esi,%esi
  801f34:	74 0e                	je     801f44 <lwip_ioctl+0x92>
  801f36:	83 3e 00             	cmpl   $0x0,(%esi)
  801f39:	74 09                	je     801f44 <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  801f3b:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801f3f:	80 ce 08             	or     $0x8,%dh
  801f42:	eb 07                	jmp    801f4b <lwip_ioctl+0x99>
    else
      sock->flags &= ~O_NONBLOCK;
  801f44:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801f48:	80 e6 f7             	and    $0xf7,%dh
  801f4b:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801f4f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f56:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f5d:	00 00 00 
    return 0;
  801f60:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  801f65:	5b                   	pop    %ebx
  801f66:	5e                   	pop    %esi
  801f67:	5d                   	pop    %ebp
  801f68:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  801f69:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  801f70:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  801f77:	00 00 00 
    return -1;
  801f7a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f7f:	eb e4                	jmp    801f65 <lwip_ioctl+0xb3>
    return -1;
  801f81:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f86:	eb dd                	jmp    801f65 <lwip_ioctl+0xb3>

00801f88 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  801f88:	55                   	push   %ebp
  801f89:	89 e5                	mov    %esp,%ebp
  801f8b:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  801f8e:	e8 2d 41 00 00       	call   8060c0 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  801f93:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  801f9a:	74 19                	je     801fb5 <tcpip_tcp_timer+0x2d>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  801f9c:	83 ec 04             	sub    $0x4,%esp
  801f9f:	6a 00                	push   $0x0
  801fa1:	68 88 1f 80 00       	push   $0x801f88
  801fa6:	68 fa 00 00 00       	push   $0xfa
  801fab:	e8 9e 31 00 00       	call   80514e <sys_timeout>
  801fb0:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  801fb3:	c9                   	leave  
  801fb4:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  801fb5:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  801fbc:	75 de                	jne    801f9c <tcpip_tcp_timer+0x14>
    tcpip_tcp_timer_active = 0;
  801fbe:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  801fc5:	00 00 00 
}
  801fc8:	eb e9                	jmp    801fb3 <tcpip_tcp_timer+0x2b>

00801fca <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  801fca:	55                   	push   %ebp
  801fcb:	89 e5                	mov    %esp,%ebp
  801fcd:	53                   	push   %ebx
  801fce:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  801fd1:	6a 00                	push   $0x0
  801fd3:	68 7a 21 80 00       	push   $0x80217a
  801fd8:	68 e8 03 00 00       	push   $0x3e8
  801fdd:	e8 6c 31 00 00       	call   80514e <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  801fe2:	83 c4 0c             	add    $0xc,%esp
  801fe5:	6a 00                	push   $0x0
  801fe7:	68 56 21 80 00       	push   $0x802156
  801fec:	68 88 13 00 00       	push   $0x1388
  801ff1:	e8 58 31 00 00       	call   80514e <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  801ff6:	83 c4 0c             	add    $0xc,%esp
  801ff9:	6a 00                	push   $0x0
  801ffb:	68 32 21 80 00       	push   $0x802132
  802000:	68 60 ea 00 00       	push   $0xea60
  802005:	e8 44 31 00 00       	call   80514e <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80200a:	83 c4 0c             	add    $0xc,%esp
  80200d:	6a 00                	push   $0x0
  80200f:	68 0e 21 80 00       	push   $0x80210e
  802014:	68 f4 01 00 00       	push   $0x1f4
  802019:	e8 30 31 00 00       	call   80514e <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80201e:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  802023:	83 c4 10             	add    $0x10,%esp
  802026:	85 c0                	test   %eax,%eax
  802028:	74 0e                	je     802038 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  80202a:	83 ec 0c             	sub    $0xc,%esp
  80202d:	ff 35 e4 52 81 00    	pushl  0x8152e4
  802033:	ff d0                	call   *%eax
  802035:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802038:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80203b:	eb 0f                	jmp    80204c <tcpip_thread+0x82>
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  80203d:	8b 42 08             	mov    0x8(%edx),%eax
  802040:	83 ec 0c             	sub    $0xc,%esp
  802043:	8d 50 04             	lea    0x4(%eax),%edx
  802046:	52                   	push   %edx
  802047:	ff 10                	call   *(%eax)
      break;
  802049:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  80204c:	83 ec 08             	sub    $0x8,%esp
  80204f:	53                   	push   %ebx
  802050:	ff 35 00 40 81 00    	pushl  0x814000
  802056:	e8 d3 2f 00 00       	call   80502e <sys_mbox_fetch>
    switch (msg->type) {
  80205b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80205e:	8b 02                	mov    (%edx),%eax
  802060:	83 c4 10             	add    $0x10,%esp
  802063:	83 f8 01             	cmp    $0x1,%eax
  802066:	74 3a                	je     8020a2 <tcpip_thread+0xd8>
  802068:	85 c0                	test   %eax,%eax
  80206a:	74 d1                	je     80203d <tcpip_thread+0x73>
  80206c:	83 f8 02             	cmp    $0x2,%eax
  80206f:	74 6c                	je     8020dd <tcpip_thread+0x113>
  802071:	83 f8 03             	cmp    $0x3,%eax
  802074:	75 d6                	jne    80204c <tcpip_thread+0x82>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  802076:	8b 42 08             	mov    0x8(%edx),%eax
  802079:	83 f8 ff             	cmp    $0xffffffff,%eax
  80207c:	74 7d                	je     8020fb <tcpip_thread+0x131>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  80207e:	83 ec 04             	sub    $0x4,%esp
  802081:	ff 72 10             	pushl  0x10(%edx)
  802084:	ff 72 0c             	pushl  0xc(%edx)
  802087:	50                   	push   %eax
  802088:	e8 c1 30 00 00       	call   80514e <sys_timeout>
  80208d:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802090:	83 ec 08             	sub    $0x8,%esp
  802093:	ff 75 f4             	pushl  -0xc(%ebp)
  802096:	6a 08                	push   $0x8
  802098:	e8 f6 23 00 00       	call   804493 <memp_free>
      break;
  80209d:	83 c4 10             	add    $0x10,%esp
  8020a0:	eb aa                	jmp    80204c <tcpip_thread+0x82>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  8020a2:	8b 42 0c             	mov    0xc(%edx),%eax
  8020a5:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  8020a9:	74 21                	je     8020cc <tcpip_thread+0x102>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8020ab:	83 ec 08             	sub    $0x8,%esp
  8020ae:	50                   	push   %eax
  8020af:	ff 72 08             	pushl  0x8(%edx)
  8020b2:	e8 40 7b 00 00       	call   809bf7 <ethernet_input>
  8020b7:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8020ba:	83 ec 08             	sub    $0x8,%esp
  8020bd:	ff 75 f4             	pushl  -0xc(%ebp)
  8020c0:	6a 09                	push   $0x9
  8020c2:	e8 cc 23 00 00       	call   804493 <memp_free>
      break;
  8020c7:	83 c4 10             	add    $0x10,%esp
  8020ca:	eb 80                	jmp    80204c <tcpip_thread+0x82>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8020cc:	83 ec 08             	sub    $0x8,%esp
  8020cf:	50                   	push   %eax
  8020d0:	ff 72 08             	pushl  0x8(%edx)
  8020d3:	e8 26 44 00 00       	call   8064fe <ip_input>
  8020d8:	83 c4 10             	add    $0x10,%esp
  8020db:	eb dd                	jmp    8020ba <tcpip_thread+0xf0>
      msg->msg.cb.f(msg->msg.cb.ctx);
  8020dd:	83 ec 0c             	sub    $0xc,%esp
  8020e0:	ff 72 0c             	pushl  0xc(%edx)
  8020e3:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8020e6:	83 c4 08             	add    $0x8,%esp
  8020e9:	ff 75 f4             	pushl  -0xc(%ebp)
  8020ec:	6a 08                	push   $0x8
  8020ee:	e8 a0 23 00 00       	call   804493 <memp_free>
      break;
  8020f3:	83 c4 10             	add    $0x10,%esp
  8020f6:	e9 51 ff ff ff       	jmp    80204c <tcpip_thread+0x82>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  8020fb:	83 ec 08             	sub    $0x8,%esp
  8020fe:	ff 72 10             	pushl  0x10(%edx)
  802101:	ff 72 0c             	pushl  0xc(%edx)
  802104:	e8 08 31 00 00       	call   805211 <sys_untimeout>
  802109:	83 c4 10             	add    $0x10,%esp
  80210c:	eb 82                	jmp    802090 <tcpip_thread+0xc6>

0080210e <dhcp_timer_fine>:
{
  80210e:	55                   	push   %ebp
  80210f:	89 e5                	mov    %esp,%ebp
  802111:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  802114:	e8 4a 1b 00 00       	call   803c63 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802119:	83 ec 04             	sub    $0x4,%esp
  80211c:	6a 00                	push   $0x0
  80211e:	68 0e 21 80 00       	push   $0x80210e
  802123:	68 f4 01 00 00       	push   $0x1f4
  802128:	e8 21 30 00 00       	call   80514e <sys_timeout>
}
  80212d:	83 c4 10             	add    $0x10,%esp
  802130:	c9                   	leave  
  802131:	c3                   	ret    

00802132 <dhcp_timer_coarse>:
{
  802132:	55                   	push   %ebp
  802133:	89 e5                	mov    %esp,%ebp
  802135:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  802138:	e8 5a 19 00 00       	call   803a97 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80213d:	83 ec 04             	sub    $0x4,%esp
  802140:	6a 00                	push   $0x0
  802142:	68 32 21 80 00       	push   $0x802132
  802147:	68 60 ea 00 00       	push   $0xea60
  80214c:	e8 fd 2f 00 00       	call   80514e <sys_timeout>
}
  802151:	83 c4 10             	add    $0x10,%esp
  802154:	c9                   	leave  
  802155:	c3                   	ret    

00802156 <arp_timer>:
{
  802156:	55                   	push   %ebp
  802157:	89 e5                	mov    %esp,%ebp
  802159:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  80215c:	e8 66 73 00 00       	call   8094c7 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802161:	83 ec 04             	sub    $0x4,%esp
  802164:	6a 00                	push   $0x0
  802166:	68 56 21 80 00       	push   $0x802156
  80216b:	68 88 13 00 00       	push   $0x1388
  802170:	e8 d9 2f 00 00       	call   80514e <sys_timeout>
}
  802175:	83 c4 10             	add    $0x10,%esp
  802178:	c9                   	leave  
  802179:	c3                   	ret    

0080217a <ip_reass_timer>:
{
  80217a:	55                   	push   %ebp
  80217b:	89 e5                	mov    %esp,%ebp
  80217d:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  802180:	e8 74 4a 00 00       	call   806bf9 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802185:	83 ec 04             	sub    $0x4,%esp
  802188:	6a 00                	push   $0x0
  80218a:	68 7a 21 80 00       	push   $0x80217a
  80218f:	68 e8 03 00 00       	push   $0x3e8
  802194:	e8 b5 2f 00 00       	call   80514e <sys_timeout>
}
  802199:	83 c4 10             	add    $0x10,%esp
  80219c:	c9                   	leave  
  80219d:	c3                   	ret    

0080219e <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  80219e:	55                   	push   %ebp
  80219f:	89 e5                	mov    %esp,%ebp
  8021a1:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8021a4:	ff 75 08             	pushl  0x8(%ebp)
  8021a7:	e8 37 26 00 00       	call   8047e3 <pbuf_free>
}
  8021ac:	83 c4 10             	add    $0x10,%esp
  8021af:	c9                   	leave  
  8021b0:	c3                   	ret    

008021b1 <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8021b1:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  8021b8:	75 38                	jne    8021f2 <tcp_timer_needed+0x41>
  8021ba:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  8021c1:	74 26                	je     8021e9 <tcp_timer_needed+0x38>
{
  8021c3:	55                   	push   %ebp
  8021c4:	89 e5                	mov    %esp,%ebp
  8021c6:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  8021c9:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  8021d0:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8021d3:	6a 00                	push   $0x0
  8021d5:	68 88 1f 80 00       	push   $0x801f88
  8021da:	68 fa 00 00 00       	push   $0xfa
  8021df:	e8 6a 2f 00 00       	call   80514e <sys_timeout>
  8021e4:	83 c4 10             	add    $0x10,%esp
}
  8021e7:	c9                   	leave  
  8021e8:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8021e9:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  8021f0:	75 d1                	jne    8021c3 <tcp_timer_needed+0x12>
  8021f2:	c3                   	ret    

008021f3 <tcpip_input>:
  if (mbox != SYS_MBOX_NULL) {
  8021f3:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8021fa:	74 59                	je     802255 <tcpip_input+0x62>
{
  8021fc:	55                   	push   %ebp
  8021fd:	89 e5                	mov    %esp,%ebp
  8021ff:	53                   	push   %ebx
  802200:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  802203:	6a 09                	push   $0x9
  802205:	e8 33 22 00 00       	call   80443d <memp_malloc>
  80220a:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  80220c:	83 c4 10             	add    $0x10,%esp
  80220f:	85 c0                	test   %eax,%eax
  802211:	74 48                	je     80225b <tcpip_input+0x68>
    msg->type = TCPIP_MSG_INPKT;
  802213:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  802219:	8b 45 08             	mov    0x8(%ebp),%eax
  80221c:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  80221f:	8b 45 0c             	mov    0xc(%ebp),%eax
  802222:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  802225:	83 ec 08             	sub    $0x8,%esp
  802228:	53                   	push   %ebx
  802229:	ff 35 00 40 81 00    	pushl  0x814000
  80222f:	e8 aa 7f 00 00       	call   80a1de <sys_mbox_trypost>
  802234:	83 c4 10             	add    $0x10,%esp
  802237:	84 c0                	test   %al,%al
  802239:	75 05                	jne    802240 <tcpip_input+0x4d>
}
  80223b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80223e:	c9                   	leave  
  80223f:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802240:	83 ec 08             	sub    $0x8,%esp
  802243:	53                   	push   %ebx
  802244:	6a 09                	push   $0x9
  802246:	e8 48 22 00 00       	call   804493 <memp_free>
      return ERR_MEM;
  80224b:	83 c4 10             	add    $0x10,%esp
  80224e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802253:	eb e6                	jmp    80223b <tcpip_input+0x48>
  return ERR_VAL;
  802255:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80225a:	c3                   	ret    
      return ERR_MEM;
  80225b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802260:	eb d9                	jmp    80223b <tcpip_input+0x48>

00802262 <tcpip_callback_with_block>:
{
  802262:	55                   	push   %ebp
  802263:	89 e5                	mov    %esp,%ebp
  802265:	56                   	push   %esi
  802266:	53                   	push   %ebx
  802267:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  80226a:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802271:	74 76                	je     8022e9 <tcpip_callback_with_block+0x87>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802273:	83 ec 0c             	sub    $0xc,%esp
  802276:	6a 08                	push   $0x8
  802278:	e8 c0 21 00 00       	call   80443d <memp_malloc>
  80227d:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  80227f:	83 c4 10             	add    $0x10,%esp
  802282:	85 c0                	test   %eax,%eax
  802284:	74 6a                	je     8022f0 <tcpip_callback_with_block+0x8e>
    msg->type = TCPIP_MSG_CALLBACK;
  802286:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80228c:	8b 45 08             	mov    0x8(%ebp),%eax
  80228f:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802292:	8b 45 0c             	mov    0xc(%ebp),%eax
  802295:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  802298:	89 f0                	mov    %esi,%eax
  80229a:	84 c0                	test   %al,%al
  80229c:	75 1d                	jne    8022bb <tcpip_callback_with_block+0x59>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80229e:	83 ec 08             	sub    $0x8,%esp
  8022a1:	53                   	push   %ebx
  8022a2:	ff 35 00 40 81 00    	pushl  0x814000
  8022a8:	e8 31 7f 00 00       	call   80a1de <sys_mbox_trypost>
  8022ad:	83 c4 10             	add    $0x10,%esp
  8022b0:	84 c0                	test   %al,%al
  8022b2:	75 20                	jne    8022d4 <tcpip_callback_with_block+0x72>
}
  8022b4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8022b7:	5b                   	pop    %ebx
  8022b8:	5e                   	pop    %esi
  8022b9:	5d                   	pop    %ebp
  8022ba:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  8022bb:	83 ec 08             	sub    $0x8,%esp
  8022be:	53                   	push   %ebx
  8022bf:	ff 35 00 40 81 00    	pushl  0x814000
  8022c5:	e8 d9 7f 00 00       	call   80a2a3 <sys_mbox_post>
  8022ca:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  8022cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8022d2:	eb e0                	jmp    8022b4 <tcpip_callback_with_block+0x52>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8022d4:	83 ec 08             	sub    $0x8,%esp
  8022d7:	53                   	push   %ebx
  8022d8:	6a 08                	push   $0x8
  8022da:	e8 b4 21 00 00       	call   804493 <memp_free>
        return ERR_MEM;
  8022df:	83 c4 10             	add    $0x10,%esp
  8022e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022e7:	eb cb                	jmp    8022b4 <tcpip_callback_with_block+0x52>
  return ERR_VAL;
  8022e9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8022ee:	eb c4                	jmp    8022b4 <tcpip_callback_with_block+0x52>
      return ERR_MEM;
  8022f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022f5:	eb bd                	jmp    8022b4 <tcpip_callback_with_block+0x52>

008022f7 <tcpip_timeout>:
  if (mbox != SYS_MBOX_NULL) {
  8022f7:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022fe:	74 45                	je     802345 <tcpip_timeout+0x4e>
{
  802300:	55                   	push   %ebp
  802301:	89 e5                	mov    %esp,%ebp
  802303:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802306:	6a 08                	push   $0x8
  802308:	e8 30 21 00 00       	call   80443d <memp_malloc>
    if (msg == NULL) {
  80230d:	83 c4 10             	add    $0x10,%esp
  802310:	85 c0                	test   %eax,%eax
  802312:	74 37                	je     80234b <tcpip_timeout+0x54>
    msg->type = TCPIP_MSG_TIMEOUT;
  802314:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  80231a:	8b 55 08             	mov    0x8(%ebp),%edx
  80231d:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  802320:	8b 55 0c             	mov    0xc(%ebp),%edx
  802323:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  802326:	8b 55 10             	mov    0x10(%ebp),%edx
  802329:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  80232c:	83 ec 08             	sub    $0x8,%esp
  80232f:	50                   	push   %eax
  802330:	ff 35 00 40 81 00    	pushl  0x814000
  802336:	e8 68 7f 00 00       	call   80a2a3 <sys_mbox_post>
    return ERR_OK;
  80233b:	83 c4 10             	add    $0x10,%esp
  80233e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802343:	c9                   	leave  
  802344:	c3                   	ret    
  return ERR_VAL;
  802345:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80234a:	c3                   	ret    
      return ERR_MEM;
  80234b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802350:	eb f1                	jmp    802343 <tcpip_timeout+0x4c>

00802352 <tcpip_apimsg>:
{
  802352:	55                   	push   %ebp
  802353:	89 e5                	mov    %esp,%ebp
  802355:	53                   	push   %ebx
  802356:	83 ec 24             	sub    $0x24,%esp
  802359:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  80235c:	a1 00 40 81 00       	mov    0x814000,%eax
  802361:	83 f8 ff             	cmp    $0xffffffff,%eax
  802364:	74 34                	je     80239a <tcpip_apimsg+0x48>
    msg.type = TCPIP_MSG_API;
  802366:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  80236d:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802370:	83 ec 08             	sub    $0x8,%esp
  802373:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802376:	52                   	push   %edx
  802377:	50                   	push   %eax
  802378:	e8 26 7f 00 00       	call   80a2a3 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80237d:	83 c4 08             	add    $0x8,%esp
  802380:	6a 00                	push   $0x0
  802382:	8b 43 04             	mov    0x4(%ebx),%eax
  802385:	ff 70 10             	pushl  0x10(%eax)
  802388:	e8 41 7d 00 00       	call   80a0ce <sys_arch_sem_wait>
    return ERR_OK;
  80238d:	83 c4 10             	add    $0x10,%esp
  802390:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802395:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802398:	c9                   	leave  
  802399:	c3                   	ret    
  return ERR_VAL;
  80239a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80239f:	eb f4                	jmp    802395 <tcpip_apimsg+0x43>

008023a1 <tcpip_init>:
{
  8023a1:	55                   	push   %ebp
  8023a2:	89 e5                	mov    %esp,%ebp
  8023a4:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  8023a7:	e8 71 03 00 00       	call   80271d <lwip_init>
  tcpip_init_done = initfunc;
  8023ac:	8b 45 08             	mov    0x8(%ebp),%eax
  8023af:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  8023b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023b7:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8023bc:	83 ec 0c             	sub    $0xc,%esp
  8023bf:	6a 00                	push   $0x0
  8023c1:	e8 84 7b 00 00       	call   809f4a <sys_mbox_new>
  8023c6:	a3 00 40 81 00       	mov    %eax,0x814000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8023cb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8023d2:	6a 00                	push   $0x0
  8023d4:	6a 00                	push   $0x0
  8023d6:	68 ca 1f 80 00       	push   $0x801fca
  8023db:	68 bc 11 81 00       	push   $0x8111bc
  8023e0:	e8 f1 7f 00 00       	call   80a3d6 <sys_thread_new>
}
  8023e5:	83 c4 20             	add    $0x20,%esp
  8023e8:	c9                   	leave  
  8023e9:	c3                   	ret    

008023ea <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8023ea:	55                   	push   %ebp
  8023eb:	89 e5                	mov    %esp,%ebp
  8023ed:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8023f0:	6a 00                	push   $0x0
  8023f2:	ff 75 08             	pushl  0x8(%ebp)
  8023f5:	68 9e 21 80 00       	push   $0x80219e
  8023fa:	e8 63 fe ff ff       	call   802262 <tcpip_callback_with_block>
}
  8023ff:	c9                   	leave  
  802400:	c3                   	ret    

00802401 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  802401:	55                   	push   %ebp
  802402:	89 e5                	mov    %esp,%ebp
  802404:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  802407:	6a 00                	push   $0x0
  802409:	ff 75 08             	pushl  0x8(%ebp)
  80240c:	68 fa 3e 80 00       	push   $0x803efa
  802411:	e8 4c fe ff ff       	call   802262 <tcpip_callback_with_block>
}
  802416:	c9                   	leave  
  802417:	c3                   	ret    

00802418 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  802418:	55                   	push   %ebp
  802419:	89 e5                	mov    %esp,%ebp
  80241b:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  80241e:	6a 06                	push   $0x6
  802420:	e8 18 20 00 00       	call   80443d <memp_malloc>
  if (buf != NULL) {
  802425:	83 c4 10             	add    $0x10,%esp
  802428:	85 c0                	test   %eax,%eax
  80242a:	74 14                	je     802440 <netbuf_new+0x28>
    buf->p = NULL;
  80242c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  802432:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802439:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802440:	c9                   	leave  
  802441:	c3                   	ret    

00802442 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  802442:	55                   	push   %ebp
  802443:	89 e5                	mov    %esp,%ebp
  802445:	53                   	push   %ebx
  802446:	83 ec 04             	sub    $0x4,%esp
  802449:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  80244c:	85 db                	test   %ebx,%ebx
  80244e:	74 2d                	je     80247d <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802450:	8b 03                	mov    (%ebx),%eax
  802452:	85 c0                	test   %eax,%eax
  802454:	74 19                	je     80246f <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  802456:	83 ec 0c             	sub    $0xc,%esp
  802459:	50                   	push   %eax
  80245a:	e8 84 23 00 00       	call   8047e3 <pbuf_free>
      buf->p = buf->ptr = NULL;
  80245f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802466:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80246c:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  80246f:	83 ec 08             	sub    $0x8,%esp
  802472:	53                   	push   %ebx
  802473:	6a 06                	push   $0x6
  802475:	e8 19 20 00 00       	call   804493 <memp_free>
  80247a:	83 c4 10             	add    $0x10,%esp
  }
}
  80247d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802480:	c9                   	leave  
  802481:	c3                   	ret    

00802482 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802482:	55                   	push   %ebp
  802483:	89 e5                	mov    %esp,%ebp
  802485:	56                   	push   %esi
  802486:	53                   	push   %ebx
  802487:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80248a:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80248d:	85 db                	test   %ebx,%ebx
  80248f:	74 3e                	je     8024cf <netbuf_alloc+0x4d>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802491:	8b 03                	mov    (%ebx),%eax
  802493:	85 c0                	test   %eax,%eax
  802495:	74 0c                	je     8024a3 <netbuf_alloc+0x21>
    pbuf_free(buf->p);
  802497:	83 ec 0c             	sub    $0xc,%esp
  80249a:	50                   	push   %eax
  80249b:	e8 43 23 00 00       	call   8047e3 <pbuf_free>
  8024a0:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8024a3:	83 ec 04             	sub    $0x4,%esp
  8024a6:	6a 00                	push   $0x0
  8024a8:	0f b7 c6             	movzwl %si,%eax
  8024ab:	50                   	push   %eax
  8024ac:	6a 00                	push   $0x0
  8024ae:	e8 f6 23 00 00       	call   8048a9 <pbuf_alloc>
  8024b3:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8024b5:	83 c4 10             	add    $0x10,%esp
  8024b8:	85 c0                	test   %eax,%eax
  8024ba:	74 3b                	je     8024f7 <netbuf_alloc+0x75>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8024bc:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8024c0:	72 21                	jb     8024e3 <netbuf_alloc+0x61>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8024c2:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8024c5:	8b 40 04             	mov    0x4(%eax),%eax
}
  8024c8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8024cb:	5b                   	pop    %ebx
  8024cc:	5e                   	pop    %esi
  8024cd:	5d                   	pop    %ebp
  8024ce:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8024cf:	83 ec 04             	sub    $0x4,%esp
  8024d2:	68 c9 11 81 00       	push   $0x8111c9
  8024d7:	6a 63                	push   $0x63
  8024d9:	68 e3 11 81 00       	push   $0x8111e3
  8024de:	e8 8d c0 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  8024e3:	83 ec 04             	sub    $0x4,%esp
  8024e6:	68 b0 12 81 00       	push   $0x8112b0
  8024eb:	6a 6e                	push   $0x6e
  8024ed:	68 e3 11 81 00       	push   $0x8111e3
  8024f2:	e8 79 c0 00 00       	call   80e570 <_panic>
     return NULL;
  8024f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8024fc:	eb ca                	jmp    8024c8 <netbuf_alloc+0x46>

008024fe <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8024fe:	55                   	push   %ebp
  8024ff:	89 e5                	mov    %esp,%ebp
  802501:	53                   	push   %ebx
  802502:	83 ec 04             	sub    $0x4,%esp
  802505:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802508:	85 db                	test   %ebx,%ebx
  80250a:	74 24                	je     802530 <netbuf_free+0x32>
  if (buf->p != NULL) {
  80250c:	8b 03                	mov    (%ebx),%eax
  80250e:	85 c0                	test   %eax,%eax
  802510:	74 0c                	je     80251e <netbuf_free+0x20>
    pbuf_free(buf->p);
  802512:	83 ec 0c             	sub    $0xc,%esp
  802515:	50                   	push   %eax
  802516:	e8 c8 22 00 00       	call   8047e3 <pbuf_free>
  80251b:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  80251e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802525:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  80252b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80252e:	c9                   	leave  
  80252f:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802530:	83 ec 04             	sub    $0x4,%esp
  802533:	68 f9 11 81 00       	push   $0x8111f9
  802538:	6a 7b                	push   $0x7b
  80253a:	68 e3 11 81 00       	push   $0x8111e3
  80253f:	e8 2c c0 00 00       	call   80e570 <_panic>

00802544 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802544:	55                   	push   %ebp
  802545:	89 e5                	mov    %esp,%ebp
  802547:	56                   	push   %esi
  802548:	53                   	push   %ebx
  802549:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80254c:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  80254f:	85 db                	test   %ebx,%ebx
  802551:	74 4c                	je     80259f <netbuf_ref+0x5b>
  if (buf->p != NULL) {
  802553:	8b 03                	mov    (%ebx),%eax
  802555:	85 c0                	test   %eax,%eax
  802557:	74 0c                	je     802565 <netbuf_ref+0x21>
    pbuf_free(buf->p);
  802559:	83 ec 0c             	sub    $0xc,%esp
  80255c:	50                   	push   %eax
  80255d:	e8 81 22 00 00       	call   8047e3 <pbuf_free>
  802562:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802565:	83 ec 04             	sub    $0x4,%esp
  802568:	6a 02                	push   $0x2
  80256a:	6a 00                	push   $0x0
  80256c:	6a 00                	push   $0x0
  80256e:	e8 36 23 00 00       	call   8048a9 <pbuf_alloc>
  802573:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802575:	83 c4 10             	add    $0x10,%esp
  802578:	85 c0                	test   %eax,%eax
  80257a:	74 3a                	je     8025b6 <netbuf_ref+0x72>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  80257c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80257f:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802582:	8b 03                	mov    (%ebx),%eax
  802584:	66 89 70 08          	mov    %si,0x8(%eax)
  802588:	8b 03                	mov    (%ebx),%eax
  80258a:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80258e:	8b 03                	mov    (%ebx),%eax
  802590:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  802593:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802598:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80259b:	5b                   	pop    %ebx
  80259c:	5e                   	pop    %esi
  80259d:	5d                   	pop    %ebp
  80259e:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  80259f:	83 ec 04             	sub    $0x4,%esp
  8025a2:	68 12 12 81 00       	push   $0x811212
  8025a7:	68 8e 00 00 00       	push   $0x8e
  8025ac:	68 e3 11 81 00       	push   $0x8111e3
  8025b1:	e8 ba bf 00 00       	call   80e570 <_panic>
    buf->ptr = NULL;
  8025b6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  8025bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8025c2:	eb d4                	jmp    802598 <netbuf_ref+0x54>

008025c4 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8025c4:	55                   	push   %ebp
  8025c5:	89 e5                	mov    %esp,%ebp
  8025c7:	56                   	push   %esi
  8025c8:	53                   	push   %ebx
  8025c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025cc:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8025cf:	85 db                	test   %ebx,%ebx
  8025d1:	74 2a                	je     8025fd <netbuf_chain+0x39>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8025d3:	85 f6                	test   %esi,%esi
  8025d5:	74 3d                	je     802614 <netbuf_chain+0x50>
  pbuf_chain(head->p, tail->p);
  8025d7:	83 ec 08             	sub    $0x8,%esp
  8025da:	ff 36                	pushl  (%esi)
  8025dc:	ff 33                	pushl  (%ebx)
  8025de:	e8 e1 26 00 00       	call   804cc4 <pbuf_chain>
  head->ptr = head->p;
  8025e3:	8b 03                	mov    (%ebx),%eax
  8025e5:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8025e8:	83 c4 08             	add    $0x8,%esp
  8025eb:	56                   	push   %esi
  8025ec:	6a 06                	push   $0x6
  8025ee:	e8 a0 1e 00 00       	call   804493 <memp_free>
  8025f3:	83 c4 10             	add    $0x10,%esp
}
  8025f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8025f9:	5b                   	pop    %ebx
  8025fa:	5e                   	pop    %esi
  8025fb:	5d                   	pop    %ebp
  8025fc:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8025fd:	83 ec 04             	sub    $0x4,%esp
  802600:	68 2a 12 81 00       	push   $0x81122a
  802605:	68 a6 00 00 00       	push   $0xa6
  80260a:	68 e3 11 81 00       	push   $0x8111e3
  80260f:	e8 5c bf 00 00       	call   80e570 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802614:	83 ec 04             	sub    $0x4,%esp
  802617:	68 43 12 81 00       	push   $0x811243
  80261c:	68 a7 00 00 00       	push   $0xa7
  802621:	68 e3 11 81 00       	push   $0x8111e3
  802626:	e8 45 bf 00 00       	call   80e570 <_panic>

0080262b <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80262b:	55                   	push   %ebp
  80262c:	89 e5                	mov    %esp,%ebp
  80262e:	53                   	push   %ebx
  80262f:	83 ec 04             	sub    $0x4,%esp
  802632:	8b 45 08             	mov    0x8(%ebp),%eax
  802635:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802638:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80263b:	85 c0                	test   %eax,%eax
  80263d:	74 28                	je     802667 <netbuf_data+0x3c>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80263f:	85 c9                	test   %ecx,%ecx
  802641:	74 3b                	je     80267e <netbuf_data+0x53>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802643:	85 d2                	test   %edx,%edx
  802645:	74 4e                	je     802695 <netbuf_data+0x6a>

  if (buf->ptr == NULL) {
  802647:	8b 58 04             	mov    0x4(%eax),%ebx
  80264a:	85 db                	test   %ebx,%ebx
  80264c:	74 5e                	je     8026ac <netbuf_data+0x81>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  80264e:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802651:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802653:	8b 40 04             	mov    0x4(%eax),%eax
  802656:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  80265a:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  80265d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802662:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802665:	c9                   	leave  
  802666:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802667:	83 ec 04             	sub    $0x4,%esp
  80266a:	68 5e 12 81 00       	push   $0x81125e
  80266f:	68 b9 00 00 00       	push   $0xb9
  802674:	68 e3 11 81 00       	push   $0x8111e3
  802679:	e8 f2 be 00 00       	call   80e570 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80267e:	83 ec 04             	sub    $0x4,%esp
  802681:	68 77 12 81 00       	push   $0x811277
  802686:	68 ba 00 00 00       	push   $0xba
  80268b:	68 e3 11 81 00       	push   $0x8111e3
  802690:	e8 db be 00 00       	call   80e570 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802695:	83 ec 04             	sub    $0x4,%esp
  802698:	68 94 12 81 00       	push   $0x811294
  80269d:	68 bb 00 00 00       	push   $0xbb
  8026a2:	68 e3 11 81 00       	push   $0x8111e3
  8026a7:	e8 c4 be 00 00       	call   80e570 <_panic>
    return ERR_BUF;
  8026ac:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8026b1:	eb af                	jmp    802662 <netbuf_data+0x37>

008026b3 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8026b3:	55                   	push   %ebp
  8026b4:	89 e5                	mov    %esp,%ebp
  8026b6:	83 ec 08             	sub    $0x8,%esp
  8026b9:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8026bc:	85 c0                	test   %eax,%eax
  8026be:	74 14                	je     8026d4 <netbuf_next+0x21>
  if (buf->ptr->next == NULL) {
  8026c0:	8b 50 04             	mov    0x4(%eax),%edx
  8026c3:	8b 12                	mov    (%edx),%edx
  8026c5:	85 d2                	test   %edx,%edx
  8026c7:	74 22                	je     8026eb <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  8026c9:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  8026cc:	83 3a 00             	cmpl   $0x0,(%edx)
  8026cf:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  8026d2:	c9                   	leave  
  8026d3:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8026d4:	83 ec 04             	sub    $0x4,%esp
  8026d7:	68 f9 11 81 00       	push   $0x8111f9
  8026dc:	68 d2 00 00 00       	push   $0xd2
  8026e1:	68 e3 11 81 00       	push   $0x8111e3
  8026e6:	e8 85 be 00 00       	call   80e570 <_panic>
    return -1;
  8026eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026f0:	eb e0                	jmp    8026d2 <netbuf_next+0x1f>

008026f2 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8026f2:	55                   	push   %ebp
  8026f3:	89 e5                	mov    %esp,%ebp
  8026f5:	83 ec 08             	sub    $0x8,%esp
  8026f8:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8026fb:	85 c0                	test   %eax,%eax
  8026fd:	74 07                	je     802706 <netbuf_first+0x14>
  buf->ptr = buf->p;
  8026ff:	8b 10                	mov    (%eax),%edx
  802701:	89 50 04             	mov    %edx,0x4(%eax)
}
  802704:	c9                   	leave  
  802705:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802706:	83 ec 04             	sub    $0x4,%esp
  802709:	68 f9 11 81 00       	push   $0x8111f9
  80270e:	68 e7 00 00 00       	push   $0xe7
  802713:	68 e3 11 81 00       	push   $0x8111e3
  802718:	e8 53 be 00 00       	call   80e570 <_panic>

0080271d <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  80271d:	55                   	push   %ebp
  80271e:	89 e5                	mov    %esp,%ebp
  802720:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802723:	e8 dc 75 00 00       	call   809d04 <sys_init>
  mem_init();
  802728:	e8 67 17 00 00       	call   803e94 <mem_init>
  memp_init();
  80272d:	e8 af 1c 00 00       	call   8043e1 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802732:	e8 ac e6 ff ff       	call   800de3 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802737:	c9                   	leave  
  802738:	c3                   	ret    

00802739 <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  802739:	38 10                	cmp    %dl,(%eax)
  80273b:	74 06                	je     802743 <dhcp_set_state+0xa>
    dhcp->state = new_state;
  80273d:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  80273f:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802743:	c3                   	ret    

00802744 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802744:	55                   	push   %ebp
  802745:	89 e5                	mov    %esp,%ebp
  802747:	57                   	push   %edi
  802748:	56                   	push   %esi
  802749:	53                   	push   %ebx
  80274a:	83 ec 08             	sub    $0x8,%esp
  80274d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802750:	8b 70 14             	mov    0x14(%eax),%esi
  802753:	85 f6                	test   %esi,%esi
  802755:	0f 84 eb 00 00 00    	je     802846 <dhcp_get_option_ptr+0x102>
  80275b:	0f b7 78 18          	movzwl 0x18(%eax),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  80275f:	b9 00 00 00 00       	mov    $0x0,%ecx
  u8_t overload = DHCP_OVERLOAD_NONE;
  802764:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802768:	b8 00 00 00 00       	mov    $0x0,%eax
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80276d:	66 85 ff             	test   %di,%di
  802770:	75 28                	jne    80279a <dhcp_get_option_ptr+0x56>
}
  802772:	83 c4 08             	add    $0x8,%esp
  802775:	5b                   	pop    %ebx
  802776:	5e                   	pop    %esi
  802777:	5f                   	pop    %edi
  802778:	5d                   	pop    %ebp
  802779:	c3                   	ret    
        offset += 2;
  80277a:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  80277d:	83 c1 03             	add    $0x3,%ecx
  802780:	0f b7 c0             	movzwl %ax,%eax
  802783:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802787:	88 45 f3             	mov    %al,-0xd(%ebp)
  80278a:	eb 0e                	jmp    80279a <dhcp_get_option_ptr+0x56>
        offset++;
  80278c:	8d 41 01             	lea    0x1(%ecx),%eax
        offset += 1 + options[offset];
  80278f:	0f b7 c0             	movzwl %ax,%eax
  802792:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802796:	8d 4c 08 02          	lea    0x2(%eax,%ecx,1),%ecx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80279a:	66 39 cf             	cmp    %cx,%di
  80279d:	76 18                	jbe    8027b7 <dhcp_get_option_ptr+0x73>
  80279f:	0f b7 c1             	movzwl %cx,%eax
  8027a2:	01 f0                	add    %esi,%eax
  8027a4:	0f b6 18             	movzbl (%eax),%ebx
  8027a7:	80 fb ff             	cmp    $0xff,%bl
  8027aa:	74 0b                	je     8027b7 <dhcp_get_option_ptr+0x73>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  8027ac:	80 fb 34             	cmp    $0x34,%bl
  8027af:	74 c9                	je     80277a <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  8027b1:	38 d3                	cmp    %dl,%bl
  8027b3:	75 d7                	jne    80278c <dhcp_get_option_ptr+0x48>
  8027b5:	eb bb                	jmp    802772 <dhcp_get_option_ptr+0x2e>
  return NULL;
  8027b7:	b8 00 00 00 00       	mov    $0x0,%eax
    if (overload != DHCP_OVERLOAD_NONE) {
  8027bc:	0f b6 5d f3          	movzbl -0xd(%ebp),%ebx
  8027c0:	84 db                	test   %bl,%bl
  8027c2:	74 ae                	je     802772 <dhcp_get_option_ptr+0x2e>
      if (overload == DHCP_OVERLOAD_FILE) {
  8027c4:	80 fb 01             	cmp    $0x1,%bl
  8027c7:	74 53                	je     80281c <dhcp_get_option_ptr+0xd8>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8027c9:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
  8027cd:	74 5d                	je     80282c <dhcp_get_option_ptr+0xe8>
        options = (u8_t *)&dhcp->msg_in->sname;
  8027cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8027d2:	8b 58 10             	mov    0x10(%eax),%ebx
  8027d5:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8027d8:	be c0 00 00 00       	mov    $0xc0,%esi
      offset = 0;
  8027dd:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027e2:	88 55 f3             	mov    %dl,-0xd(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8027e5:	0f b7 c1             	movzwl %cx,%eax
  8027e8:	01 d8                	add    %ebx,%eax
  8027ea:	0f b6 38             	movzbl (%eax),%edi
  8027ed:	89 fa                	mov    %edi,%edx
  8027ef:	80 fa ff             	cmp    $0xff,%dl
  8027f2:	74 48                	je     80283c <dhcp_get_option_ptr+0xf8>
        if (options[offset] == option_type) {
  8027f4:	89 fa                	mov    %edi,%edx
  8027f6:	3a 55 f3             	cmp    -0xd(%ebp),%dl
  8027f9:	0f 84 73 ff ff ff    	je     802772 <dhcp_get_option_ptr+0x2e>
          offset++;
  8027ff:	8d 41 01             	lea    0x1(%ecx),%eax
          offset += 1 + options[offset];
  802802:	0f b7 c0             	movzwl %ax,%eax
  802805:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
  802809:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80280d:	66 39 ce             	cmp    %cx,%si
  802810:	77 d3                	ja     8027e5 <dhcp_get_option_ptr+0xa1>
  return NULL;
  802812:	b8 00 00 00 00       	mov    $0x0,%eax
  802817:	e9 56 ff ff ff       	jmp    802772 <dhcp_get_option_ptr+0x2e>
        options = (u8_t *)&dhcp->msg_in->file;
  80281c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80281f:	8b 58 10             	mov    0x10(%eax),%ebx
  802822:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  802825:	be 80 00 00 00       	mov    $0x80,%esi
  80282a:	eb b1                	jmp    8027dd <dhcp_get_option_ptr+0x99>
        options = (u8_t *)&dhcp->msg_in->sname;
  80282c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80282f:	8b 58 10             	mov    0x10(%eax),%ebx
  802832:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  802835:	be 40 00 00 00       	mov    $0x40,%esi
  80283a:	eb a1                	jmp    8027dd <dhcp_get_option_ptr+0x99>
  return NULL;
  80283c:	b8 00 00 00 00       	mov    $0x0,%eax
  802841:	e9 2c ff ff ff       	jmp    802772 <dhcp_get_option_ptr+0x2e>
  802846:	b8 00 00 00 00       	mov    $0x0,%eax
  80284b:	e9 22 ff ff ff       	jmp    802772 <dhcp_get_option_ptr+0x2e>

00802850 <dhcp_get_option_long>:
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802850:	0f b6 10             	movzbl (%eax),%edx
  802853:	89 d1                	mov    %edx,%ecx
  802855:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802858:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80285c:	c1 e2 10             	shl    $0x10,%edx
  80285f:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802861:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  802865:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  802867:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  80286b:	c1 e0 08             	shl    $0x8,%eax
  value |= (u32_t)(*ptr++);
  80286e:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802870:	c3                   	ret    

00802871 <dhcp_option_byte>:
{
  802871:	55                   	push   %ebp
  802872:	89 e5                	mov    %esp,%ebp
  802874:	56                   	push   %esi
  802875:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802876:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80287a:	66 83 f9 43          	cmp    $0x43,%cx
  80287e:	77 1b                	ja     80289b <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802880:	8b 58 20             	mov    0x20(%eax),%ebx
  802883:	8d 71 01             	lea    0x1(%ecx),%esi
  802886:	66 89 70 24          	mov    %si,0x24(%eax)
  80288a:	0f b7 c9             	movzwl %cx,%ecx
  80288d:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802894:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802897:	5b                   	pop    %ebx
  802898:	5e                   	pop    %esi
  802899:	5d                   	pop    %ebp
  80289a:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80289b:	83 ec 04             	sub    $0x4,%esp
  80289e:	68 d4 12 81 00       	push   $0x8112d4
  8028a3:	68 65 04 00 00       	push   $0x465
  8028a8:	68 22 16 81 00       	push   $0x811622
  8028ad:	e8 be bc 00 00       	call   80e570 <_panic>

008028b2 <dhcp_option>:
{
  8028b2:	55                   	push   %ebp
  8028b3:	89 e5                	mov    %esp,%ebp
  8028b5:	57                   	push   %edi
  8028b6:	56                   	push   %esi
  8028b7:	53                   	push   %ebx
  8028b8:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8028bb:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8028bf:	0f b6 f9             	movzbl %cl,%edi
  8028c2:	0f b7 f3             	movzwl %bx,%esi
  8028c5:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8028c9:	83 fe 44             	cmp    $0x44,%esi
  8028cc:	77 34                	ja     802902 <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8028ce:	8b 70 20             	mov    0x20(%eax),%esi
  8028d1:	8d 7b 01             	lea    0x1(%ebx),%edi
  8028d4:	66 89 78 24          	mov    %di,0x24(%eax)
  8028d8:	0f b7 db             	movzwl %bx,%ebx
  8028db:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8028e2:	8b 58 20             	mov    0x20(%eax),%ebx
  8028e5:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8028e9:	8d 72 01             	lea    0x1(%edx),%esi
  8028ec:	66 89 70 24          	mov    %si,0x24(%eax)
  8028f0:	0f b7 d2             	movzwl %dx,%edx
  8028f3:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  8028fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8028fd:	5b                   	pop    %ebx
  8028fe:	5e                   	pop    %esi
  8028ff:	5f                   	pop    %edi
  802900:	5d                   	pop    %ebp
  802901:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802902:	83 ec 04             	sub    $0x4,%esp
  802905:	68 10 13 81 00       	push   $0x811310
  80290a:	68 5a 04 00 00       	push   $0x45a
  80290f:	68 22 16 81 00       	push   $0x811622
  802914:	e8 57 bc 00 00       	call   80e570 <_panic>

00802919 <dhcp_option_short>:
{
  802919:	55                   	push   %ebp
  80291a:	89 e5                	mov    %esp,%ebp
  80291c:	56                   	push   %esi
  80291d:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80291e:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802922:	0f b7 d9             	movzwl %cx,%ebx
  802925:	83 c3 02             	add    $0x2,%ebx
  802928:	83 fb 44             	cmp    $0x44,%ebx
  80292b:	77 33                	ja     802960 <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80292d:	8b 58 20             	mov    0x20(%eax),%ebx
  802930:	8d 71 01             	lea    0x1(%ecx),%esi
  802933:	66 89 70 24          	mov    %si,0x24(%eax)
  802937:	0f b7 c9             	movzwl %cx,%ecx
  80293a:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802941:	8b 58 20             	mov    0x20(%eax),%ebx
  802944:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802948:	8d 71 01             	lea    0x1(%ecx),%esi
  80294b:	66 89 70 24          	mov    %si,0x24(%eax)
  80294f:	0f b7 c9             	movzwl %cx,%ecx
  802952:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802959:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80295c:	5b                   	pop    %ebx
  80295d:	5e                   	pop    %esi
  80295e:	5d                   	pop    %ebp
  80295f:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802960:	83 ec 04             	sub    $0x4,%esp
  802963:	68 58 13 81 00       	push   $0x811358
  802968:	68 6c 04 00 00       	push   $0x46c
  80296d:	68 22 16 81 00       	push   $0x811622
  802972:	e8 f9 bb 00 00       	call   80e570 <_panic>

00802977 <dhcp_option_trailer>:
{
  802977:	55                   	push   %ebp
  802978:	89 e5                	mov    %esp,%ebp
  80297a:	53                   	push   %ebx
  80297b:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80297e:	85 c0                	test   %eax,%eax
  802980:	74 25                	je     8029a7 <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802982:	8b 48 20             	mov    0x20(%eax),%ecx
  802985:	85 c9                	test   %ecx,%ecx
  802987:	74 35                	je     8029be <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802989:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  80298d:	66 83 fa 43          	cmp    $0x43,%dx
  802991:	77 42                	ja     8029d5 <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802993:	8d 5a 01             	lea    0x1(%edx),%ebx
  802996:	66 89 58 24          	mov    %bx,0x24(%eax)
  80299a:	0f b7 d2             	movzwl %dx,%edx
  80299d:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  8029a4:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8029a5:	eb 5a                	jmp    802a01 <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  8029a7:	83 ec 04             	sub    $0x4,%esp
  8029aa:	68 9c 13 81 00       	push   $0x81139c
  8029af:	68 80 05 00 00       	push   $0x580
  8029b4:	68 22 16 81 00       	push   $0x811622
  8029b9:	e8 b2 bb 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  8029be:	83 ec 04             	sub    $0x4,%esp
  8029c1:	68 c0 13 81 00       	push   $0x8113c0
  8029c6:	68 81 05 00 00       	push   $0x581
  8029cb:	68 22 16 81 00       	push   $0x811622
  8029d0:	e8 9b bb 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8029d5:	83 ec 04             	sub    $0x4,%esp
  8029d8:	68 ec 13 81 00       	push   $0x8113ec
  8029dd:	68 82 05 00 00       	push   $0x582
  8029e2:	68 22 16 81 00       	push   $0x811622
  8029e7:	e8 84 bb 00 00       	call   80e570 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  8029ec:	8b 48 20             	mov    0x20(%eax),%ecx
  8029ef:	8d 5a 01             	lea    0x1(%edx),%ebx
  8029f2:	66 89 58 24          	mov    %bx,0x24(%eax)
  8029f6:	0f b7 d2             	movzwl %dx,%edx
  8029f9:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802a00:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a01:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a05:	66 83 fa 43          	cmp    $0x43,%dx
  802a09:	76 e1                	jbe    8029ec <dhcp_option_trailer+0x75>
  802a0b:	f6 c2 03             	test   $0x3,%dl
  802a0e:	74 17                	je     802a27 <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a10:	83 ec 04             	sub    $0x4,%esp
  802a13:	68 ec 13 81 00       	push   $0x8113ec
  802a18:	68 87 05 00 00       	push   $0x587
  802a1d:	68 22 16 81 00       	push   $0x811622
  802a22:	e8 49 bb 00 00       	call   80e570 <_panic>
}
  802a27:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802a2a:	c9                   	leave  
  802a2b:	c3                   	ret    

00802a2c <dhcp_option_long>:
{
  802a2c:	55                   	push   %ebp
  802a2d:	89 e5                	mov    %esp,%ebp
  802a2f:	56                   	push   %esi
  802a30:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802a31:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a35:	0f b7 d9             	movzwl %cx,%ebx
  802a38:	83 c3 04             	add    $0x4,%ebx
  802a3b:	83 fb 44             	cmp    $0x44,%ebx
  802a3e:	77 6d                	ja     802aad <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802a40:	8d 71 01             	lea    0x1(%ecx),%esi
  802a43:	66 89 70 24          	mov    %si,0x24(%eax)
  802a47:	0f b7 c9             	movzwl %cx,%ecx
  802a4a:	89 d3                	mov    %edx,%ebx
  802a4c:	c1 eb 18             	shr    $0x18,%ebx
  802a4f:	8b 70 20             	mov    0x20(%eax),%esi
  802a52:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802a59:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a5d:	8d 71 01             	lea    0x1(%ecx),%esi
  802a60:	66 89 70 24          	mov    %si,0x24(%eax)
  802a64:	0f b7 c9             	movzwl %cx,%ecx
  802a67:	89 d3                	mov    %edx,%ebx
  802a69:	c1 eb 10             	shr    $0x10,%ebx
  802a6c:	8b 70 20             	mov    0x20(%eax),%esi
  802a6f:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802a76:	8b 58 20             	mov    0x20(%eax),%ebx
  802a79:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a7d:	8d 71 01             	lea    0x1(%ecx),%esi
  802a80:	66 89 70 24          	mov    %si,0x24(%eax)
  802a84:	0f b7 c9             	movzwl %cx,%ecx
  802a87:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802a8e:	8b 58 20             	mov    0x20(%eax),%ebx
  802a91:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a95:	8d 71 01             	lea    0x1(%ecx),%esi
  802a98:	66 89 70 24          	mov    %si,0x24(%eax)
  802a9c:	0f b7 c9             	movzwl %cx,%ecx
  802a9f:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802aa6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802aa9:	5b                   	pop    %ebx
  802aaa:	5e                   	pop    %esi
  802aab:	5d                   	pop    %ebp
  802aac:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802aad:	83 ec 04             	sub    $0x4,%esp
  802ab0:	68 2c 14 81 00       	push   $0x81142c
  802ab5:	68 74 04 00 00       	push   $0x474
  802aba:	68 22 16 81 00       	push   $0x811622
  802abf:	e8 ac ba 00 00       	call   80e570 <_panic>

00802ac4 <dhcp_create_request>:
{
  802ac4:	55                   	push   %ebp
  802ac5:	89 e5                	mov    %esp,%ebp
  802ac7:	57                   	push   %edi
  802ac8:	56                   	push   %esi
  802ac9:	53                   	push   %ebx
  802aca:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802acd:	85 c0                	test   %eax,%eax
  802acf:	0f 84 d8 00 00 00    	je     802bad <dhcp_create_request+0xe9>
  802ad5:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802ad7:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802ada:	85 db                	test   %ebx,%ebx
  802adc:	0f 84 e2 00 00 00    	je     802bc4 <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802ae2:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802ae6:	0f 85 ef 00 00 00    	jne    802bdb <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802aec:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802af0:	0f 85 fc 00 00 00    	jne    802bf2 <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802af6:	83 ec 04             	sub    $0x4,%esp
  802af9:	6a 00                	push   $0x0
  802afb:	68 34 01 00 00       	push   $0x134
  802b00:	6a 00                	push   $0x0
  802b02:	e8 a2 1d 00 00       	call   8048a9 <pbuf_alloc>
  802b07:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802b0a:	83 c4 10             	add    $0x10,%esp
  802b0d:	85 c0                	test   %eax,%eax
  802b0f:	0f 84 9b 01 00 00    	je     802cb0 <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802b15:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802b1b:	0f 86 e8 00 00 00    	jbe    802c09 <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802b21:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802b27:	8d 4a 01             	lea    0x1(%edx),%ecx
  802b2a:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802b30:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802b33:	8b 40 04             	mov    0x4(%eax),%eax
  802b36:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802b39:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802b3c:	8b 43 20             	mov    0x20(%ebx),%eax
  802b3f:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802b43:	8b 43 20             	mov    0x20(%ebx),%eax
  802b46:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802b4a:	8b 43 20             	mov    0x20(%ebx),%eax
  802b4d:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802b51:	8b 7b 20             	mov    0x20(%ebx),%edi
  802b54:	83 ec 0c             	sub    $0xc,%esp
  802b57:	ff 73 04             	pushl  0x4(%ebx)
  802b5a:	e8 80 4b 00 00       	call   8076df <htonl>
  802b5f:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802b62:	8b 43 20             	mov    0x20(%ebx),%eax
  802b65:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802b6b:	8b 43 20             	mov    0x20(%ebx),%eax
  802b6e:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802b74:	8b 43 20             	mov    0x20(%ebx),%eax
  802b77:	8b 56 04             	mov    0x4(%esi),%edx
  802b7a:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802b7d:	8b 43 20             	mov    0x20(%ebx),%eax
  802b80:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802b87:	8b 43 20             	mov    0x20(%ebx),%eax
  802b8a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802b91:	8b 43 20             	mov    0x20(%ebx),%eax
  802b94:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802b9b:	83 c4 10             	add    $0x10,%esp
  802b9e:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802ba3:	bf 00 00 00 00       	mov    $0x0,%edi
  802ba8:	e9 82 00 00 00       	jmp    802c2f <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802bad:	83 ec 04             	sub    $0x4,%esp
  802bb0:	68 6c 14 81 00       	push   $0x81146c
  802bb5:	68 2d 05 00 00       	push   $0x52d
  802bba:	68 22 16 81 00       	push   $0x811622
  802bbf:	e8 ac b9 00 00       	call   80e570 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802bc4:	83 ec 04             	sub    $0x4,%esp
  802bc7:	68 90 14 81 00       	push   $0x811490
  802bcc:	68 2f 05 00 00       	push   $0x52f
  802bd1:	68 22 16 81 00       	push   $0x811622
  802bd6:	e8 95 b9 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802bdb:	83 ec 04             	sub    $0x4,%esp
  802bde:	68 b4 14 81 00       	push   $0x8114b4
  802be3:	68 30 05 00 00       	push   $0x530
  802be8:	68 22 16 81 00       	push   $0x811622
  802bed:	e8 7e b9 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802bf2:	83 ec 04             	sub    $0x4,%esp
  802bf5:	68 e0 14 81 00       	push   $0x8114e0
  802bfa:	68 31 05 00 00       	push   $0x531
  802bff:	68 22 16 81 00       	push   $0x811622
  802c04:	e8 67 b9 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802c09:	83 ec 04             	sub    $0x4,%esp
  802c0c:	68 0c 15 81 00       	push   $0x81150c
  802c11:	68 38 05 00 00       	push   $0x538
  802c16:	68 22 16 81 00       	push   $0x811622
  802c1b:	e8 50 b9 00 00       	call   80e570 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c20:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802c23:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802c27:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802c2a:	83 f8 10             	cmp    $0x10,%eax
  802c2d:	74 12                	je     802c41 <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c2f:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802c33:	89 fa                	mov    %edi,%edx
  802c35:	66 39 c1             	cmp    %ax,%cx
  802c38:	76 e6                	jbe    802c20 <dhcp_create_request+0x15c>
  802c3a:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802c3f:	eb df                	jmp    802c20 <dhcp_create_request+0x15c>
  802c41:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802c46:	8b 53 20             	mov    0x20(%ebx),%edx
  802c49:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802c4e:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802c51:	83 f8 40             	cmp    $0x40,%eax
  802c54:	75 f0                	jne    802c46 <dhcp_create_request+0x182>
  802c56:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802c5b:	8b 53 20             	mov    0x20(%ebx),%edx
  802c5e:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802c63:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802c66:	3d 80 00 00 00       	cmp    $0x80,%eax
  802c6b:	75 ee                	jne    802c5b <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802c6d:	8b 73 20             	mov    0x20(%ebx),%esi
  802c70:	83 ec 0c             	sub    $0xc,%esp
  802c73:	68 63 53 82 63       	push   $0x63825363
  802c78:	e8 62 4a 00 00       	call   8076df <htonl>
  802c7d:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802c83:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802c89:	83 c4 10             	add    $0x10,%esp
  802c8c:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802c91:	8b 53 20             	mov    0x20(%ebx),%edx
  802c94:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802c9b:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802c9e:	83 f8 44             	cmp    $0x44,%eax
  802ca1:	75 ee                	jne    802c91 <dhcp_create_request+0x1cd>
  return ERR_OK;
  802ca3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802ca8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802cab:	5b                   	pop    %ebx
  802cac:	5e                   	pop    %esi
  802cad:	5f                   	pop    %edi
  802cae:	5d                   	pop    %ebp
  802caf:	c3                   	ret    
    return ERR_MEM;
  802cb0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802cb5:	eb f1                	jmp    802ca8 <dhcp_create_request+0x1e4>

00802cb7 <dhcp_delete_request>:
{
  802cb7:	55                   	push   %ebp
  802cb8:	89 e5                	mov    %esp,%ebp
  802cba:	53                   	push   %ebx
  802cbb:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802cbe:	85 c0                	test   %eax,%eax
  802cc0:	74 33                	je     802cf5 <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802cc2:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802cc5:	85 db                	test   %ebx,%ebx
  802cc7:	74 43                	je     802d0c <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802cc9:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802ccc:	85 c0                	test   %eax,%eax
  802cce:	74 53                	je     802d23 <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802cd0:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802cd4:	74 64                	je     802d3a <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802cd6:	83 ec 0c             	sub    $0xc,%esp
  802cd9:	50                   	push   %eax
  802cda:	e8 04 1b 00 00       	call   8047e3 <pbuf_free>
  dhcp->p_out = NULL;
  802cdf:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802ce6:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802ced:	83 c4 10             	add    $0x10,%esp
}
  802cf0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802cf3:	c9                   	leave  
  802cf4:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802cf5:	83 ec 04             	sub    $0x4,%esp
  802cf8:	68 50 15 81 00       	push   $0x811550
  802cfd:	68 69 05 00 00       	push   $0x569
  802d02:	68 22 16 81 00       	push   $0x811622
  802d07:	e8 64 b8 00 00       	call   80e570 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d0c:	83 ec 04             	sub    $0x4,%esp
  802d0f:	68 74 15 81 00       	push   $0x811574
  802d14:	68 6b 05 00 00       	push   $0x56b
  802d19:	68 22 16 81 00       	push   $0x811622
  802d1e:	e8 4d b8 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802d23:	83 ec 04             	sub    $0x4,%esp
  802d26:	68 98 15 81 00       	push   $0x811598
  802d2b:	68 6c 05 00 00       	push   $0x56c
  802d30:	68 22 16 81 00       	push   $0x811622
  802d35:	e8 36 b8 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802d3a:	83 ec 04             	sub    $0x4,%esp
  802d3d:	68 c4 15 81 00       	push   $0x8115c4
  802d42:	68 6d 05 00 00       	push   $0x56d
  802d47:	68 22 16 81 00       	push   $0x811622
  802d4c:	e8 1f b8 00 00       	call   80e570 <_panic>

00802d51 <dhcp_rebind>:
{
  802d51:	55                   	push   %ebp
  802d52:	89 e5                	mov    %esp,%ebp
  802d54:	57                   	push   %edi
  802d55:	56                   	push   %esi
  802d56:	53                   	push   %ebx
  802d57:	83 ec 0c             	sub    $0xc,%esp
  802d5a:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802d5c:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802d5f:	ba 04 00 00 00       	mov    $0x4,%edx
  802d64:	89 d8                	mov    %ebx,%eax
  802d66:	e8 ce f9 ff ff       	call   802739 <dhcp_set_state>
  result = dhcp_create_request(netif);
  802d6b:	89 f8                	mov    %edi,%eax
  802d6d:	e8 52 fd ff ff       	call   802ac4 <dhcp_create_request>
  802d72:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802d74:	84 c0                	test   %al,%al
  802d76:	74 3e                	je     802db6 <dhcp_rebind+0x65>
  dhcp->tries++;
  802d78:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802d7c:	83 c0 01             	add    $0x1,%eax
  802d7f:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802d82:	ba 10 27 00 00       	mov    $0x2710,%edx
  802d87:	3c 09                	cmp    $0x9,%al
  802d89:	77 08                	ja     802d93 <dhcp_rebind+0x42>
  802d8b:	0f b6 d0             	movzbl %al,%edx
  802d8e:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802d93:	0f b7 d2             	movzwl %dx,%edx
  802d96:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802d9c:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802da1:	89 d0                	mov    %edx,%eax
  802da3:	f7 e9                	imul   %ecx
  802da5:	c1 fa 05             	sar    $0x5,%edx
  802da8:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802dac:	89 f0                	mov    %esi,%eax
  802dae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802db1:	5b                   	pop    %ebx
  802db2:	5e                   	pop    %esi
  802db3:	5f                   	pop    %edi
  802db4:	5d                   	pop    %ebp
  802db5:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802db6:	b9 01 00 00 00       	mov    $0x1,%ecx
  802dbb:	ba 35 00 00 00       	mov    $0x35,%edx
  802dc0:	89 d8                	mov    %ebx,%eax
  802dc2:	e8 eb fa ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802dc7:	ba 03 00 00 00       	mov    $0x3,%edx
  802dcc:	89 d8                	mov    %ebx,%eax
  802dce:	e8 9e fa ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802dd3:	b9 02 00 00 00       	mov    $0x2,%ecx
  802dd8:	ba 39 00 00 00       	mov    $0x39,%edx
  802ddd:	89 d8                	mov    %ebx,%eax
  802ddf:	e8 ce fa ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802de4:	ba 40 02 00 00       	mov    $0x240,%edx
  802de9:	89 d8                	mov    %ebx,%eax
  802deb:	e8 29 fb ff ff       	call   802919 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802df0:	89 d8                	mov    %ebx,%eax
  802df2:	e8 80 fb ff ff       	call   802977 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802df7:	83 ec 08             	sub    $0x8,%esp
  802dfa:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802dfe:	66 05 f0 00          	add    $0xf0,%ax
  802e02:	0f b7 c0             	movzwl %ax,%eax
  802e05:	50                   	push   %eax
  802e06:	ff 73 1c             	pushl  0x1c(%ebx)
  802e09:	e8 0d 1d 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802e0e:	83 c4 0c             	add    $0xc,%esp
  802e11:	6a 43                	push   $0x43
  802e13:	68 c8 1e 81 00       	push   $0x811ec8
  802e18:	ff 73 08             	pushl  0x8(%ebx)
  802e1b:	e8 bb 60 00 00       	call   808edb <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802e20:	89 3c 24             	mov    %edi,(%esp)
  802e23:	6a 43                	push   $0x43
  802e25:	68 c4 1e 81 00       	push   $0x811ec4
  802e2a:	ff 73 1c             	pushl  0x1c(%ebx)
  802e2d:	ff 73 08             	pushl  0x8(%ebx)
  802e30:	e8 b1 5e 00 00       	call   808ce6 <udp_sendto_if>
    dhcp_delete_request(netif);
  802e35:	83 c4 20             	add    $0x20,%esp
  802e38:	89 f8                	mov    %edi,%eax
  802e3a:	e8 78 fe ff ff       	call   802cb7 <dhcp_delete_request>
  802e3f:	e9 34 ff ff ff       	jmp    802d78 <dhcp_rebind+0x27>

00802e44 <dhcp_discover>:
{
  802e44:	55                   	push   %ebp
  802e45:	89 e5                	mov    %esp,%ebp
  802e47:	57                   	push   %edi
  802e48:	56                   	push   %esi
  802e49:	53                   	push   %ebx
  802e4a:	83 ec 0c             	sub    $0xc,%esp
  802e4d:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e4f:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802e52:	a1 c8 1e 81 00       	mov    0x811ec8,%eax
  802e57:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  802e5a:	89 f8                	mov    %edi,%eax
  802e5c:	e8 63 fc ff ff       	call   802ac4 <dhcp_create_request>
  802e61:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e63:	84 c0                	test   %al,%al
  802e65:	74 41                	je     802ea8 <dhcp_discover+0x64>
  dhcp->tries++;
  802e67:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802e6b:	83 c0 01             	add    $0x1,%eax
  802e6e:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802e71:	ba 10 27 00 00       	mov    $0x2710,%edx
  802e76:	3c 03                	cmp    $0x3,%al
  802e78:	77 0b                	ja     802e85 <dhcp_discover+0x41>
  802e7a:	0f b6 d0             	movzbl %al,%edx
  802e7d:	83 c2 01             	add    $0x1,%edx
  802e80:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802e85:	0f b7 d2             	movzwl %dx,%edx
  802e88:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802e8e:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802e93:	89 d0                	mov    %edx,%eax
  802e95:	f7 e9                	imul   %ecx
  802e97:	c1 fa 05             	sar    $0x5,%edx
  802e9a:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802e9e:	89 f0                	mov    %esi,%eax
  802ea0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ea3:	5b                   	pop    %ebx
  802ea4:	5e                   	pop    %esi
  802ea5:	5f                   	pop    %edi
  802ea6:	5d                   	pop    %ebp
  802ea7:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802ea8:	b9 01 00 00 00       	mov    $0x1,%ecx
  802ead:	ba 35 00 00 00       	mov    $0x35,%edx
  802eb2:	89 d8                	mov    %ebx,%eax
  802eb4:	e8 f9 f9 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802eb9:	ba 01 00 00 00       	mov    $0x1,%edx
  802ebe:	89 d8                	mov    %ebx,%eax
  802ec0:	e8 ac f9 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802ec5:	b9 02 00 00 00       	mov    $0x2,%ecx
  802eca:	ba 39 00 00 00       	mov    $0x39,%edx
  802ecf:	89 d8                	mov    %ebx,%eax
  802ed1:	e8 dc f9 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802ed6:	ba 40 02 00 00       	mov    $0x240,%edx
  802edb:	89 d8                	mov    %ebx,%eax
  802edd:	e8 37 fa ff ff       	call   802919 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802ee2:	b9 04 00 00 00       	mov    $0x4,%ecx
  802ee7:	ba 37 00 00 00       	mov    $0x37,%edx
  802eec:	89 d8                	mov    %ebx,%eax
  802eee:	e8 bf f9 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802ef3:	ba 01 00 00 00       	mov    $0x1,%edx
  802ef8:	89 d8                	mov    %ebx,%eax
  802efa:	e8 72 f9 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802eff:	ba 03 00 00 00       	mov    $0x3,%edx
  802f04:	89 d8                	mov    %ebx,%eax
  802f06:	e8 66 f9 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802f0b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802f10:	89 d8                	mov    %ebx,%eax
  802f12:	e8 5a f9 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802f17:	ba 06 00 00 00       	mov    $0x6,%edx
  802f1c:	89 d8                	mov    %ebx,%eax
  802f1e:	e8 4e f9 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  802f23:	89 d8                	mov    %ebx,%eax
  802f25:	e8 4d fa ff ff       	call   802977 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802f2a:	83 ec 08             	sub    $0x8,%esp
  802f2d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802f31:	66 05 f0 00          	add    $0xf0,%ax
  802f35:	0f b7 c0             	movzwl %ax,%eax
  802f38:	50                   	push   %eax
  802f39:	ff 73 1c             	pushl  0x1c(%ebx)
  802f3c:	e8 da 1b 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802f41:	83 c4 0c             	add    $0xc,%esp
  802f44:	6a 43                	push   $0x43
  802f46:	68 c8 1e 81 00       	push   $0x811ec8
  802f4b:	ff 73 08             	pushl  0x8(%ebx)
  802f4e:	e8 88 5f 00 00       	call   808edb <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802f53:	89 3c 24             	mov    %edi,(%esp)
  802f56:	6a 43                	push   $0x43
  802f58:	68 c4 1e 81 00       	push   $0x811ec4
  802f5d:	ff 73 1c             	pushl  0x1c(%ebx)
  802f60:	ff 73 08             	pushl  0x8(%ebx)
  802f63:	e8 7e 5d 00 00       	call   808ce6 <udp_sendto_if>
    dhcp_delete_request(netif);
  802f68:	83 c4 20             	add    $0x20,%esp
  802f6b:	89 f8                	mov    %edi,%eax
  802f6d:	e8 45 fd ff ff       	call   802cb7 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802f72:	ba 06 00 00 00       	mov    $0x6,%edx
  802f77:	89 d8                	mov    %ebx,%eax
  802f79:	e8 bb f7 ff ff       	call   802739 <dhcp_set_state>
  802f7e:	e9 e4 fe ff ff       	jmp    802e67 <dhcp_discover+0x23>

00802f83 <dhcp_select>:
{
  802f83:	55                   	push   %ebp
  802f84:	89 e5                	mov    %esp,%ebp
  802f86:	57                   	push   %edi
  802f87:	56                   	push   %esi
  802f88:	53                   	push   %ebx
  802f89:	83 ec 0c             	sub    $0xc,%esp
  802f8c:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f8e:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  802f91:	e8 2e fb ff ff       	call   802ac4 <dhcp_create_request>
  802f96:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f98:	84 c0                	test   %al,%al
  802f9a:	74 3e                	je     802fda <dhcp_select+0x57>
  dhcp->tries++;
  802f9c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802fa0:	83 c0 01             	add    $0x1,%eax
  802fa3:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  802fa6:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  802fab:	3c 03                	cmp    $0x3,%al
  802fad:	77 08                	ja     802fb7 <dhcp_select+0x34>
  802faf:	0f b6 d0             	movzbl %al,%edx
  802fb2:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802fb7:	0f b7 d2             	movzwl %dx,%edx
  802fba:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802fc0:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802fc5:	89 d0                	mov    %edx,%eax
  802fc7:	f7 e9                	imul   %ecx
  802fc9:	c1 fa 05             	sar    $0x5,%edx
  802fcc:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802fd0:	89 f0                	mov    %esi,%eax
  802fd2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802fd5:	5b                   	pop    %ebx
  802fd6:	5e                   	pop    %esi
  802fd7:	5f                   	pop    %edi
  802fd8:	5d                   	pop    %ebp
  802fd9:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802fda:	b9 01 00 00 00       	mov    $0x1,%ecx
  802fdf:	ba 35 00 00 00       	mov    $0x35,%edx
  802fe4:	89 d8                	mov    %ebx,%eax
  802fe6:	e8 c7 f8 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802feb:	ba 03 00 00 00       	mov    $0x3,%edx
  802ff0:	89 d8                	mov    %ebx,%eax
  802ff2:	e8 7a f8 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802ff7:	b9 02 00 00 00       	mov    $0x2,%ecx
  802ffc:	ba 39 00 00 00       	mov    $0x39,%edx
  803001:	89 d8                	mov    %ebx,%eax
  803003:	e8 aa f8 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803008:	ba 40 02 00 00       	mov    $0x240,%edx
  80300d:	89 d8                	mov    %ebx,%eax
  80300f:	e8 05 f9 ff ff       	call   802919 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803014:	b9 04 00 00 00       	mov    $0x4,%ecx
  803019:	ba 32 00 00 00       	mov    $0x32,%edx
  80301e:	89 d8                	mov    %ebx,%eax
  803020:	e8 8d f8 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803025:	83 ec 0c             	sub    $0xc,%esp
  803028:	ff 73 30             	pushl  0x30(%ebx)
  80302b:	e8 c6 48 00 00       	call   8078f6 <ntohl>
  803030:	89 c2                	mov    %eax,%edx
  803032:	89 d8                	mov    %ebx,%eax
  803034:	e8 f3 f9 ff ff       	call   802a2c <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  803039:	b9 04 00 00 00       	mov    $0x4,%ecx
  80303e:	ba 36 00 00 00       	mov    $0x36,%edx
  803043:	89 d8                	mov    %ebx,%eax
  803045:	e8 68 f8 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80304a:	83 c4 04             	add    $0x4,%esp
  80304d:	ff 73 2c             	pushl  0x2c(%ebx)
  803050:	e8 a1 48 00 00       	call   8078f6 <ntohl>
  803055:	89 c2                	mov    %eax,%edx
  803057:	89 d8                	mov    %ebx,%eax
  803059:	e8 ce f9 ff ff       	call   802a2c <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80305e:	b9 04 00 00 00       	mov    $0x4,%ecx
  803063:	ba 37 00 00 00       	mov    $0x37,%edx
  803068:	89 d8                	mov    %ebx,%eax
  80306a:	e8 43 f8 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80306f:	ba 01 00 00 00       	mov    $0x1,%edx
  803074:	89 d8                	mov    %ebx,%eax
  803076:	e8 f6 f7 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80307b:	ba 03 00 00 00       	mov    $0x3,%edx
  803080:	89 d8                	mov    %ebx,%eax
  803082:	e8 ea f7 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803087:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80308c:	89 d8                	mov    %ebx,%eax
  80308e:	e8 de f7 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803093:	ba 06 00 00 00       	mov    $0x6,%edx
  803098:	89 d8                	mov    %ebx,%eax
  80309a:	e8 d2 f7 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  80309f:	89 d8                	mov    %ebx,%eax
  8030a1:	e8 d1 f8 ff ff       	call   802977 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8030a6:	83 c4 08             	add    $0x8,%esp
  8030a9:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8030ad:	66 05 f0 00          	add    $0xf0,%ax
  8030b1:	0f b7 c0             	movzwl %ax,%eax
  8030b4:	50                   	push   %eax
  8030b5:	ff 73 1c             	pushl  0x1c(%ebx)
  8030b8:	e8 5e 1a 00 00       	call   804b1b <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8030bd:	89 3c 24             	mov    %edi,(%esp)
  8030c0:	6a 43                	push   $0x43
  8030c2:	68 c4 1e 81 00       	push   $0x811ec4
  8030c7:	ff 73 1c             	pushl  0x1c(%ebx)
  8030ca:	ff 73 08             	pushl  0x8(%ebx)
  8030cd:	e8 14 5c 00 00       	call   808ce6 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8030d2:	83 c4 1c             	add    $0x1c,%esp
  8030d5:	6a 43                	push   $0x43
  8030d7:	68 c8 1e 81 00       	push   $0x811ec8
  8030dc:	ff 73 08             	pushl  0x8(%ebx)
  8030df:	e8 f7 5d 00 00       	call   808edb <udp_connect>
    dhcp_delete_request(netif);
  8030e4:	89 f8                	mov    %edi,%eax
  8030e6:	e8 cc fb ff ff       	call   802cb7 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8030eb:	ba 01 00 00 00       	mov    $0x1,%edx
  8030f0:	89 d8                	mov    %ebx,%eax
  8030f2:	e8 42 f6 ff ff       	call   802739 <dhcp_set_state>
  8030f7:	83 c4 10             	add    $0x10,%esp
  8030fa:	e9 9d fe ff ff       	jmp    802f9c <dhcp_select+0x19>

008030ff <dhcp_check>:
{
  8030ff:	55                   	push   %ebp
  803100:	89 e5                	mov    %esp,%ebp
  803102:	53                   	push   %ebx
  803103:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  803106:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  803109:	6a 00                	push   $0x0
  80310b:	8d 53 30             	lea    0x30(%ebx),%edx
  80310e:	52                   	push   %edx
  80310f:	50                   	push   %eax
  803110:	e8 ba 67 00 00       	call   8098cf <etharp_query>
  dhcp->tries++;
  803115:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803119:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80311f:	ba 08 00 00 00       	mov    $0x8,%edx
  803124:	89 d8                	mov    %ebx,%eax
  803126:	e8 0e f6 ff ff       	call   802739 <dhcp_set_state>
}
  80312b:	83 c4 10             	add    $0x10,%esp
  80312e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803131:	c9                   	leave  
  803132:	c3                   	ret    

00803133 <dhcp_bind>:
{
  803133:	55                   	push   %ebp
  803134:	89 e5                	mov    %esp,%ebp
  803136:	56                   	push   %esi
  803137:	53                   	push   %ebx
  803138:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80313b:	85 c0                	test   %eax,%eax
  80313d:	0f 84 cf 00 00 00    	je     803212 <dhcp_bind+0xdf>
  803143:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  803145:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803148:	85 db                	test   %ebx,%ebx
  80314a:	0f 84 d9 00 00 00    	je     803229 <dhcp_bind+0xf6>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803150:	8b 53 50             	mov    0x50(%ebx),%edx
  803153:	83 fa ff             	cmp    $0xffffffff,%edx
  803156:	74 2a                	je     803182 <dhcp_bind+0x4f>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803158:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  80315b:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803161:	0f 87 74 01 00 00    	ja     8032db <dhcp_bind+0x1a8>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803167:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80316c:	89 d0                	mov    %edx,%eax
  80316e:	f7 e1                	mul    %ecx
  803170:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t1_timeout == 0) {
  803173:	66 85 d2             	test   %dx,%dx
  803176:	0f 85 c4 00 00 00    	jne    803240 <dhcp_bind+0x10d>
      dhcp->t1_timeout = 1;
  80317c:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803182:	8b 53 54             	mov    0x54(%ebx),%edx
  803185:	83 fa ff             	cmp    $0xffffffff,%edx
  803188:	74 2a                	je     8031b4 <dhcp_bind+0x81>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80318a:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  80318d:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803193:	0f 87 37 01 00 00    	ja     8032d0 <dhcp_bind+0x19d>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803199:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80319e:	89 d0                	mov    %edx,%eax
  8031a0:	f7 e1                	mul    %ecx
  8031a2:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t2_timeout == 0) {
  8031a5:	66 85 d2             	test   %dx,%dx
  8031a8:	0f 85 9b 00 00 00    	jne    803249 <dhcp_bind+0x116>
      dhcp->t2_timeout = 1;
  8031ae:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8031b4:	8b 43 34             	mov    0x34(%ebx),%eax
  8031b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  8031ba:	85 c0                	test   %eax,%eax
  8031bc:	0f 84 90 00 00 00    	je     803252 <dhcp_bind+0x11f>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8031c2:	8b 43 38             	mov    0x38(%ebx),%eax
  8031c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  8031c8:	85 c0                	test   %eax,%eax
  8031ca:	0f 84 e2 00 00 00    	je     8032b2 <dhcp_bind+0x17f>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8031d0:	83 ec 08             	sub    $0x8,%esp
  8031d3:	8d 43 30             	lea    0x30(%ebx),%eax
  8031d6:	50                   	push   %eax
  8031d7:	56                   	push   %esi
  8031d8:	e8 76 13 00 00       	call   804553 <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  8031dd:	83 c4 08             	add    $0x8,%esp
  8031e0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8031e3:	50                   	push   %eax
  8031e4:	56                   	push   %esi
  8031e5:	e8 ae 14 00 00       	call   804698 <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  8031ea:	83 c4 08             	add    $0x8,%esp
  8031ed:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8031f0:	50                   	push   %eax
  8031f1:	56                   	push   %esi
  8031f2:	e8 88 14 00 00       	call   80467f <netif_set_gw>
  netif_set_up(netif);
  8031f7:	89 34 24             	mov    %esi,(%esp)
  8031fa:	e8 bf 14 00 00       	call   8046be <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  8031ff:	ba 0a 00 00 00       	mov    $0xa,%edx
  803204:	89 d8                	mov    %ebx,%eax
  803206:	e8 2e f5 ff ff       	call   802739 <dhcp_set_state>
}
  80320b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80320e:	5b                   	pop    %ebx
  80320f:	5e                   	pop    %esi
  803210:	5d                   	pop    %ebp
  803211:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803212:	83 ec 04             	sub    $0x4,%esp
  803215:	68 37 16 81 00       	push   $0x811637
  80321a:	68 3d 03 00 00       	push   $0x33d
  80321f:	68 22 16 81 00       	push   $0x811622
  803224:	e8 47 b3 00 00       	call   80e570 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803229:	83 ec 04             	sub    $0x4,%esp
  80322c:	68 50 16 81 00       	push   $0x811650
  803231:	68 3f 03 00 00       	push   $0x33f
  803236:	68 22 16 81 00       	push   $0x811622
  80323b:	e8 30 b3 00 00       	call   80e570 <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  803240:	66 89 53 28          	mov    %dx,0x28(%ebx)
  803244:	e9 39 ff ff ff       	jmp    803182 <dhcp_bind+0x4f>
    dhcp->t2_timeout = (u16_t)timeout;
  803249:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
  80324d:	e9 62 ff ff ff       	jmp    8031b4 <dhcp_bind+0x81>
    u8_t first_octet = ip4_addr1(&sn_mask);
  803252:	83 ec 0c             	sub    $0xc,%esp
  803255:	6a 00                	push   $0x0
  803257:	e8 9a 46 00 00       	call   8078f6 <ntohl>
  80325c:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  80325f:	83 c4 10             	add    $0x10,%esp
  803262:	84 c0                	test   %al,%al
  803264:	79 1c                	jns    803282 <dhcp_bind+0x14f>
    } else if (first_octet >= 192) {
  803266:	3c bf                	cmp    $0xbf,%al
  803268:	76 30                	jbe    80329a <dhcp_bind+0x167>
      sn_mask.addr = htonl(0xffffff00);
  80326a:	83 ec 0c             	sub    $0xc,%esp
  80326d:	68 00 ff ff ff       	push   $0xffffff00
  803272:	e8 68 44 00 00       	call   8076df <htonl>
  803277:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80327a:	83 c4 10             	add    $0x10,%esp
  80327d:	e9 40 ff ff ff       	jmp    8031c2 <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xff000000);
  803282:	83 ec 0c             	sub    $0xc,%esp
  803285:	68 00 00 00 ff       	push   $0xff000000
  80328a:	e8 50 44 00 00       	call   8076df <htonl>
  80328f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803292:	83 c4 10             	add    $0x10,%esp
  803295:	e9 28 ff ff ff       	jmp    8031c2 <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xffff0000);
  80329a:	83 ec 0c             	sub    $0xc,%esp
  80329d:	68 00 00 ff ff       	push   $0xffff0000
  8032a2:	e8 38 44 00 00       	call   8076df <htonl>
  8032a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032aa:	83 c4 10             	add    $0x10,%esp
  8032ad:	e9 10 ff ff ff       	jmp    8031c2 <dhcp_bind+0x8f>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8032b2:	8b 43 30             	mov    0x30(%ebx),%eax
  8032b5:	23 45 f4             	and    -0xc(%ebp),%eax
  8032b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  8032bb:	83 ec 0c             	sub    $0xc,%esp
  8032be:	6a 01                	push   $0x1
  8032c0:	e8 1a 44 00 00       	call   8076df <htonl>
  8032c5:	09 45 f0             	or     %eax,-0x10(%ebp)
  8032c8:	83 c4 10             	add    $0x10,%esp
  8032cb:	e9 00 ff ff ff       	jmp    8031d0 <dhcp_bind+0x9d>
    dhcp->t2_timeout = (u16_t)timeout;
  8032d0:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  8032d6:	e9 d9 fe ff ff       	jmp    8031b4 <dhcp_bind+0x81>
    dhcp->t1_timeout = (u16_t)timeout;
  8032db:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  8032e1:	e9 9c fe ff ff       	jmp    803182 <dhcp_bind+0x4f>

008032e6 <dhcp_free_reply>:
{
  8032e6:	55                   	push   %ebp
  8032e7:	89 e5                	mov    %esp,%ebp
  8032e9:	53                   	push   %ebx
  8032ea:	83 ec 04             	sub    $0x4,%esp
  8032ed:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8032ef:	8b 40 10             	mov    0x10(%eax),%eax
  8032f2:	85 c0                	test   %eax,%eax
  8032f4:	74 13                	je     803309 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  8032f6:	83 ec 0c             	sub    $0xc,%esp
  8032f9:	50                   	push   %eax
  8032fa:	e8 fb 0b 00 00       	call   803efa <mem_free>
    dhcp->msg_in = NULL;
  8032ff:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803306:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  803309:	8b 43 14             	mov    0x14(%ebx),%eax
  80330c:	85 c0                	test   %eax,%eax
  80330e:	74 19                	je     803329 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  803310:	83 ec 0c             	sub    $0xc,%esp
  803313:	50                   	push   %eax
  803314:	e8 e1 0b 00 00       	call   803efa <mem_free>
    dhcp->options_in = NULL;
  803319:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803320:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  803326:	83 c4 10             	add    $0x10,%esp
}
  803329:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80332c:	c9                   	leave  
  80332d:	c3                   	ret    

0080332e <dhcp_recv>:
{
  80332e:	55                   	push   %ebp
  80332f:	89 e5                	mov    %esp,%ebp
  803331:	57                   	push   %edi
  803332:	56                   	push   %esi
  803333:	53                   	push   %ebx
  803334:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  803337:	8b 45 08             	mov    0x8(%ebp),%eax
  80333a:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80333d:	8b 45 10             	mov    0x10(%ebp),%eax
  803340:	8b 70 04             	mov    0x4(%eax),%esi
  803343:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  803346:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  803349:	80 3e 02             	cmpb   $0x2,(%esi)
  80334c:	75 26                	jne    803374 <dhcp_recv+0x46>
  80334e:	8b 45 08             	mov    0x8(%ebp),%eax
  803351:	83 c0 25             	add    $0x25,%eax
  803354:	8d 56 1c             	lea    0x1c(%esi),%edx
  803357:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80335a:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  80335e:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  803360:	39 c6                	cmp    %eax,%esi
  803362:	74 2a                	je     80338e <dhcp_recv+0x60>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803364:	0f b6 18             	movzbl (%eax),%ebx
  803367:	0f b6 0a             	movzbl (%edx),%ecx
  80336a:	83 c0 01             	add    $0x1,%eax
  80336d:	83 c2 01             	add    $0x1,%edx
  803370:	38 cb                	cmp    %cl,%bl
  803372:	74 ec                	je     803360 <dhcp_recv+0x32>
  pbuf_free(p);
  803374:	83 ec 0c             	sub    $0xc,%esp
  803377:	ff 75 10             	pushl  0x10(%ebp)
  80337a:	e8 64 14 00 00       	call   8047e3 <pbuf_free>
  dhcp->p = NULL;
  80337f:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  803386:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803389:	5b                   	pop    %ebx
  80338a:	5e                   	pop    %esi
  80338b:	5f                   	pop    %edi
  80338c:	5d                   	pop    %ebp
  80338d:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80338e:	83 ec 0c             	sub    $0xc,%esp
  803391:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803394:	ff 70 04             	pushl  0x4(%eax)
  803397:	e8 5a 45 00 00       	call   8078f6 <ntohl>
  80339c:	83 c4 10             	add    $0x10,%esp
  80339f:	3b 47 04             	cmp    0x4(%edi),%eax
  8033a2:	75 d0                	jne    803374 <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8033a4:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  8033a8:	0f 84 20 01 00 00    	je     8034ce <dhcp_recv+0x1a0>
  dhcp_free_reply(dhcp);
  8033ae:	89 f8                	mov    %edi,%eax
  8033b0:	e8 31 ff ff ff       	call   8032e6 <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8033b5:	8b 47 0c             	mov    0xc(%edi),%eax
  8033b8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8033bc:	66 3d f0 00          	cmp    $0xf0,%ax
  8033c0:	76 1e                	jbe    8033e0 <dhcp_recv+0xb2>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033c2:	66 2d f0 00          	sub    $0xf0,%ax
  8033c6:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8033ca:	83 ec 0c             	sub    $0xc,%esp
  8033cd:	0f b7 c0             	movzwl %ax,%eax
  8033d0:	50                   	push   %eax
  8033d1:	e8 13 0e 00 00       	call   8041e9 <mem_malloc>
  8033d6:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  8033d9:	83 c4 10             	add    $0x10,%esp
  8033dc:	85 c0                	test   %eax,%eax
  8033de:	74 94                	je     803374 <dhcp_recv+0x46>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033e0:	83 ec 0c             	sub    $0xc,%esp
  8033e3:	68 f0 00 00 00       	push   $0xf0
  8033e8:	e8 fc 0d 00 00       	call   8041e9 <mem_malloc>
  8033ed:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  8033f0:	83 c4 10             	add    $0x10,%esp
  8033f3:	85 c0                	test   %eax,%eax
  8033f5:	0f 84 ea 00 00 00    	je     8034e5 <dhcp_recv+0x1b7>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8033fb:	6a 00                	push   $0x0
  8033fd:	68 f0 00 00 00       	push   $0xf0
  803402:	50                   	push   %eax
  803403:	ff 77 0c             	pushl  0xc(%edi)
  803406:	e8 54 1b 00 00       	call   804f5f <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80340b:	83 c4 10             	add    $0x10,%esp
  80340e:	66 3d f0 00          	cmp    $0xf0,%ax
  803412:	0f 85 e7 00 00 00    	jne    8034ff <dhcp_recv+0x1d1>
  if (dhcp->options_in != NULL) {
  803418:	8b 47 14             	mov    0x14(%edi),%eax
  80341b:	85 c0                	test   %eax,%eax
  80341d:	74 20                	je     80343f <dhcp_recv+0x111>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80341f:	68 f0 00 00 00       	push   $0xf0
  803424:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  803428:	52                   	push   %edx
  803429:	50                   	push   %eax
  80342a:	ff 77 0c             	pushl  0xc(%edi)
  80342d:	e8 2d 1b 00 00       	call   804f5f <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803432:	83 c4 10             	add    $0x10,%esp
  803435:	66 3b 47 18          	cmp    0x18(%edi),%ax
  803439:	0f 85 d7 00 00 00    	jne    803516 <dhcp_recv+0x1e8>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80343f:	ba 35 00 00 00       	mov    $0x35,%edx
  803444:	89 f8                	mov    %edi,%eax
  803446:	e8 f9 f2 ff ff       	call   802744 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  80344b:	85 c0                	test   %eax,%eax
  80344d:	0f 84 21 ff ff ff    	je     803374 <dhcp_recv+0x46>
  return *ptr;
  803453:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  803457:	3c 05                	cmp    $0x5,%al
  803459:	0f 84 ce 00 00 00    	je     80352d <dhcp_recv+0x1ff>
  else if ((msg_type == DHCP_NAK) &&
  80345f:	3c 06                	cmp    $0x6,%al
  803461:	0f 84 6e 02 00 00    	je     8036d5 <dhcp_recv+0x3a7>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803467:	3c 02                	cmp    $0x2,%al
  803469:	0f 85 05 ff ff ff    	jne    803374 <dhcp_recv+0x46>
  80346f:	80 3f 06             	cmpb   $0x6,(%edi)
  803472:	0f 85 fc fe ff ff    	jne    803374 <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  803478:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  80347e:	8b 45 08             	mov    0x8(%ebp),%eax
  803481:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803484:	ba 36 00 00 00       	mov    $0x36,%edx
  803489:	89 d8                	mov    %ebx,%eax
  80348b:	e8 b4 f2 ff ff       	call   802744 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803490:	85 c0                	test   %eax,%eax
  803492:	0f 84 dc fe ff ff    	je     803374 <dhcp_recv+0x46>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803498:	83 c0 02             	add    $0x2,%eax
  80349b:	e8 b0 f3 ff ff       	call   802850 <dhcp_get_option_long>
  8034a0:	83 ec 0c             	sub    $0xc,%esp
  8034a3:	50                   	push   %eax
  8034a4:	e8 36 42 00 00       	call   8076df <htonl>
  8034a9:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8034ac:	8b 43 10             	mov    0x10(%ebx),%eax
  8034af:	83 c4 10             	add    $0x10,%esp
  8034b2:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8034b5:	0f 84 8e 02 00 00    	je     803749 <dhcp_recv+0x41b>
  8034bb:	8b 40 10             	mov    0x10(%eax),%eax
  8034be:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  8034c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8034c4:	e8 ba fa ff ff       	call   802f83 <dhcp_select>
  8034c9:	e9 a6 fe ff ff       	jmp    803374 <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8034ce:	83 ec 04             	sub    $0x4,%esp
  8034d1:	68 68 16 81 00       	push   $0x811668
  8034d6:	68 8a 04 00 00       	push   $0x48a
  8034db:	68 22 16 81 00       	push   $0x811622
  8034e0:	e8 8b b0 00 00       	call   80e570 <_panic>
    mem_free((void *)dhcp->options_in);
  8034e5:	83 ec 0c             	sub    $0xc,%esp
  8034e8:	ff 77 14             	pushl  0x14(%edi)
  8034eb:	e8 0a 0a 00 00       	call   803efa <mem_free>
    dhcp->options_in = NULL;
  8034f0:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
  8034f7:	83 c4 10             	add    $0x10,%esp
  8034fa:	e9 75 fe ff ff       	jmp    803374 <dhcp_recv+0x46>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034ff:	83 ec 04             	sub    $0x4,%esp
  803502:	68 f0 15 81 00       	push   $0x8115f0
  803507:	68 a0 04 00 00       	push   $0x4a0
  80350c:	68 22 16 81 00       	push   $0x811622
  803511:	e8 5a b0 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803516:	83 ec 04             	sub    $0x4,%esp
  803519:	68 78 16 81 00       	push   $0x811678
  80351e:	68 a7 04 00 00       	push   $0x4a7
  803523:	68 22 16 81 00       	push   $0x811622
  803528:	e8 43 b0 00 00       	call   80e570 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  80352d:	0f b6 07             	movzbl (%edi),%eax
  803530:	3c 01                	cmp    $0x1,%al
  803532:	74 1e                	je     803552 <dhcp_recv+0x224>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803534:	83 e8 03             	sub    $0x3,%eax
  803537:	3c 02                	cmp    $0x2,%al
  803539:	0f 87 35 fe ff ff    	ja     803374 <dhcp_recv+0x46>
      dhcp->request_timeout = 0;
  80353f:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  803545:	8b 45 08             	mov    0x8(%ebp),%eax
  803548:	e8 e6 fb ff ff       	call   803133 <dhcp_bind>
  80354d:	e9 22 fe ff ff       	jmp    803374 <dhcp_recv+0x46>
  struct dhcp *dhcp = netif->dhcp;
  803552:	8b 45 08             	mov    0x8(%ebp),%eax
  803555:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  803558:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  80355f:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  803566:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  80356d:	ba 33 00 00 00       	mov    $0x33,%edx
  803572:	89 f0                	mov    %esi,%eax
  803574:	e8 cb f1 ff ff       	call   802744 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803579:	85 c0                	test   %eax,%eax
  80357b:	74 0b                	je     803588 <dhcp_recv+0x25a>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80357d:	83 c0 02             	add    $0x2,%eax
  803580:	e8 cb f2 ff ff       	call   802850 <dhcp_get_option_long>
  803585:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803588:	ba 3a 00 00 00       	mov    $0x3a,%edx
  80358d:	89 f0                	mov    %esi,%eax
  80358f:	e8 b0 f1 ff ff       	call   802744 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803594:	85 c0                	test   %eax,%eax
  803596:	0f 84 e7 00 00 00    	je     803683 <dhcp_recv+0x355>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80359c:	83 c0 02             	add    $0x2,%eax
  80359f:	e8 ac f2 ff ff       	call   802850 <dhcp_get_option_long>
  8035a4:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8035a7:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8035ac:	89 f0                	mov    %esi,%eax
  8035ae:	e8 91 f1 ff ff       	call   802744 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035b3:	85 c0                	test   %eax,%eax
  8035b5:	0f 84 d2 00 00 00    	je     80368d <dhcp_recv+0x35f>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8035bb:	83 c0 02             	add    $0x2,%eax
  8035be:	e8 8d f2 ff ff       	call   802850 <dhcp_get_option_long>
  8035c3:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8035c6:	8b 56 10             	mov    0x10(%esi),%edx
  8035c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8035ce:	83 fa f0             	cmp    $0xfffffff0,%edx
  8035d1:	74 03                	je     8035d6 <dhcp_recv+0x2a8>
  8035d3:	8b 42 10             	mov    0x10(%edx),%eax
  8035d6:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8035d9:	ba 01 00 00 00       	mov    $0x1,%edx
  8035de:	89 f0                	mov    %esi,%eax
  8035e0:	e8 5f f1 ff ff       	call   802744 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035e5:	85 c0                	test   %eax,%eax
  8035e7:	74 17                	je     803600 <dhcp_recv+0x2d2>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035e9:	83 c0 02             	add    $0x2,%eax
  8035ec:	e8 5f f2 ff ff       	call   802850 <dhcp_get_option_long>
  8035f1:	83 ec 0c             	sub    $0xc,%esp
  8035f4:	50                   	push   %eax
  8035f5:	e8 e5 40 00 00       	call   8076df <htonl>
  8035fa:	89 46 34             	mov    %eax,0x34(%esi)
  8035fd:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803600:	ba 03 00 00 00       	mov    $0x3,%edx
  803605:	89 f0                	mov    %esi,%eax
  803607:	e8 38 f1 ff ff       	call   802744 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80360c:	85 c0                	test   %eax,%eax
  80360e:	74 17                	je     803627 <dhcp_recv+0x2f9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803610:	83 c0 02             	add    $0x2,%eax
  803613:	e8 38 f2 ff ff       	call   802850 <dhcp_get_option_long>
  803618:	83 ec 0c             	sub    $0xc,%esp
  80361b:	50                   	push   %eax
  80361c:	e8 be 40 00 00       	call   8076df <htonl>
  803621:	89 46 38             	mov    %eax,0x38(%esi)
  803624:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803627:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80362c:	89 f0                	mov    %esi,%eax
  80362e:	e8 11 f1 ff ff       	call   802744 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803633:	85 c0                	test   %eax,%eax
  803635:	74 17                	je     80364e <dhcp_recv+0x320>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803637:	83 c0 02             	add    $0x2,%eax
  80363a:	e8 11 f2 ff ff       	call   802850 <dhcp_get_option_long>
  80363f:	83 ec 0c             	sub    $0xc,%esp
  803642:	50                   	push   %eax
  803643:	e8 97 40 00 00       	call   8076df <htonl>
  803648:	89 46 3c             	mov    %eax,0x3c(%esi)
  80364b:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  80364e:	ba 06 00 00 00       	mov    $0x6,%edx
  803653:	89 f0                	mov    %esi,%eax
  803655:	e8 ea f0 ff ff       	call   802744 <dhcp_get_option_ptr>
  80365a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  80365d:	85 c0                	test   %eax,%eax
  80365f:	74 61                	je     8036c2 <dhcp_recv+0x394>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803661:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803665:	c0 e8 02             	shr    $0x2,%al
  803668:	0f b6 c0             	movzbl %al,%eax
  80366b:	83 f8 02             	cmp    $0x2,%eax
  80366e:	ba 02 00 00 00       	mov    $0x2,%edx
  803673:	0f 47 c2             	cmova  %edx,%eax
  803676:	89 46 40             	mov    %eax,0x40(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803679:	bb 00 00 00 00       	mov    $0x0,%ebx
  80367e:	89 7d e0             	mov    %edi,-0x20(%ebp)
  803681:	eb 34                	jmp    8036b7 <dhcp_recv+0x389>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803683:	8b 46 4c             	mov    0x4c(%esi),%eax
  803686:	d1 e8                	shr    %eax
  803688:	e9 17 ff ff ff       	jmp    8035a4 <dhcp_recv+0x276>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  80368d:	8b 46 4c             	mov    0x4c(%esi),%eax
  803690:	e9 2e ff ff ff       	jmp    8035c3 <dhcp_recv+0x295>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803695:	0f b6 fb             	movzbl %bl,%edi
  803698:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80369b:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  80369f:	e8 ac f1 ff ff       	call   802850 <dhcp_get_option_long>
  8036a4:	83 ec 0c             	sub    $0xc,%esp
  8036a7:	50                   	push   %eax
  8036a8:	e8 32 40 00 00       	call   8076df <htonl>
  8036ad:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  8036b1:	83 c3 01             	add    $0x1,%ebx
  8036b4:	83 c4 10             	add    $0x10,%esp
  8036b7:	0f b6 c3             	movzbl %bl,%eax
  8036ba:	3b 46 40             	cmp    0x40(%esi),%eax
  8036bd:	72 d6                	jb     803695 <dhcp_recv+0x367>
  8036bf:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  8036c2:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  8036c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8036cb:	e8 2f fa ff ff       	call   8030ff <dhcp_check>
  8036d0:	e9 9f fc ff ff       	jmp    803374 <dhcp_recv+0x46>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8036d5:	0f b6 07             	movzbl (%edi),%eax
  8036d8:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8036db:	80 fa 02             	cmp    $0x2,%dl
  8036de:	76 08                	jbe    8036e8 <dhcp_recv+0x3ba>
  8036e0:	3c 01                	cmp    $0x1,%al
  8036e2:	0f 85 8c fc ff ff    	jne    803374 <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  8036e8:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  8036ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8036f1:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  8036f4:	83 ec 0c             	sub    $0xc,%esp
  8036f7:	50                   	push   %eax
  8036f8:	e8 f4 0f 00 00       	call   8046f1 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8036fd:	83 c4 08             	add    $0x8,%esp
  803700:	68 c8 1e 81 00       	push   $0x811ec8
  803705:	ff 75 08             	pushl  0x8(%ebp)
  803708:	e8 46 0e 00 00       	call   804553 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  80370d:	83 c4 08             	add    $0x8,%esp
  803710:	68 c8 1e 81 00       	push   $0x811ec8
  803715:	ff 75 08             	pushl  0x8(%ebp)
  803718:	e8 62 0f 00 00       	call   80467f <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  80371d:	83 c4 08             	add    $0x8,%esp
  803720:	68 c8 1e 81 00       	push   $0x811ec8
  803725:	ff 75 08             	pushl  0x8(%ebp)
  803728:	e8 6b 0f 00 00       	call   804698 <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80372d:	ba 0c 00 00 00       	mov    $0xc,%edx
  803732:	89 d8                	mov    %ebx,%eax
  803734:	e8 00 f0 ff ff       	call   802739 <dhcp_set_state>
  dhcp_discover(netif);
  803739:	8b 45 08             	mov    0x8(%ebp),%eax
  80373c:	e8 03 f7 ff ff       	call   802e44 <dhcp_discover>
  803741:	83 c4 10             	add    $0x10,%esp
  803744:	e9 2b fc ff ff       	jmp    803374 <dhcp_recv+0x46>
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803749:	b8 00 00 00 00       	mov    $0x0,%eax
  80374e:	e9 6b fd ff ff       	jmp    8034be <dhcp_recv+0x190>

00803753 <dhcp_inform>:
{
  803753:	55                   	push   %ebp
  803754:	89 e5                	mov    %esp,%ebp
  803756:	57                   	push   %edi
  803757:	56                   	push   %esi
  803758:	53                   	push   %ebx
  803759:	83 ec 18             	sub    $0x18,%esp
  80375c:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  80375f:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  803762:	6a 58                	push   $0x58
  803764:	e8 80 0a 00 00       	call   8041e9 <mem_malloc>
  if (dhcp == NULL) {
  803769:	83 c4 10             	add    $0x10,%esp
  80376c:	85 c0                	test   %eax,%eax
  80376e:	74 55                	je     8037c5 <dhcp_inform+0x72>
  803770:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  803772:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803775:	83 ec 04             	sub    $0x4,%esp
  803778:	6a 58                	push   $0x58
  80377a:	6a 00                	push   $0x0
  80377c:	50                   	push   %eax
  80377d:	e8 eb b5 00 00       	call   80ed6d <memset>
  dhcp->pcb = udp_new();
  803782:	e8 38 58 00 00       	call   808fbf <udp_new>
  803787:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  80378a:	83 c4 10             	add    $0x10,%esp
  80378d:	85 c0                	test   %eax,%eax
  80378f:	74 3c                	je     8037cd <dhcp_inform+0x7a>
  result = dhcp_create_request(netif);
  803791:	89 f0                	mov    %esi,%eax
  803793:	e8 2c f3 ff ff       	call   802ac4 <dhcp_create_request>
  if (result == ERR_OK) {
  803798:	84 c0                	test   %al,%al
  80379a:	74 3f                	je     8037db <dhcp_inform+0x88>
    if (dhcp->pcb != NULL) {
  80379c:	8b 43 08             	mov    0x8(%ebx),%eax
  80379f:	85 c0                	test   %eax,%eax
  8037a1:	74 0c                	je     8037af <dhcp_inform+0x5c>
      udp_remove(dhcp->pcb);
  8037a3:	83 ec 0c             	sub    $0xc,%esp
  8037a6:	50                   	push   %eax
  8037a7:	e8 cf 57 00 00       	call   808f7b <udp_remove>
  8037ac:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  8037af:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8037b6:	83 ec 0c             	sub    $0xc,%esp
  8037b9:	53                   	push   %ebx
  8037ba:	e8 3b 07 00 00       	call   803efa <mem_free>
    netif->dhcp = old_dhcp;
  8037bf:	89 7e 20             	mov    %edi,0x20(%esi)
  8037c2:	83 c4 10             	add    $0x10,%esp
}
  8037c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8037c8:	5b                   	pop    %ebx
  8037c9:	5e                   	pop    %esi
  8037ca:	5f                   	pop    %edi
  8037cb:	5d                   	pop    %ebp
  8037cc:	c3                   	ret    
    mem_free((void *)dhcp);
  8037cd:	83 ec 0c             	sub    $0xc,%esp
  8037d0:	53                   	push   %ebx
  8037d1:	e8 24 07 00 00       	call   803efa <mem_free>
    return;
  8037d6:	83 c4 10             	add    $0x10,%esp
  8037d9:	eb ea                	jmp    8037c5 <dhcp_inform+0x72>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8037db:	b9 01 00 00 00       	mov    $0x1,%ecx
  8037e0:	ba 35 00 00 00       	mov    $0x35,%edx
  8037e5:	89 d8                	mov    %ebx,%eax
  8037e7:	e8 c6 f0 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  8037ec:	ba 08 00 00 00       	mov    $0x8,%edx
  8037f1:	89 d8                	mov    %ebx,%eax
  8037f3:	e8 79 f0 ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8037f8:	b9 02 00 00 00       	mov    $0x2,%ecx
  8037fd:	ba 39 00 00 00       	mov    $0x39,%edx
  803802:	89 d8                	mov    %ebx,%eax
  803804:	e8 a9 f0 ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803809:	ba 40 02 00 00       	mov    $0x240,%edx
  80380e:	89 d8                	mov    %ebx,%eax
  803810:	e8 04 f1 ff ff       	call   802919 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803815:	89 d8                	mov    %ebx,%eax
  803817:	e8 5b f1 ff ff       	call   802977 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80381c:	83 ec 08             	sub    $0x8,%esp
  80381f:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803823:	66 05 f0 00          	add    $0xf0,%ax
  803827:	0f b7 c0             	movzwl %ax,%eax
  80382a:	50                   	push   %eax
  80382b:	ff 73 1c             	pushl  0x1c(%ebx)
  80382e:	e8 e8 12 00 00       	call   804b1b <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803833:	83 c4 0c             	add    $0xc,%esp
  803836:	6a 44                	push   $0x44
  803838:	68 c8 1e 81 00       	push   $0x811ec8
  80383d:	ff 73 08             	pushl  0x8(%ebx)
  803840:	e8 e6 53 00 00       	call   808c2b <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803845:	83 c4 0c             	add    $0xc,%esp
  803848:	6a 43                	push   $0x43
  80384a:	68 c4 1e 81 00       	push   $0x811ec4
  80384f:	ff 73 08             	pushl  0x8(%ebx)
  803852:	e8 84 56 00 00       	call   808edb <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803857:	89 34 24             	mov    %esi,(%esp)
  80385a:	6a 43                	push   $0x43
  80385c:	68 c4 1e 81 00       	push   $0x811ec4
  803861:	ff 73 1c             	pushl  0x1c(%ebx)
  803864:	ff 73 08             	pushl  0x8(%ebx)
  803867:	e8 7a 54 00 00       	call   808ce6 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80386c:	83 c4 1c             	add    $0x1c,%esp
  80386f:	6a 43                	push   $0x43
  803871:	68 c8 1e 81 00       	push   $0x811ec8
  803876:	ff 73 08             	pushl  0x8(%ebx)
  803879:	e8 5d 56 00 00       	call   808edb <udp_connect>
    dhcp_delete_request(netif);
  80387e:	89 f0                	mov    %esi,%eax
  803880:	e8 32 f4 ff ff       	call   802cb7 <dhcp_delete_request>
  803885:	83 c4 10             	add    $0x10,%esp
  803888:	e9 0f ff ff ff       	jmp    80379c <dhcp_inform+0x49>

0080388d <dhcp_arp_reply>:
{
  80388d:	55                   	push   %ebp
  80388e:	89 e5                	mov    %esp,%ebp
  803890:	56                   	push   %esi
  803891:	53                   	push   %ebx
  803892:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803895:	85 f6                	test   %esi,%esi
  803897:	74 13                	je     8038ac <dhcp_arp_reply+0x1f>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803899:	8b 5e 20             	mov    0x20(%esi),%ebx
  80389c:	85 db                	test   %ebx,%ebx
  80389e:	74 05                	je     8038a5 <dhcp_arp_reply+0x18>
  8038a0:	80 3b 08             	cmpb   $0x8,(%ebx)
  8038a3:	74 1e                	je     8038c3 <dhcp_arp_reply+0x36>
}
  8038a5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8038a8:	5b                   	pop    %ebx
  8038a9:	5e                   	pop    %esi
  8038aa:	5d                   	pop    %ebp
  8038ab:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8038ac:	83 ec 04             	sub    $0x4,%esp
  8038af:	68 42 16 81 00       	push   $0x811642
  8038b4:	68 b5 02 00 00       	push   $0x2b5
  8038b9:	68 22 16 81 00       	push   $0x811622
  8038be:	e8 ad ac 00 00       	call   80e570 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  8038c3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8038c6:	8b 4b 30             	mov    0x30(%ebx),%ecx
  8038c9:	39 08                	cmp    %ecx,(%eax)
  8038cb:	75 d8                	jne    8038a5 <dhcp_arp_reply+0x18>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8038cd:	ba 0c 00 00 00       	mov    $0xc,%edx
  8038d2:	89 d8                	mov    %ebx,%eax
  8038d4:	e8 60 ee ff ff       	call   802739 <dhcp_set_state>
  result = dhcp_create_request(netif);
  8038d9:	89 f0                	mov    %esi,%eax
  8038db:	e8 e4 f1 ff ff       	call   802ac4 <dhcp_create_request>
  if (result == ERR_OK) {
  8038e0:	84 c0                	test   %al,%al
  8038e2:	74 0c                	je     8038f0 <dhcp_arp_reply+0x63>
  dhcp->tries++;
  8038e4:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8038e8:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  8038ee:	eb b5                	jmp    8038a5 <dhcp_arp_reply+0x18>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8038f0:	b9 01 00 00 00       	mov    $0x1,%ecx
  8038f5:	ba 35 00 00 00       	mov    $0x35,%edx
  8038fa:	89 d8                	mov    %ebx,%eax
  8038fc:	e8 b1 ef ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803901:	ba 04 00 00 00       	mov    $0x4,%edx
  803906:	89 d8                	mov    %ebx,%eax
  803908:	e8 64 ef ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80390d:	b9 02 00 00 00       	mov    $0x2,%ecx
  803912:	ba 39 00 00 00       	mov    $0x39,%edx
  803917:	89 d8                	mov    %ebx,%eax
  803919:	e8 94 ef ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80391e:	ba 40 02 00 00       	mov    $0x240,%edx
  803923:	89 d8                	mov    %ebx,%eax
  803925:	e8 ef ef ff ff       	call   802919 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80392a:	b9 04 00 00 00       	mov    $0x4,%ecx
  80392f:	ba 32 00 00 00       	mov    $0x32,%edx
  803934:	89 d8                	mov    %ebx,%eax
  803936:	e8 77 ef ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80393b:	83 ec 0c             	sub    $0xc,%esp
  80393e:	ff 73 30             	pushl  0x30(%ebx)
  803941:	e8 b0 3f 00 00       	call   8078f6 <ntohl>
  803946:	89 c2                	mov    %eax,%edx
  803948:	89 d8                	mov    %ebx,%eax
  80394a:	e8 dd f0 ff ff       	call   802a2c <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  80394f:	89 d8                	mov    %ebx,%eax
  803951:	e8 21 f0 ff ff       	call   802977 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803956:	83 c4 08             	add    $0x8,%esp
  803959:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80395d:	66 05 f0 00          	add    $0xf0,%ax
  803961:	0f b7 c0             	movzwl %ax,%eax
  803964:	50                   	push   %eax
  803965:	ff 73 1c             	pushl  0x1c(%ebx)
  803968:	e8 ae 11 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80396d:	83 c4 0c             	add    $0xc,%esp
  803970:	6a 43                	push   $0x43
  803972:	68 c8 1e 81 00       	push   $0x811ec8
  803977:	ff 73 08             	pushl  0x8(%ebx)
  80397a:	e8 5c 55 00 00       	call   808edb <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80397f:	89 34 24             	mov    %esi,(%esp)
  803982:	6a 43                	push   $0x43
  803984:	68 c4 1e 81 00       	push   $0x811ec4
  803989:	ff 73 1c             	pushl  0x1c(%ebx)
  80398c:	ff 73 08             	pushl  0x8(%ebx)
  80398f:	e8 52 53 00 00       	call   808ce6 <udp_sendto_if>
    dhcp_delete_request(netif);
  803994:	83 c4 20             	add    $0x20,%esp
  803997:	89 f0                	mov    %esi,%eax
  803999:	e8 19 f3 ff ff       	call   802cb7 <dhcp_delete_request>
  80399e:	e9 41 ff ff ff       	jmp    8038e4 <dhcp_arp_reply+0x57>

008039a3 <dhcp_renew>:
{
  8039a3:	55                   	push   %ebp
  8039a4:	89 e5                	mov    %esp,%ebp
  8039a6:	57                   	push   %edi
  8039a7:	56                   	push   %esi
  8039a8:	53                   	push   %ebx
  8039a9:	83 ec 1c             	sub    $0x1c,%esp
  8039ac:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8039af:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  8039b2:	ba 05 00 00 00       	mov    $0x5,%edx
  8039b7:	89 d8                	mov    %ebx,%eax
  8039b9:	e8 7b ed ff ff       	call   802739 <dhcp_set_state>
  result = dhcp_create_request(netif);
  8039be:	89 f0                	mov    %esi,%eax
  8039c0:	e8 ff f0 ff ff       	call   802ac4 <dhcp_create_request>
  8039c5:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  8039c7:	84 c0                	test   %al,%al
  8039c9:	74 3e                	je     803a09 <dhcp_renew+0x66>
  dhcp->tries++;
  8039cb:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8039cf:	83 c0 01             	add    $0x1,%eax
  8039d2:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  8039d5:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  8039da:	3c 09                	cmp    $0x9,%al
  8039dc:	77 08                	ja     8039e6 <dhcp_renew+0x43>
  8039de:	0f b6 d0             	movzbl %al,%edx
  8039e1:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8039e6:	0f b7 d2             	movzwl %dx,%edx
  8039e9:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8039ef:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8039f4:	89 d0                	mov    %edx,%eax
  8039f6:	f7 e9                	imul   %ecx
  8039f8:	c1 fa 05             	sar    $0x5,%edx
  8039fb:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  8039ff:	89 f8                	mov    %edi,%eax
  803a01:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803a04:	5b                   	pop    %ebx
  803a05:	5e                   	pop    %esi
  803a06:	5f                   	pop    %edi
  803a07:	5d                   	pop    %ebp
  803a08:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803a09:	b9 01 00 00 00       	mov    $0x1,%ecx
  803a0e:	ba 35 00 00 00       	mov    $0x35,%edx
  803a13:	89 d8                	mov    %ebx,%eax
  803a15:	e8 98 ee ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803a1a:	ba 03 00 00 00       	mov    $0x3,%edx
  803a1f:	89 d8                	mov    %ebx,%eax
  803a21:	e8 4b ee ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a26:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a2b:	ba 39 00 00 00       	mov    $0x39,%edx
  803a30:	89 d8                	mov    %ebx,%eax
  803a32:	e8 7b ee ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803a37:	ba 40 02 00 00       	mov    $0x240,%edx
  803a3c:	89 d8                	mov    %ebx,%eax
  803a3e:	e8 d6 ee ff ff       	call   802919 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803a43:	89 d8                	mov    %ebx,%eax
  803a45:	e8 2d ef ff ff       	call   802977 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a4a:	83 ec 08             	sub    $0x8,%esp
  803a4d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a51:	66 05 f0 00          	add    $0xf0,%ax
  803a55:	0f b7 c0             	movzwl %ax,%eax
  803a58:	50                   	push   %eax
  803a59:	ff 73 1c             	pushl  0x1c(%ebx)
  803a5c:	e8 ba 10 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803a61:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803a64:	83 c4 0c             	add    $0xc,%esp
  803a67:	6a 43                	push   $0x43
  803a69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803a6c:	50                   	push   %eax
  803a6d:	ff 73 08             	pushl  0x8(%ebx)
  803a70:	e8 66 54 00 00       	call   808edb <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803a75:	89 34 24             	mov    %esi,(%esp)
  803a78:	6a 43                	push   $0x43
  803a7a:	ff 75 e4             	pushl  -0x1c(%ebp)
  803a7d:	ff 73 1c             	pushl  0x1c(%ebx)
  803a80:	ff 73 08             	pushl  0x8(%ebx)
  803a83:	e8 5e 52 00 00       	call   808ce6 <udp_sendto_if>
    dhcp_delete_request(netif);
  803a88:	83 c4 20             	add    $0x20,%esp
  803a8b:	89 f0                	mov    %esi,%eax
  803a8d:	e8 25 f2 ff ff       	call   802cb7 <dhcp_delete_request>
  803a92:	e9 34 ff ff ff       	jmp    8039cb <dhcp_renew+0x28>

00803a97 <dhcp_coarse_tmr>:
{
  803a97:	55                   	push   %ebp
  803a98:	89 e5                	mov    %esp,%ebp
  803a9a:	53                   	push   %ebx
  803a9b:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803a9e:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803aa4:	eb 1d                	jmp    803ac3 <dhcp_coarse_tmr+0x2c>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803aa6:	8b 43 20             	mov    0x20(%ebx),%eax
  803aa9:	0f b6 00             	movzbl (%eax),%eax
  803aac:	89 c2                	mov    %eax,%edx
  803aae:	83 e2 fb             	and    $0xfffffffb,%edx
  803ab1:	80 fa 01             	cmp    $0x1,%dl
  803ab4:	74 04                	je     803aba <dhcp_coarse_tmr+0x23>
  803ab6:	3c 0a                	cmp    $0xa,%al
  803ab8:	75 07                	jne    803ac1 <dhcp_coarse_tmr+0x2a>
    dhcp_rebind(netif);
  803aba:	89 d8                	mov    %ebx,%eax
  803abc:	e8 90 f2 ff ff       	call   802d51 <dhcp_rebind>
    netif = netif->next;
  803ac1:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803ac3:	85 db                	test   %ebx,%ebx
  803ac5:	74 4e                	je     803b15 <dhcp_coarse_tmr+0x7e>
    if (netif->dhcp != NULL) {
  803ac7:	8b 43 20             	mov    0x20(%ebx),%eax
  803aca:	85 c0                	test   %eax,%eax
  803acc:	74 f3                	je     803ac1 <dhcp_coarse_tmr+0x2a>
      if (netif->dhcp->t2_timeout-- == 1) {
  803ace:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803ad2:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803ad5:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803ad9:	66 83 fa 01          	cmp    $0x1,%dx
  803add:	74 c7                	je     803aa6 <dhcp_coarse_tmr+0xf>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803adf:	8b 53 20             	mov    0x20(%ebx),%edx
  803ae2:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803ae6:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803ae9:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803aed:	66 83 f8 01          	cmp    $0x1,%ax
  803af1:	75 ce                	jne    803ac1 <dhcp_coarse_tmr+0x2a>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803af3:	8b 43 20             	mov    0x20(%ebx),%eax
  803af6:	0f b6 00             	movzbl (%eax),%eax
  803af9:	89 c2                	mov    %eax,%edx
  803afb:	83 e2 fb             	and    $0xfffffffb,%edx
  803afe:	80 fa 01             	cmp    $0x1,%dl
  803b01:	74 04                	je     803b07 <dhcp_coarse_tmr+0x70>
  803b03:	3c 0a                	cmp    $0xa,%al
  803b05:	75 ba                	jne    803ac1 <dhcp_coarse_tmr+0x2a>
    dhcp_renew(netif);
  803b07:	83 ec 0c             	sub    $0xc,%esp
  803b0a:	53                   	push   %ebx
  803b0b:	e8 93 fe ff ff       	call   8039a3 <dhcp_renew>
  803b10:	83 c4 10             	add    $0x10,%esp
  803b13:	eb ac                	jmp    803ac1 <dhcp_coarse_tmr+0x2a>
}
  803b15:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803b18:	c9                   	leave  
  803b19:	c3                   	ret    

00803b1a <dhcp_release>:
{
  803b1a:	55                   	push   %ebp
  803b1b:	89 e5                	mov    %esp,%ebp
  803b1d:	57                   	push   %edi
  803b1e:	56                   	push   %esi
  803b1f:	53                   	push   %ebx
  803b20:	83 ec 1c             	sub    $0x1c,%esp
  803b23:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803b26:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803b29:	ba 0d 00 00 00       	mov    $0xd,%edx
  803b2e:	89 d8                	mov    %ebx,%eax
  803b30:	e8 04 ec ff ff       	call   802739 <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803b35:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803b3c:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803b43:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803b4a:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803b51:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803b58:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803b5f:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803b66:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803b6d:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803b74:	89 f0                	mov    %esi,%eax
  803b76:	e8 49 ef ff ff       	call   802ac4 <dhcp_create_request>
  803b7b:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803b7d:	84 c0                	test   %al,%al
  803b7f:	74 71                	je     803bf2 <dhcp_release+0xd8>
  dhcp->tries++;
  803b81:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803b85:	83 c0 01             	add    $0x1,%eax
  803b88:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803b8b:	ba 10 27 00 00       	mov    $0x2710,%edx
  803b90:	3c 09                	cmp    $0x9,%al
  803b92:	77 08                	ja     803b9c <dhcp_release+0x82>
  803b94:	0f b6 d0             	movzbl %al,%edx
  803b97:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803b9c:	0f b7 d2             	movzwl %dx,%edx
  803b9f:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803ba5:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803baa:	89 d0                	mov    %edx,%eax
  803bac:	f7 e9                	imul   %ecx
  803bae:	c1 fa 05             	sar    $0x5,%edx
  803bb1:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803bb5:	83 ec 0c             	sub    $0xc,%esp
  803bb8:	56                   	push   %esi
  803bb9:	e8 33 0b 00 00       	call   8046f1 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803bbe:	83 c4 08             	add    $0x8,%esp
  803bc1:	68 c8 1e 81 00       	push   $0x811ec8
  803bc6:	56                   	push   %esi
  803bc7:	e8 87 09 00 00       	call   804553 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803bcc:	83 c4 08             	add    $0x8,%esp
  803bcf:	68 c8 1e 81 00       	push   $0x811ec8
  803bd4:	56                   	push   %esi
  803bd5:	e8 a5 0a 00 00       	call   80467f <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803bda:	83 c4 08             	add    $0x8,%esp
  803bdd:	68 c8 1e 81 00       	push   $0x811ec8
  803be2:	56                   	push   %esi
  803be3:	e8 b0 0a 00 00       	call   804698 <netif_set_netmask>
}
  803be8:	89 f8                	mov    %edi,%eax
  803bea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803bed:	5b                   	pop    %ebx
  803bee:	5e                   	pop    %esi
  803bef:	5f                   	pop    %edi
  803bf0:	5d                   	pop    %ebp
  803bf1:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803bf2:	b9 01 00 00 00       	mov    $0x1,%ecx
  803bf7:	ba 35 00 00 00       	mov    $0x35,%edx
  803bfc:	89 d8                	mov    %ebx,%eax
  803bfe:	e8 af ec ff ff       	call   8028b2 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803c03:	ba 07 00 00 00       	mov    $0x7,%edx
  803c08:	89 d8                	mov    %ebx,%eax
  803c0a:	e8 62 ec ff ff       	call   802871 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803c0f:	89 d8                	mov    %ebx,%eax
  803c11:	e8 61 ed ff ff       	call   802977 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c16:	83 ec 08             	sub    $0x8,%esp
  803c19:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c1d:	66 05 f0 00          	add    $0xf0,%ax
  803c21:	0f b7 c0             	movzwl %ax,%eax
  803c24:	50                   	push   %eax
  803c25:	ff 73 1c             	pushl  0x1c(%ebx)
  803c28:	e8 ee 0e 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c2d:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c30:	83 c4 0c             	add    $0xc,%esp
  803c33:	6a 43                	push   $0x43
  803c35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c38:	50                   	push   %eax
  803c39:	ff 73 08             	pushl  0x8(%ebx)
  803c3c:	e8 9a 52 00 00       	call   808edb <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c41:	89 34 24             	mov    %esi,(%esp)
  803c44:	6a 43                	push   $0x43
  803c46:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c49:	ff 73 1c             	pushl  0x1c(%ebx)
  803c4c:	ff 73 08             	pushl  0x8(%ebx)
  803c4f:	e8 92 50 00 00       	call   808ce6 <udp_sendto_if>
    dhcp_delete_request(netif);
  803c54:	83 c4 20             	add    $0x20,%esp
  803c57:	89 f0                	mov    %esi,%eax
  803c59:	e8 59 f0 ff ff       	call   802cb7 <dhcp_delete_request>
  803c5e:	e9 1e ff ff ff       	jmp    803b81 <dhcp_release+0x67>

00803c63 <dhcp_fine_tmr>:
{
  803c63:	55                   	push   %ebp
  803c64:	89 e5                	mov    %esp,%ebp
  803c66:	53                   	push   %ebx
  803c67:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803c6a:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803c70:	eb 04                	jmp    803c76 <dhcp_fine_tmr+0x13>
      else if (netif->dhcp->request_timeout == 1) {
  803c72:	74 24                	je     803c98 <dhcp_fine_tmr+0x35>
    netif = netif->next;
  803c74:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803c76:	85 db                	test   %ebx,%ebx
  803c78:	0f 84 c4 00 00 00    	je     803d42 <dhcp_fine_tmr+0xdf>
    if (netif->dhcp != NULL) {
  803c7e:	8b 43 20             	mov    0x20(%ebx),%eax
  803c81:	85 c0                	test   %eax,%eax
  803c83:	74 ef                	je     803c74 <dhcp_fine_tmr+0x11>
      if (netif->dhcp->request_timeout > 1) {
  803c85:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803c89:	66 83 fa 01          	cmp    $0x1,%dx
  803c8d:	76 e3                	jbe    803c72 <dhcp_fine_tmr+0xf>
        netif->dhcp->request_timeout--;
  803c8f:	83 ea 01             	sub    $0x1,%edx
  803c92:	66 89 50 26          	mov    %dx,0x26(%eax)
  803c96:	eb dc                	jmp    803c74 <dhcp_fine_tmr+0x11>
        netif->dhcp->request_timeout--;
  803c98:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803c9e:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803ca1:	0f b6 02             	movzbl (%edx),%eax
  803ca4:	3c 0c                	cmp    $0xc,%al
  803ca6:	74 23                	je     803ccb <dhcp_fine_tmr+0x68>
  803ca8:	3c 06                	cmp    $0x6,%al
  803caa:	74 1f                	je     803ccb <dhcp_fine_tmr+0x68>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803cac:	3c 01                	cmp    $0x1,%al
  803cae:	74 24                	je     803cd4 <dhcp_fine_tmr+0x71>
  } else if (dhcp->state == DHCP_CHECKING) {
  803cb0:	3c 08                	cmp    $0x8,%al
  803cb2:	74 47                	je     803cfb <dhcp_fine_tmr+0x98>
  else if (dhcp->state == DHCP_RENEWING) {
  803cb4:	3c 05                	cmp    $0x5,%al
  803cb6:	74 61                	je     803d19 <dhcp_fine_tmr+0xb6>
  } else if (dhcp->state == DHCP_REBINDING) {
  803cb8:	3c 04                	cmp    $0x4,%al
  803cba:	75 b8                	jne    803c74 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 8) {
  803cbc:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803cc0:	77 68                	ja     803d2a <dhcp_fine_tmr+0xc7>
      dhcp_rebind(netif);
  803cc2:	89 d8                	mov    %ebx,%eax
  803cc4:	e8 88 f0 ff ff       	call   802d51 <dhcp_rebind>
  803cc9:	eb a9                	jmp    803c74 <dhcp_fine_tmr+0x11>
    dhcp_discover(netif);
  803ccb:	89 d8                	mov    %ebx,%eax
  803ccd:	e8 72 f1 ff ff       	call   802e44 <dhcp_discover>
  803cd2:	eb a0                	jmp    803c74 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 5) {
  803cd4:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803cd8:	77 09                	ja     803ce3 <dhcp_fine_tmr+0x80>
      dhcp_select(netif);
  803cda:	89 d8                	mov    %ebx,%eax
  803cdc:	e8 a2 f2 ff ff       	call   802f83 <dhcp_select>
  803ce1:	eb 91                	jmp    803c74 <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803ce3:	83 ec 0c             	sub    $0xc,%esp
  803ce6:	53                   	push   %ebx
  803ce7:	e8 2e fe ff ff       	call   803b1a <dhcp_release>
      dhcp_discover(netif);
  803cec:	89 d8                	mov    %ebx,%eax
  803cee:	e8 51 f1 ff ff       	call   802e44 <dhcp_discover>
  803cf3:	83 c4 10             	add    $0x10,%esp
  803cf6:	e9 79 ff ff ff       	jmp    803c74 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 1) {
  803cfb:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803cff:	76 0c                	jbe    803d0d <dhcp_fine_tmr+0xaa>
      dhcp_bind(netif);
  803d01:	89 d8                	mov    %ebx,%eax
  803d03:	e8 2b f4 ff ff       	call   803133 <dhcp_bind>
  803d08:	e9 67 ff ff ff       	jmp    803c74 <dhcp_fine_tmr+0x11>
      dhcp_check(netif);
  803d0d:	89 d8                	mov    %ebx,%eax
  803d0f:	e8 eb f3 ff ff       	call   8030ff <dhcp_check>
  803d14:	e9 5b ff ff ff       	jmp    803c74 <dhcp_fine_tmr+0x11>
    dhcp_renew(netif);
  803d19:	83 ec 0c             	sub    $0xc,%esp
  803d1c:	53                   	push   %ebx
  803d1d:	e8 81 fc ff ff       	call   8039a3 <dhcp_renew>
  803d22:	83 c4 10             	add    $0x10,%esp
  803d25:	e9 4a ff ff ff       	jmp    803c74 <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803d2a:	83 ec 0c             	sub    $0xc,%esp
  803d2d:	53                   	push   %ebx
  803d2e:	e8 e7 fd ff ff       	call   803b1a <dhcp_release>
      dhcp_discover(netif);
  803d33:	89 d8                	mov    %ebx,%eax
  803d35:	e8 0a f1 ff ff       	call   802e44 <dhcp_discover>
  803d3a:	83 c4 10             	add    $0x10,%esp
  803d3d:	e9 32 ff ff ff       	jmp    803c74 <dhcp_fine_tmr+0x11>
}
  803d42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803d45:	c9                   	leave  
  803d46:	c3                   	ret    

00803d47 <dhcp_stop>:
{
  803d47:	55                   	push   %ebp
  803d48:	89 e5                	mov    %esp,%ebp
  803d4a:	56                   	push   %esi
  803d4b:	53                   	push   %ebx
  803d4c:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803d4f:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803d52:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803d56:	85 db                	test   %ebx,%ebx
  803d58:	74 4e                	je     803da8 <dhcp_stop+0x61>
    if (dhcp->pcb != NULL) {
  803d5a:	8b 43 08             	mov    0x8(%ebx),%eax
  803d5d:	85 c0                	test   %eax,%eax
  803d5f:	74 13                	je     803d74 <dhcp_stop+0x2d>
      udp_remove(dhcp->pcb);
  803d61:	83 ec 0c             	sub    $0xc,%esp
  803d64:	50                   	push   %eax
  803d65:	e8 11 52 00 00       	call   808f7b <udp_remove>
      dhcp->pcb = NULL;
  803d6a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803d71:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803d74:	8b 43 0c             	mov    0xc(%ebx),%eax
  803d77:	85 c0                	test   %eax,%eax
  803d79:	74 13                	je     803d8e <dhcp_stop+0x47>
      pbuf_free(dhcp->p);
  803d7b:	83 ec 0c             	sub    $0xc,%esp
  803d7e:	50                   	push   %eax
  803d7f:	e8 5f 0a 00 00       	call   8047e3 <pbuf_free>
      dhcp->p = NULL;
  803d84:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803d8b:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803d8e:	89 d8                	mov    %ebx,%eax
  803d90:	e8 51 f5 ff ff       	call   8032e6 <dhcp_free_reply>
    mem_free((void *)dhcp);
  803d95:	83 ec 0c             	sub    $0xc,%esp
  803d98:	53                   	push   %ebx
  803d99:	e8 5c 01 00 00       	call   803efa <mem_free>
    netif->dhcp = NULL;
  803d9e:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803da5:	83 c4 10             	add    $0x10,%esp
}
  803da8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803dab:	5b                   	pop    %ebx
  803dac:	5e                   	pop    %esi
  803dad:	5d                   	pop    %ebp
  803dae:	c3                   	ret    

00803daf <dhcp_start>:
{
  803daf:	55                   	push   %ebp
  803db0:	89 e5                	mov    %esp,%ebp
  803db2:	56                   	push   %esi
  803db3:	53                   	push   %ebx
  803db4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803db7:	85 db                	test   %ebx,%ebx
  803db9:	74 73                	je     803e2e <dhcp_start+0x7f>
  dhcp = netif->dhcp;
  803dbb:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803dbe:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803dc2:	85 f6                	test   %esi,%esi
  803dc4:	74 7f                	je     803e45 <dhcp_start+0x96>
  memset(dhcp, 0, sizeof(struct dhcp));
  803dc6:	83 ec 04             	sub    $0x4,%esp
  803dc9:	6a 58                	push   $0x58
  803dcb:	6a 00                	push   $0x0
  803dcd:	56                   	push   %esi
  803dce:	e8 9a af 00 00       	call   80ed6d <memset>
  dhcp->pcb = udp_new();
  803dd3:	e8 e7 51 00 00       	call   808fbf <udp_new>
  803dd8:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803ddb:	83 c4 10             	add    $0x10,%esp
  803dde:	85 c0                	test   %eax,%eax
  803de0:	74 7e                	je     803e60 <dhcp_start+0xb1>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803de2:	83 ec 04             	sub    $0x4,%esp
  803de5:	6a 44                	push   $0x44
  803de7:	68 c8 1e 81 00       	push   $0x811ec8
  803dec:	50                   	push   %eax
  803ded:	e8 39 4e 00 00       	call   808c2b <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803df2:	83 c4 0c             	add    $0xc,%esp
  803df5:	6a 43                	push   $0x43
  803df7:	68 c8 1e 81 00       	push   $0x811ec8
  803dfc:	ff 76 08             	pushl  0x8(%esi)
  803dff:	e8 d7 50 00 00       	call   808edb <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803e04:	83 c4 0c             	add    $0xc,%esp
  803e07:	53                   	push   %ebx
  803e08:	68 2e 33 80 00       	push   $0x80332e
  803e0d:	ff 76 08             	pushl  0x8(%esi)
  803e10:	e8 52 51 00 00       	call   808f67 <udp_recv>
  result = dhcp_discover(netif);
  803e15:	89 d8                	mov    %ebx,%eax
  803e17:	e8 28 f0 ff ff       	call   802e44 <dhcp_discover>
  if (result != ERR_OK) {
  803e1c:	83 c4 10             	add    $0x10,%esp
  803e1f:	84 c0                	test   %al,%al
  803e21:	75 57                	jne    803e7a <dhcp_start+0xcb>
  netif->flags |= NETIF_FLAG_DHCP;
  803e23:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  803e27:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e2a:	5b                   	pop    %ebx
  803e2b:	5e                   	pop    %esi
  803e2c:	5d                   	pop    %ebp
  803e2d:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e2e:	83 ec 04             	sub    $0x4,%esp
  803e31:	68 42 16 81 00       	push   $0x811642
  803e36:	68 38 02 00 00       	push   $0x238
  803e3b:	68 22 16 81 00       	push   $0x811622
  803e40:	e8 2b a7 00 00       	call   80e570 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  803e45:	83 ec 0c             	sub    $0xc,%esp
  803e48:	6a 58                	push   $0x58
  803e4a:	e8 9a 03 00 00       	call   8041e9 <mem_malloc>
  803e4f:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803e51:	83 c4 10             	add    $0x10,%esp
  803e54:	85 c0                	test   %eax,%eax
  803e56:	74 35                	je     803e8d <dhcp_start+0xde>
    netif->dhcp = dhcp;
  803e58:	89 43 20             	mov    %eax,0x20(%ebx)
  803e5b:	e9 66 ff ff ff       	jmp    803dc6 <dhcp_start+0x17>
    mem_free((void *)dhcp);
  803e60:	83 ec 0c             	sub    $0xc,%esp
  803e63:	56                   	push   %esi
  803e64:	e8 91 00 00 00       	call   803efa <mem_free>
    netif->dhcp = dhcp = NULL;
  803e69:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803e70:	83 c4 10             	add    $0x10,%esp
  803e73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e78:	eb ad                	jmp    803e27 <dhcp_start+0x78>
    dhcp_stop(netif);
  803e7a:	83 ec 0c             	sub    $0xc,%esp
  803e7d:	53                   	push   %ebx
  803e7e:	e8 c4 fe ff ff       	call   803d47 <dhcp_stop>
    return ERR_MEM;
  803e83:	83 c4 10             	add    $0x10,%esp
  803e86:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e8b:	eb 9a                	jmp    803e27 <dhcp_start+0x78>
      return ERR_MEM;
  803e8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e92:	eb 93                	jmp    803e27 <dhcp_start+0x78>

00803e94 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803e94:	55                   	push   %ebp
  803e95:	89 e5                	mov    %esp,%ebp
  803e97:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803e9a:	b8 23 53 81 00       	mov    $0x815323,%eax
  803e9f:	83 e0 fc             	and    $0xfffffffc,%eax
  803ea2:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803ea7:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803ead:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803eb4:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803eb8:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803ebe:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803ec4:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803ecb:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803ed2:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803ed5:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803edc:	00 22 00 

  mem_sem = sys_sem_new(1);
  803edf:	6a 01                	push   $0x1
  803ee1:	e8 bb 5e 00 00       	call   809da1 <sys_sem_new>
  803ee6:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803eeb:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803ef0:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803ef5:	83 c4 10             	add    $0x10,%esp
  803ef8:	c9                   	leave  
  803ef9:	c3                   	ret    

00803efa <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803efa:	55                   	push   %ebp
  803efb:	89 e5                	mov    %esp,%ebp
  803efd:	56                   	push   %esi
  803efe:	53                   	push   %ebx
  803eff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803f02:	85 db                	test   %ebx,%ebx
  803f04:	0f 84 e1 00 00 00    	je     803feb <mem_free+0xf1>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803f0a:	f6 c3 03             	test   $0x3,%bl
  803f0d:	0f 85 df 00 00 00    	jne    803ff2 <mem_free+0xf8>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803f13:	39 1d 0c 53 81 00    	cmp    %ebx,0x81530c
  803f19:	0f 87 ea 00 00 00    	ja     804009 <mem_free+0x10f>
  803f1f:	39 1d 08 53 81 00    	cmp    %ebx,0x815308
  803f25:	0f 86 de 00 00 00    	jbe    804009 <mem_free+0x10f>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803f2b:	83 ec 08             	sub    $0x8,%esp
  803f2e:	6a 00                	push   $0x0
  803f30:	ff 35 00 53 81 00    	pushl  0x815300
  803f36:	e8 93 61 00 00       	call   80a0ce <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  803f3b:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803f3e:	83 c4 10             	add    $0x10,%esp
  803f41:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803f45:	0f 84 d5 00 00 00    	je     804020 <mem_free+0x126>
  /* ... and is now unused. */
  mem->used = 0;
  803f4b:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  803f4f:	39 05 04 53 81 00    	cmp    %eax,0x815304
  803f55:	76 05                	jbe    803f5c <mem_free+0x62>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  803f57:	a3 04 53 81 00       	mov    %eax,0x815304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  803f5c:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  803f62:	39 c8                	cmp    %ecx,%eax
  803f64:	0f 82 cd 00 00 00    	jb     804037 <mem_free+0x13d>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  803f6a:	8b 35 08 53 81 00    	mov    0x815308,%esi
  803f70:	39 f0                	cmp    %esi,%eax
  803f72:	0f 83 d6 00 00 00    	jae    80404e <mem_free+0x154>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  803f78:	8b 53 f4             	mov    -0xc(%ebx),%edx
  803f7b:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  803f81:	0f 87 de 00 00 00    	ja     804065 <mem_free+0x16b>
  nmem = (struct mem *)&ram[mem->next];
  803f87:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  803f89:	39 d0                	cmp    %edx,%eax
  803f8b:	74 25                	je     803fb2 <mem_free+0xb8>
  803f8d:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  803f91:	75 1f                	jne    803fb2 <mem_free+0xb8>
  803f93:	39 d6                	cmp    %edx,%esi
  803f95:	74 1b                	je     803fb2 <mem_free+0xb8>
    if (lfree == nmem) {
  803f97:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  803f9d:	0f 84 d9 00 00 00    	je     80407c <mem_free+0x182>
    mem->next = nmem->next;
  803fa3:	8b 32                	mov    (%edx),%esi
  803fa5:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  803fa8:	8b 12                	mov    (%edx),%edx
  803faa:	89 c6                	mov    %eax,%esi
  803fac:	29 ce                	sub    %ecx,%esi
  803fae:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  803fb2:	8b 73 f8             	mov    -0x8(%ebx),%esi
  803fb5:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  803fb8:	39 d0                	cmp    %edx,%eax
  803fba:	74 1e                	je     803fda <mem_free+0xe0>
  803fbc:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  803fc0:	75 18                	jne    803fda <mem_free+0xe0>
    if (lfree == mem) {
  803fc2:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  803fc8:	0f 84 b8 00 00 00    	je     804086 <mem_free+0x18c>
    pmem->next = mem->next;
  803fce:	8b 43 f4             	mov    -0xc(%ebx),%eax
  803fd1:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  803fd3:	8b 43 f4             	mov    -0xc(%ebx),%eax
  803fd6:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  803fda:	83 ec 0c             	sub    $0xc,%esp
  803fdd:	ff 35 00 53 81 00    	pushl  0x815300
  803fe3:	e8 76 60 00 00       	call   80a05e <sys_sem_signal>
  803fe8:	83 c4 10             	add    $0x10,%esp
}
  803feb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803fee:	5b                   	pop    %ebx
  803fef:	5e                   	pop    %esi
  803ff0:	5d                   	pop    %ebp
  803ff1:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803ff2:	83 ec 04             	sub    $0x4,%esp
  803ff5:	68 94 16 81 00       	push   $0x811694
  803ffa:	68 30 01 00 00       	push   $0x130
  803fff:	68 8b 17 81 00       	push   $0x81178b
  804004:	e8 67 a5 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804009:	83 ec 04             	sub    $0x4,%esp
  80400c:	68 9f 17 81 00       	push   $0x81179f
  804011:	68 33 01 00 00       	push   $0x133
  804016:	68 8b 17 81 00       	push   $0x81178b
  80401b:	e8 50 a5 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804020:	83 ec 04             	sub    $0x4,%esp
  804023:	68 b6 17 81 00       	push   $0x8117b6
  804028:	68 43 01 00 00       	push   $0x143
  80402d:	68 8b 17 81 00       	push   $0x81178b
  804032:	e8 39 a5 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804037:	83 ec 04             	sub    $0x4,%esp
  80403a:	68 ca 17 81 00       	push   $0x8117ca
  80403f:	68 e3 00 00 00       	push   $0xe3
  804044:	68 8b 17 81 00       	push   $0x81178b
  804049:	e8 22 a5 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80404e:	83 ec 04             	sub    $0x4,%esp
  804051:	68 e1 17 81 00       	push   $0x8117e1
  804056:	68 e4 00 00 00       	push   $0xe4
  80405b:	68 8b 17 81 00       	push   $0x81178b
  804060:	e8 0b a5 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804065:	83 ec 04             	sub    $0x4,%esp
  804068:	68 b8 16 81 00       	push   $0x8116b8
  80406d:	68 e8 00 00 00       	push   $0xe8
  804072:	68 8b 17 81 00       	push   $0x81178b
  804077:	e8 f4 a4 00 00       	call   80e570 <_panic>
      lfree = mem;
  80407c:	a3 04 53 81 00       	mov    %eax,0x815304
  804081:	e9 1d ff ff ff       	jmp    803fa3 <mem_free+0xa9>
      lfree = pmem;
  804086:	89 15 04 53 81 00    	mov    %edx,0x815304
  80408c:	e9 3d ff ff ff       	jmp    803fce <mem_free+0xd4>

00804091 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  804091:	55                   	push   %ebp
  804092:	89 e5                	mov    %esp,%ebp
  804094:	57                   	push   %edi
  804095:	56                   	push   %esi
  804096:	53                   	push   %ebx
  804097:	83 ec 1c             	sub    $0x1c,%esp
  80409a:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80409d:	8b 45 0c             	mov    0xc(%ebp),%eax
  8040a0:	8d 58 03             	lea    0x3(%eax),%ebx
  8040a3:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  8040a6:	83 fb 0b             	cmp    $0xb,%ebx
  8040a9:	76 12                	jbe    8040bd <mem_realloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8040ab:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8040b1:	76 0f                	jbe    8040c2 <mem_realloc+0x31>
    return NULL;
  8040b3:	be 00 00 00 00       	mov    $0x0,%esi
  8040b8:	e9 a1 00 00 00       	jmp    80415e <mem_realloc+0xcd>
    newsize = MIN_SIZE_ALIGNED;
  8040bd:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8040c2:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8040c7:	39 f0                	cmp    %esi,%eax
  8040c9:	0f 87 99 00 00 00    	ja     804168 <mem_realloc+0xd7>
  8040cf:	39 35 08 53 81 00    	cmp    %esi,0x815308
  8040d5:	0f 86 8d 00 00 00    	jbe    804168 <mem_realloc+0xd7>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8040db:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8040de:	29 c2                	sub    %eax,%edx
  8040e0:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8040e3:	8b 4e f4             	mov    -0xc(%esi),%ecx
  8040e6:	8d 79 f4             	lea    -0xc(%ecx),%edi
  8040e9:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8040eb:	39 df                	cmp    %ebx,%edi
  8040ed:	0f 82 8c 00 00 00    	jb     80417f <mem_realloc+0xee>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8040f3:	74 69                	je     80415e <mem_realloc+0xcd>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8040f5:	83 ec 08             	sub    $0x8,%esp
  8040f8:	6a 00                	push   $0x0
  8040fa:	ff 35 00 53 81 00    	pushl  0x815300
  804100:	e8 c9 5f 00 00       	call   80a0ce <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804105:	a1 0c 53 81 00       	mov    0x81530c,%eax
  80410a:	89 c2                	mov    %eax,%edx
  80410c:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  80410f:	83 c4 10             	add    $0x10,%esp
  804112:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804116:	0f 85 85 00 00 00    	jne    8041a1 <mem_realloc+0x110>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80411c:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80411e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804121:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  804125:	39 15 04 53 81 00    	cmp    %edx,0x815304
  80412b:	74 69                	je     804196 <mem_realloc+0x105>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  80412d:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  804130:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804134:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  804136:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804139:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  80413c:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80413f:	8b 12                	mov    (%edx),%edx
  804141:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804147:	74 04                	je     80414d <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804149:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80414d:	83 ec 0c             	sub    $0xc,%esp
  804150:	ff 35 00 53 81 00    	pushl  0x815300
  804156:	e8 03 5f 00 00       	call   80a05e <sys_sem_signal>
  return rmem;
  80415b:	83 c4 10             	add    $0x10,%esp
}
  80415e:	89 f0                	mov    %esi,%eax
  804160:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804163:	5b                   	pop    %ebx
  804164:	5e                   	pop    %esi
  804165:	5f                   	pop    %edi
  804166:	5d                   	pop    %ebp
  804167:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804168:	83 ec 04             	sub    $0x4,%esp
  80416b:	68 fb 17 81 00       	push   $0x8117fb
  804170:	68 79 01 00 00       	push   $0x179
  804175:	68 8b 17 81 00       	push   $0x81178b
  80417a:	e8 f1 a3 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80417f:	83 ec 04             	sub    $0x4,%esp
  804182:	68 e4 16 81 00       	push   $0x8116e4
  804187:	68 8a 01 00 00       	push   $0x18a
  80418c:	68 8b 17 81 00       	push   $0x81178b
  804191:	e8 da a3 00 00       	call   80e570 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  804196:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  804199:	89 15 04 53 81 00    	mov    %edx,0x815304
  80419f:	eb 8c                	jmp    80412d <mem_realloc+0x9c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8041a1:	8d 53 18             	lea    0x18(%ebx),%edx
  8041a4:	39 fa                	cmp    %edi,%edx
  8041a6:	77 a5                	ja     80414d <mem_realloc+0xbc>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8041a8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041ab:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8041af:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8041b2:	39 15 04 53 81 00    	cmp    %edx,0x815304
  8041b8:	76 06                	jbe    8041c0 <mem_realloc+0x12f>
      lfree = mem2;
  8041ba:	89 15 04 53 81 00    	mov    %edx,0x815304
    mem2->used = 0;
  8041c0:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8041c4:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8041c7:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8041c9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8041cc:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8041cf:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8041d2:	8b 12                	mov    (%edx),%edx
  8041d4:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8041da:	0f 84 6d ff ff ff    	je     80414d <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041e0:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  8041e4:	e9 64 ff ff ff       	jmp    80414d <mem_realloc+0xbc>

008041e9 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8041e9:	55                   	push   %ebp
  8041ea:	89 e5                	mov    %esp,%ebp
  8041ec:	57                   	push   %edi
  8041ed:	56                   	push   %esi
  8041ee:	53                   	push   %ebx
  8041ef:	83 ec 1c             	sub    $0x1c,%esp
  8041f2:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8041f5:	85 c0                	test   %eax,%eax
  8041f7:	0f 84 a0 01 00 00    	je     80439d <mem_malloc+0x1b4>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  8041fd:	83 c0 03             	add    $0x3,%eax
  804200:	83 e0 fc             	and    $0xfffffffc,%eax
  804203:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  804205:	83 f8 0b             	cmp    $0xb,%eax
  804208:	76 3a                	jbe    804244 <mem_malloc+0x5b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80420a:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80420f:	0f 87 8f 01 00 00    	ja     8043a4 <mem_malloc+0x1bb>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804215:	83 ec 08             	sub    $0x8,%esp
  804218:	6a 00                	push   $0x0
  80421a:	ff 35 00 53 81 00    	pushl  0x815300
  804220:	e8 a9 5e 00 00       	call   80a0ce <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804225:	a1 04 53 81 00       	mov    0x815304,%eax
  80422a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80422d:	8b 35 0c 53 81 00    	mov    0x81530c,%esi
  804233:	29 f0                	sub    %esi,%eax
  804235:	83 c4 10             	add    $0x10,%esp
  804238:	b9 00 00 22 00       	mov    $0x220000,%ecx
  80423d:	29 f9                	sub    %edi,%ecx
  80423f:	e9 e2 00 00 00       	jmp    804326 <mem_malloc+0x13d>
    size = MIN_SIZE_ALIGNED;
  804244:	bf 0c 00 00 00       	mov    $0xc,%edi
  804249:	eb ca                	jmp    804215 <mem_malloc+0x2c>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80424b:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80424f:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  804252:	74 4c                	je     8042a0 <mem_malloc+0xb7>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804254:	83 ec 0c             	sub    $0xc,%esp
  804257:	ff 35 00 53 81 00    	pushl  0x815300
  80425d:	e8 fc 5d 00 00       	call   80a05e <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804262:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  804266:	83 c4 10             	add    $0x10,%esp
  804269:	39 05 08 53 81 00    	cmp    %eax,0x815308
  80426f:	0f 82 81 00 00 00    	jb     8042f6 <mem_malloc+0x10d>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804275:	8d 43 0c             	lea    0xc(%ebx),%eax
  804278:	a8 03                	test   $0x3,%al
  80427a:	0f 85 8d 00 00 00    	jne    80430d <mem_malloc+0x124>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804280:	f6 c3 03             	test   $0x3,%bl
  804283:	0f 84 0c 01 00 00    	je     804395 <mem_malloc+0x1ac>
  804289:	83 ec 04             	sub    $0x4,%esp
  80428c:	68 68 17 81 00       	push   $0x811768
  804291:	68 4f 02 00 00       	push   $0x24f
  804296:	68 8b 17 81 00       	push   $0x81178b
  80429b:	e8 d0 a2 00 00       	call   80e570 <_panic>
          while (lfree->used && lfree != ram_end) {
  8042a0:	8b 15 08 53 81 00    	mov    0x815308,%edx
  8042a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8042ab:	b9 01 00 00 00       	mov    $0x1,%ecx
  8042b0:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8042b3:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8042b6:	eb 08                	jmp    8042c0 <mem_malloc+0xd7>
            lfree = (struct mem *)&ram[lfree->next];
  8042b8:	89 f0                	mov    %esi,%eax
  8042ba:	03 07                	add    (%edi),%eax
  8042bc:	89 c7                	mov    %eax,%edi
  8042be:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  8042c0:	80 7f 08 00          	cmpb   $0x0,0x8(%edi)
  8042c4:	74 18                	je     8042de <mem_malloc+0xf5>
  8042c6:	39 fa                	cmp    %edi,%edx
  8042c8:	75 ee                	jne    8042b8 <mem_malloc+0xcf>
  8042ca:	89 fe                	mov    %edi,%esi
  8042cc:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8042cf:	84 c0                	test   %al,%al
  8042d1:	74 81                	je     804254 <mem_malloc+0x6b>
  8042d3:	89 35 04 53 81 00    	mov    %esi,0x815304
  8042d9:	e9 76 ff ff ff       	jmp    804254 <mem_malloc+0x6b>
  8042de:	89 fe                	mov    %edi,%esi
  8042e0:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8042e3:	84 c0                	test   %al,%al
  8042e5:	0f 84 69 ff ff ff    	je     804254 <mem_malloc+0x6b>
  8042eb:	89 35 04 53 81 00    	mov    %esi,0x815304
  8042f1:	e9 5e ff ff ff       	jmp    804254 <mem_malloc+0x6b>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8042f6:	83 ec 04             	sub    $0x4,%esp
  8042f9:	68 08 17 81 00       	push   $0x811708
  8042fe:	68 4b 02 00 00       	push   $0x24b
  804303:	68 8b 17 81 00       	push   $0x81178b
  804308:	e8 63 a2 00 00       	call   80e570 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80430d:	83 ec 04             	sub    $0x4,%esp
  804310:	68 38 17 81 00       	push   $0x811738
  804315:	68 4d 02 00 00       	push   $0x24d
  80431a:	68 8b 17 81 00       	push   $0x81178b
  80431f:	e8 4c a2 00 00       	call   80e570 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  804324:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804326:	39 c1                	cmp    %eax,%ecx
  804328:	76 55                	jbe    80437f <mem_malloc+0x196>
      mem = (struct mem *)&ram[ptr];
  80432a:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  80432d:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804331:	75 f1                	jne    804324 <mem_malloc+0x13b>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  804333:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  804338:	29 c2                	sub    %eax,%edx
  80433a:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  80433c:	39 fa                	cmp    %edi,%edx
  80433e:	72 e4                	jb     804324 <mem_malloc+0x13b>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  804340:	8d 4f 18             	lea    0x18(%edi),%ecx
  804343:	39 ca                	cmp    %ecx,%edx
  804345:	0f 82 00 ff ff ff    	jb     80424b <mem_malloc+0x62>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80434b:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  80434f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  804352:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  804355:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  804359:	8b 0b                	mov    (%ebx),%ecx
  80435b:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  80435d:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  804360:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  804363:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  804365:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  804369:	8b 02                	mov    (%edx),%eax
  80436b:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804370:	0f 84 d9 fe ff ff    	je     80424f <mem_malloc+0x66>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804376:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  80437a:	e9 d0 fe ff ff       	jmp    80424f <mem_malloc+0x66>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80437f:	83 ec 0c             	sub    $0xc,%esp
  804382:	ff 35 00 53 81 00    	pushl  0x815300
  804388:	e8 d1 5c 00 00       	call   80a05e <sys_sem_signal>
  return NULL;
  80438d:	83 c4 10             	add    $0x10,%esp
  804390:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804395:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804398:	5b                   	pop    %ebx
  804399:	5e                   	pop    %esi
  80439a:	5f                   	pop    %edi
  80439b:	5d                   	pop    %ebp
  80439c:	c3                   	ret    
    return NULL;
  80439d:	b8 00 00 00 00       	mov    $0x0,%eax
  8043a2:	eb f1                	jmp    804395 <mem_malloc+0x1ac>
    return NULL;
  8043a4:	b8 00 00 00 00       	mov    $0x0,%eax
  8043a9:	eb ea                	jmp    804395 <mem_malloc+0x1ac>

008043ab <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8043ab:	55                   	push   %ebp
  8043ac:	89 e5                	mov    %esp,%ebp
  8043ae:	56                   	push   %esi
  8043af:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8043b0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8043b3:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8043b7:	83 ec 0c             	sub    $0xc,%esp
  8043ba:	53                   	push   %ebx
  8043bb:	e8 29 fe ff ff       	call   8041e9 <mem_malloc>
  8043c0:	89 c6                	mov    %eax,%esi
  if (p) {
  8043c2:	83 c4 10             	add    $0x10,%esp
  8043c5:	85 c0                	test   %eax,%eax
  8043c7:	74 0f                	je     8043d8 <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  8043c9:	83 ec 04             	sub    $0x4,%esp
  8043cc:	53                   	push   %ebx
  8043cd:	6a 00                	push   $0x0
  8043cf:	50                   	push   %eax
  8043d0:	e8 98 a9 00 00       	call   80ed6d <memset>
  8043d5:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8043d8:	89 f0                	mov    %esi,%eax
  8043da:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8043dd:	5b                   	pop    %ebx
  8043de:	5e                   	pop    %esi
  8043df:	5d                   	pop    %ebp
  8043e0:	c3                   	ret    

008043e1 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8043e1:	55                   	push   %ebp
  8043e2:	89 e5                	mov    %esp,%ebp
  8043e4:	56                   	push   %esi
  8043e5:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8043e6:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  8043eb:	83 e0 fc             	and    $0xfffffffc,%eax
  8043ee:	ba 00 00 00 00       	mov    $0x0,%edx
  8043f3:	eb 08                	jmp    8043fd <memp_init+0x1c>
  8043f5:	83 c2 01             	add    $0x1,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8043f8:	83 fa 0e             	cmp    $0xe,%edx
  8043fb:	74 3c                	je     804439 <memp_init+0x58>
    memp_tab[i] = NULL;
  8043fd:	c7 04 95 c0 43 b3 00 	movl   $0x0,0xb343c0(,%edx,4)
  804404:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804408:	0f b7 b4 12 8c 18 81 	movzwl 0x81188c(%edx,%edx,1),%esi
  80440f:	00 
  804410:	b9 00 00 00 00       	mov    $0x0,%ecx
  804415:	66 39 ce             	cmp    %cx,%si
  804418:	74 db                	je     8043f5 <memp_init+0x14>
      memp->next = memp_tab[i];
  80441a:	8b 1c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ebx
  804421:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804423:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80442a:	0f b7 9c 12 a8 18 81 	movzwl 0x8118a8(%edx,%edx,1),%ebx
  804431:	00 
  804432:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  804434:	83 c1 01             	add    $0x1,%ecx
  804437:	eb dc                	jmp    804415 <memp_init+0x34>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804439:	5b                   	pop    %ebx
  80443a:	5e                   	pop    %esi
  80443b:	5d                   	pop    %ebp
  80443c:	c3                   	ret    

0080443d <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80443d:	55                   	push   %ebp
  80443e:	89 e5                	mov    %esp,%ebp
  804440:	83 ec 08             	sub    $0x8,%esp
  804443:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804446:	83 fa 0d             	cmp    $0xd,%edx
  804449:	77 1a                	ja     804465 <memp_malloc+0x28>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80444b:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804452:	85 c0                	test   %eax,%eax
  804454:	74 0d                	je     804463 <memp_malloc+0x26>
    memp_tab[type] = memp->next;    
  804456:	8b 08                	mov    (%eax),%ecx
  804458:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80445f:	a8 03                	test   $0x3,%al
  804461:	75 19                	jne    80447c <memp_malloc+0x3f>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804463:	c9                   	leave  
  804464:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804465:	83 ec 04             	sub    $0x4,%esp
  804468:	68 15 18 81 00       	push   $0x811815
  80446d:	68 2d 01 00 00       	push   $0x12d
  804472:	68 32 18 81 00       	push   $0x811832
  804477:	e8 f4 a0 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80447c:	83 ec 04             	sub    $0x4,%esp
  80447f:	68 48 18 81 00       	push   $0x811848
  804484:	68 3f 01 00 00       	push   $0x13f
  804489:	68 32 18 81 00       	push   $0x811832
  80448e:	e8 dd a0 00 00       	call   80e570 <_panic>

00804493 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  804493:	55                   	push   %ebp
  804494:	89 e5                	mov    %esp,%ebp
  804496:	83 ec 08             	sub    $0x8,%esp
  804499:	8b 55 08             	mov    0x8(%ebp),%edx
  80449c:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80449f:	85 c0                	test   %eax,%eax
  8044a1:	74 14                	je     8044b7 <memp_free+0x24>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8044a3:	a8 03                	test   $0x3,%al
  8044a5:	75 12                	jne    8044b9 <memp_free+0x26>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8044a7:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8044ae:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8044b0:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8044b7:	c9                   	leave  
  8044b8:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  8044b9:	83 ec 04             	sub    $0x4,%esp
  8044bc:	68 6c 18 81 00       	push   $0x81186c
  8044c1:	68 5b 01 00 00       	push   $0x15b
  8044c6:	68 32 18 81 00       	push   $0x811832
  8044cb:	e8 a0 a0 00 00       	call   80e570 <_panic>

008044d0 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8044d0:	55                   	push   %ebp
  8044d1:	89 e5                	mov    %esp,%ebp
  8044d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8044d6:	85 c9                	test   %ecx,%ecx
  8044d8:	74 2c                	je     804506 <netif_remove+0x36>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8044da:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8044df:	39 c8                	cmp    %ecx,%eax
  8044e1:	74 0e                	je     8044f1 <netif_remove+0x21>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8044e3:	85 c0                	test   %eax,%eax
  8044e5:	74 1f                	je     804506 <netif_remove+0x36>
      if (tmpNetif->next == netif) {
  8044e7:	8b 10                	mov    (%eax),%edx
  8044e9:	39 ca                	cmp    %ecx,%edx
  8044eb:	74 0d                	je     8044fa <netif_remove+0x2a>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8044ed:	89 d0                	mov    %edx,%eax
  8044ef:	eb f2                	jmp    8044e3 <netif_remove+0x13>
    netif_list = netif->next;
  8044f1:	8b 01                	mov    (%ecx),%eax
  8044f3:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  8044f8:	eb 04                	jmp    8044fe <netif_remove+0x2e>
        tmpNetif->next = netif->next;
  8044fa:	8b 11                	mov    (%ecx),%edx
  8044fc:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  8044fe:	39 0d 38 b2 b3 00    	cmp    %ecx,0xb3b238
  804504:	74 02                	je     804508 <netif_remove+0x38>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804506:	5d                   	pop    %ebp
  804507:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804508:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  80450f:	00 00 00 
  804512:	eb f2                	jmp    804506 <netif_remove+0x36>

00804514 <netif_find>:
{
  804514:	55                   	push   %ebp
  804515:	89 e5                	mov    %esp,%ebp
  804517:	53                   	push   %ebx
  804518:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  80451b:	85 c9                	test   %ecx,%ecx
  80451d:	74 2d                	je     80454c <netif_find+0x38>
  num = name[2] - '0';
  80451f:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804523:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804526:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  80452b:	eb 02                	jmp    80452f <netif_find+0x1b>
  80452d:	8b 00                	mov    (%eax),%eax
  80452f:	85 c0                	test   %eax,%eax
  804531:	74 16                	je     804549 <netif_find+0x35>
    if (num == netif->num &&
  804533:	38 50 31             	cmp    %dl,0x31(%eax)
  804536:	75 f5                	jne    80452d <netif_find+0x19>
  804538:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  80453c:	38 19                	cmp    %bl,(%ecx)
  80453e:	75 ed                	jne    80452d <netif_find+0x19>
       name[0] == netif->name[0] &&
  804540:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804544:	38 59 01             	cmp    %bl,0x1(%ecx)
  804547:	75 e4                	jne    80452d <netif_find+0x19>
}
  804549:	5b                   	pop    %ebx
  80454a:	5d                   	pop    %ebp
  80454b:	c3                   	ret    
    return NULL;
  80454c:	b8 00 00 00 00       	mov    $0x0,%eax
  804551:	eb f6                	jmp    804549 <netif_find+0x35>

00804553 <netif_set_ipaddr>:
{
  804553:	55                   	push   %ebp
  804554:	89 e5                	mov    %esp,%ebp
  804556:	57                   	push   %edi
  804557:	56                   	push   %esi
  804558:	53                   	push   %ebx
  804559:	83 ec 0c             	sub    $0xc,%esp
  80455c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80455f:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804562:	8b 43 04             	mov    0x4(%ebx),%eax
  804565:	39 06                	cmp    %eax,(%esi)
  804567:	74 47                	je     8045b0 <netif_set_ipaddr+0x5d>
    pcb = tcp_active_pcbs;
  804569:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  80456e:	eb 11                	jmp    804581 <netif_set_ipaddr+0x2e>
        struct tcp_pcb *next = pcb->next;
  804570:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  804573:	83 ec 0c             	sub    $0xc,%esp
  804576:	50                   	push   %eax
  804577:	e8 d4 15 00 00       	call   805b50 <tcp_abort>
  80457c:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  80457f:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  804581:	85 c0                	test   %eax,%eax
  804583:	74 0c                	je     804591 <netif_set_ipaddr+0x3e>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804585:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804588:	39 08                	cmp    %ecx,(%eax)
  80458a:	74 e4                	je     804570 <netif_set_ipaddr+0x1d>
        pcb = pcb->next;
  80458c:	8b 40 0c             	mov    0xc(%eax),%eax
  80458f:	eb f0                	jmp    804581 <netif_set_ipaddr+0x2e>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804591:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  804596:	eb 03                	jmp    80459b <netif_set_ipaddr+0x48>
  804598:	8b 40 0c             	mov    0xc(%eax),%eax
  80459b:	85 c0                	test   %eax,%eax
  80459d:	74 11                	je     8045b0 <netif_set_ipaddr+0x5d>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80459f:	8b 10                	mov    (%eax),%edx
  8045a1:	85 d2                	test   %edx,%edx
  8045a3:	74 f3                	je     804598 <netif_set_ipaddr+0x45>
  8045a5:	3b 53 04             	cmp    0x4(%ebx),%edx
  8045a8:	75 ee                	jne    804598 <netif_set_ipaddr+0x45>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8045aa:	8b 16                	mov    (%esi),%edx
  8045ac:	89 10                	mov    %edx,(%eax)
  8045ae:	eb e8                	jmp    804598 <netif_set_ipaddr+0x45>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8045b0:	8b 06                	mov    (%esi),%eax
  8045b2:	89 43 04             	mov    %eax,0x4(%ebx)
}
  8045b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045b8:	5b                   	pop    %ebx
  8045b9:	5e                   	pop    %esi
  8045ba:	5f                   	pop    %edi
  8045bb:	5d                   	pop    %ebp
  8045bc:	c3                   	ret    

008045bd <netif_set_addr>:
{
  8045bd:	55                   	push   %ebp
  8045be:	89 e5                	mov    %esp,%ebp
  8045c0:	57                   	push   %edi
  8045c1:	56                   	push   %esi
  8045c2:	53                   	push   %ebx
  8045c3:	83 ec 14             	sub    $0x14,%esp
  8045c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8045c9:	8b 7d 10             	mov    0x10(%ebp),%edi
  8045cc:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  8045cf:	ff 75 0c             	pushl  0xc(%ebp)
  8045d2:	53                   	push   %ebx
  8045d3:	e8 7b ff ff ff       	call   804553 <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  8045d8:	83 c4 10             	add    $0x10,%esp
  8045db:	b8 00 00 00 00       	mov    $0x0,%eax
  8045e0:	85 ff                	test   %edi,%edi
  8045e2:	74 02                	je     8045e6 <netif_set_addr+0x29>
  8045e4:	8b 07                	mov    (%edi),%eax
  8045e6:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  8045e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8045ee:	85 f6                	test   %esi,%esi
  8045f0:	74 02                	je     8045f4 <netif_set_addr+0x37>
  8045f2:	8b 06                	mov    (%esi),%eax
  8045f4:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  8045f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045fa:	5b                   	pop    %ebx
  8045fb:	5e                   	pop    %esi
  8045fc:	5f                   	pop    %edi
  8045fd:	5d                   	pop    %ebp
  8045fe:	c3                   	ret    

008045ff <netif_add>:
{
  8045ff:	55                   	push   %ebp
  804600:	89 e5                	mov    %esp,%ebp
  804602:	53                   	push   %ebx
  804603:	83 ec 04             	sub    $0x4,%esp
  804606:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  804609:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804610:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804617:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  80461e:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  804622:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  804629:	8b 45 18             	mov    0x18(%ebp),%eax
  80462c:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  80462f:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  804636:	8d 50 01             	lea    0x1(%eax),%edx
  804639:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  80463f:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804642:	8b 45 20             	mov    0x20(%ebp),%eax
  804645:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  804648:	ff 75 14             	pushl  0x14(%ebp)
  80464b:	ff 75 10             	pushl  0x10(%ebp)
  80464e:	ff 75 0c             	pushl  0xc(%ebp)
  804651:	53                   	push   %ebx
  804652:	e8 66 ff ff ff       	call   8045bd <netif_set_addr>
  if (init(netif) != ERR_OK) {
  804657:	89 1c 24             	mov    %ebx,(%esp)
  80465a:	ff 55 1c             	call   *0x1c(%ebp)
  80465d:	83 c4 10             	add    $0x10,%esp
  804660:	84 c0                	test   %al,%al
  804662:	75 14                	jne    804678 <netif_add+0x79>
  netif->next = netif_list;
  804664:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804669:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80466b:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  return netif;
  804671:	89 d8                	mov    %ebx,%eax
}
  804673:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804676:	c9                   	leave  
  804677:	c3                   	ret    
    return NULL;
  804678:	b8 00 00 00 00       	mov    $0x0,%eax
  80467d:	eb f4                	jmp    804673 <netif_add+0x74>

0080467f <netif_set_gw>:
{
  80467f:	55                   	push   %ebp
  804680:	89 e5                	mov    %esp,%ebp
  804682:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  804685:	b8 00 00 00 00       	mov    $0x0,%eax
  80468a:	85 d2                	test   %edx,%edx
  80468c:	74 02                	je     804690 <netif_set_gw+0x11>
  80468e:	8b 02                	mov    (%edx),%eax
  804690:	8b 55 08             	mov    0x8(%ebp),%edx
  804693:	89 42 0c             	mov    %eax,0xc(%edx)
}
  804696:	5d                   	pop    %ebp
  804697:	c3                   	ret    

00804698 <netif_set_netmask>:
{
  804698:	55                   	push   %ebp
  804699:	89 e5                	mov    %esp,%ebp
  80469b:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  80469e:	b8 00 00 00 00       	mov    $0x0,%eax
  8046a3:	85 d2                	test   %edx,%edx
  8046a5:	74 02                	je     8046a9 <netif_set_netmask+0x11>
  8046a7:	8b 02                	mov    (%edx),%eax
  8046a9:	8b 55 08             	mov    0x8(%ebp),%edx
  8046ac:	89 42 08             	mov    %eax,0x8(%edx)
}
  8046af:	5d                   	pop    %ebp
  8046b0:	c3                   	ret    

008046b1 <netif_set_default>:
{
  8046b1:	55                   	push   %ebp
  8046b2:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  8046b4:	8b 45 08             	mov    0x8(%ebp),%eax
  8046b7:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  8046bc:	5d                   	pop    %ebp
  8046bd:	c3                   	ret    

008046be <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8046be:	55                   	push   %ebp
  8046bf:	89 e5                	mov    %esp,%ebp
  8046c1:	83 ec 08             	sub    $0x8,%esp
  8046c4:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8046c7:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8046cb:	a8 01                	test   $0x1,%al
  8046cd:	75 0c                	jne    8046db <netif_set_up+0x1d>
    netif->flags |= NETIF_FLAG_UP;
  8046cf:	89 c1                	mov    %eax,%ecx
  8046d1:	83 c9 01             	or     $0x1,%ecx
  8046d4:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8046d7:	a8 20                	test   $0x20,%al
  8046d9:	75 02                	jne    8046dd <netif_set_up+0x1f>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  8046db:	c9                   	leave  
  8046dc:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  8046dd:	83 ec 04             	sub    $0x4,%esp
  8046e0:	6a 00                	push   $0x0
  8046e2:	8d 42 04             	lea    0x4(%edx),%eax
  8046e5:	50                   	push   %eax
  8046e6:	52                   	push   %edx
  8046e7:	e8 e3 51 00 00       	call   8098cf <etharp_query>
  8046ec:	83 c4 10             	add    $0x10,%esp
}
  8046ef:	eb ea                	jmp    8046db <netif_set_up+0x1d>

008046f1 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  8046f1:	55                   	push   %ebp
  8046f2:	89 e5                	mov    %esp,%ebp
  8046f4:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  8046f7:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8046fb:	a8 01                	test   $0x1,%al
  8046fd:	74 06                	je     804705 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  8046ff:	83 e0 fe             	and    $0xfffffffe,%eax
  804702:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804705:	5d                   	pop    %ebp
  804706:	c3                   	ret    

00804707 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804707:	55                   	push   %ebp
  804708:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80470a:	8b 45 08             	mov    0x8(%ebp),%eax
  80470d:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804711:	83 e0 01             	and    $0x1,%eax
}
  804714:	5d                   	pop    %ebp
  804715:	c3                   	ret    

00804716 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804716:	55                   	push   %ebp
  804717:	89 e5                	mov    %esp,%ebp
  804719:	56                   	push   %esi
  80471a:	53                   	push   %ebx
  80471b:	8b 55 08             	mov    0x8(%ebp),%edx
  80471e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804721:	85 d2                	test   %edx,%edx
  804723:	74 42                	je     804767 <pbuf_header+0x51>
  if ((header_size_increment == 0) || (p == NULL))
  804725:	66 85 c9             	test   %cx,%cx
  804728:	0f 84 ae 00 00 00    	je     8047dc <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  80472e:	89 ce                	mov    %ecx,%esi
  if (header_size_increment < 0){
  804730:	78 4c                	js     80477e <pbuf_header+0x68>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804732:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804736:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804739:	66 85 c0             	test   %ax,%ax
  80473c:	74 5f                	je     80479d <pbuf_header+0x87>
  80473e:	66 83 f8 03          	cmp    $0x3,%ax
  804742:	74 59                	je     80479d <pbuf_header+0x87>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804744:	83 e8 01             	sub    $0x1,%eax
  804747:	66 83 f8 01          	cmp    $0x1,%ax
  80474b:	77 78                	ja     8047c5 <pbuf_header+0xaf>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80474d:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804752:	66 85 c9             	test   %cx,%cx
  804755:	79 67                	jns    8047be <pbuf_header+0xa8>
  804757:	66 39 72 0a          	cmp    %si,0xa(%edx)
  80475b:	72 61                	jb     8047be <pbuf_header+0xa8>
      p->payload = (u8_t *)p->payload - header_size_increment;
  80475d:	0f bf c1             	movswl %cx,%eax
  804760:	29 c3                	sub    %eax,%ebx
  804762:	89 5a 04             	mov    %ebx,0x4(%edx)
  804765:	eb 4a                	jmp    8047b1 <pbuf_header+0x9b>
  LWIP_ASSERT("p != NULL", p != NULL);
  804767:	83 ec 04             	sub    $0x4,%esp
  80476a:	68 88 19 81 00       	push   $0x811988
  80476f:	68 64 01 00 00       	push   $0x164
  804774:	68 c4 18 81 00       	push   $0x8118c4
  804779:	e8 f2 9d 00 00       	call   80e570 <_panic>
    increment_magnitude = -header_size_increment;
  80477e:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804780:	66 39 72 0a          	cmp    %si,0xa(%edx)
  804784:	73 ac                	jae    804732 <pbuf_header+0x1c>
  804786:	83 ec 04             	sub    $0x4,%esp
  804789:	68 d9 18 81 00       	push   $0x8118d9
  80478e:	68 6b 01 00 00       	push   $0x16b
  804793:	68 c4 18 81 00       	push   $0x8118c4
  804798:	e8 d3 9d 00 00       	call   80e570 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  80479d:	0f bf c1             	movswl %cx,%eax
  8047a0:	29 c3                	sub    %eax,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8047a2:	8d 72 10             	lea    0x10(%edx),%esi
      return 1;
  8047a5:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8047aa:	39 f3                	cmp    %esi,%ebx
  8047ac:	72 10                	jb     8047be <pbuf_header+0xa8>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8047ae:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8047b1:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  8047b5:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8047b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8047be:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8047c1:	5b                   	pop    %ebx
  8047c2:	5e                   	pop    %esi
  8047c3:	5d                   	pop    %ebp
  8047c4:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  8047c5:	83 ec 04             	sub    $0x4,%esp
  8047c8:	68 f7 18 81 00       	push   $0x8118f7
  8047cd:	68 9a 01 00 00       	push   $0x19a
  8047d2:	68 c4 18 81 00       	push   $0x8118c4
  8047d7:	e8 94 9d 00 00       	call   80e570 <_panic>
    return 0;
  8047dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8047e1:	eb db                	jmp    8047be <pbuf_header+0xa8>

008047e3 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  8047e3:	55                   	push   %ebp
  8047e4:	89 e5                	mov    %esp,%ebp
  8047e6:	56                   	push   %esi
  8047e7:	53                   	push   %ebx
  8047e8:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  8047eb:	85 c0                	test   %eax,%eax
  8047ed:	74 0d                	je     8047fc <pbuf_free+0x19>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  8047ef:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  8047f3:	77 1e                	ja     804813 <pbuf_free+0x30>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  8047f5:	bb 00 00 00 00       	mov    $0x0,%ebx
  8047fa:	eb 6c                	jmp    804868 <pbuf_free+0x85>
    LWIP_ASSERT("p != NULL", p != NULL);
  8047fc:	83 ec 04             	sub    $0x4,%esp
  8047ff:	68 88 19 81 00       	push   $0x811988
  804804:	68 d0 01 00 00       	push   $0x1d0
  804809:	68 c4 18 81 00       	push   $0x8118c4
  80480e:	e8 5d 9d 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  804813:	83 ec 04             	sub    $0x4,%esp
  804816:	68 05 19 81 00       	push   $0x811905
  80481b:	68 db 01 00 00       	push   $0x1db
  804820:	68 c4 18 81 00       	push   $0x8118c4
  804825:	e8 46 9d 00 00       	call   80e570 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80482a:	83 ec 04             	sub    $0x4,%esp
  80482d:	68 1a 19 81 00       	push   $0x81191a
  804832:	68 e8 01 00 00       	push   $0x1e8
  804837:	68 c4 18 81 00       	push   $0x8118c4
  80483c:	e8 2f 9d 00 00       	call   80e570 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  804841:	83 ec 08             	sub    $0x8,%esp
  804844:	50                   	push   %eax
  804845:	6a 0d                	push   $0xd
  804847:	e8 47 fc ff ff       	call   804493 <memp_free>
  80484c:	83 c4 10             	add    $0x10,%esp
  80484f:	eb 0e                	jmp    80485f <pbuf_free+0x7c>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  804851:	83 ec 08             	sub    $0x8,%esp
  804854:	50                   	push   %eax
  804855:	6a 0c                	push   $0xc
  804857:	e8 37 fc ff ff       	call   804493 <memp_free>
  80485c:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  80485f:	83 c3 01             	add    $0x1,%ebx
      /* proceed to next pbuf */
      p = q;
  804862:	89 f0                	mov    %esi,%eax
  while (p != NULL) {
  804864:	85 f6                	test   %esi,%esi
  804866:	74 38                	je     8048a0 <pbuf_free+0xbd>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804868:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  80486c:	66 85 d2             	test   %dx,%dx
  80486f:	74 b9                	je     80482a <pbuf_free+0x47>
    ref = --(p->ref);
  804871:	83 ea 01             	sub    $0x1,%edx
  804874:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  804878:	66 85 d2             	test   %dx,%dx
  80487b:	75 23                	jne    8048a0 <pbuf_free+0xbd>
      q = p->next;
  80487d:	8b 30                	mov    (%eax),%esi
      type = p->type;
  80487f:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  804883:	66 83 fa 03          	cmp    $0x3,%dx
  804887:	74 b8                	je     804841 <pbuf_free+0x5e>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804889:	83 ea 01             	sub    $0x1,%edx
  80488c:	66 83 fa 01          	cmp    $0x1,%dx
  804890:	76 bf                	jbe    804851 <pbuf_free+0x6e>
        mem_free(p);
  804892:	83 ec 0c             	sub    $0xc,%esp
  804895:	50                   	push   %eax
  804896:	e8 5f f6 ff ff       	call   803efa <mem_free>
  80489b:	83 c4 10             	add    $0x10,%esp
  80489e:	eb bf                	jmp    80485f <pbuf_free+0x7c>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8048a0:	89 d8                	mov    %ebx,%eax
  8048a2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8048a5:	5b                   	pop    %ebx
  8048a6:	5e                   	pop    %esi
  8048a7:	5d                   	pop    %ebp
  8048a8:	c3                   	ret    

008048a9 <pbuf_alloc>:
{
  8048a9:	55                   	push   %ebp
  8048aa:	89 e5                	mov    %esp,%ebp
  8048ac:	57                   	push   %edi
  8048ad:	56                   	push   %esi
  8048ae:	53                   	push   %ebx
  8048af:	83 ec 1c             	sub    $0x1c,%esp
  8048b2:	8b 45 08             	mov    0x8(%ebp),%eax
  8048b5:	8b 75 0c             	mov    0xc(%ebp),%esi
  8048b8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  8048bb:	83 f8 01             	cmp    $0x1,%eax
  8048be:	0f 84 8a 00 00 00    	je     80494e <pbuf_alloc+0xa5>
  8048c4:	85 c0                	test   %eax,%eax
  8048c6:	0f 84 89 00 00 00    	je     804955 <pbuf_alloc+0xac>
  8048cc:	83 f8 02             	cmp    $0x2,%eax
  8048cf:	0f 84 94 00 00 00    	je     804969 <pbuf_alloc+0xc0>
  8048d5:	83 f8 03             	cmp    $0x3,%eax
  8048d8:	0f 85 92 00 00 00    	jne    804970 <pbuf_alloc+0xc7>
  offset = 0;
  8048de:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  8048e4:	83 fb 02             	cmp    $0x2,%ebx
  8048e7:	0f 87 9a 00 00 00    	ja     804987 <pbuf_alloc+0xde>
  8048ed:	85 db                	test   %ebx,%ebx
  8048ef:	0f 85 db 01 00 00    	jne    804ad0 <pbuf_alloc+0x227>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  8048f5:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  8048f9:	83 ec 0c             	sub    $0xc,%esp
  8048fc:	8d 43 13             	lea    0x13(%ebx),%eax
  8048ff:	83 e0 fc             	and    $0xfffffffc,%eax
  804902:	89 c2                	mov    %eax,%edx
  804904:	0f b7 c6             	movzwl %si,%eax
  804907:	83 c0 03             	add    $0x3,%eax
  80490a:	83 e0 fc             	and    $0xfffffffc,%eax
  80490d:	01 d0                	add    %edx,%eax
  80490f:	50                   	push   %eax
  804910:	e8 d4 f8 ff ff       	call   8041e9 <mem_malloc>
  804915:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804917:	83 c4 10             	add    $0x10,%esp
  80491a:	85 c0                	test   %eax,%eax
  80491c:	74 26                	je     804944 <pbuf_alloc+0x9b>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80491e:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804922:	83 e0 fc             	and    $0xfffffffc,%eax
  804925:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  804928:	66 89 77 08          	mov    %si,0x8(%edi)
  80492c:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  804930:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  804936:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  80493a:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  804940:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  804944:	89 f8                	mov    %edi,%eax
  804946:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804949:	5b                   	pop    %ebx
  80494a:	5e                   	pop    %esi
  80494b:	5f                   	pop    %edi
  80494c:	5d                   	pop    %ebp
  80494d:	c3                   	ret    
  offset = 0;
  80494e:	bf 00 00 00 00       	mov    $0x0,%edi
  804953:	eb 05                	jmp    80495a <pbuf_alloc+0xb1>
    offset += PBUF_TRANSPORT_HLEN;
  804955:	bf 14 00 00 00       	mov    $0x14,%edi
    offset += PBUF_IP_HLEN;
  80495a:	83 c7 14             	add    $0x14,%edi
    offset += PBUF_LINK_HLEN;
  80495d:	8d 47 0e             	lea    0xe(%edi),%eax
  804960:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804964:	e9 7b ff ff ff       	jmp    8048e4 <pbuf_alloc+0x3b>
  offset = 0;
  804969:	bf 00 00 00 00       	mov    $0x0,%edi
  80496e:	eb ed                	jmp    80495d <pbuf_alloc+0xb4>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804970:	83 ec 04             	sub    $0x4,%esp
  804973:	68 30 19 81 00       	push   $0x811930
  804978:	68 8a 00 00 00       	push   $0x8a
  80497d:	68 c4 18 81 00       	push   $0x8118c4
  804982:	e8 e9 9b 00 00       	call   80e570 <_panic>
  switch (type) {
  804987:	83 fb 03             	cmp    $0x3,%ebx
  80498a:	0f 85 74 01 00 00    	jne    804b04 <pbuf_alloc+0x25b>
      p = memp_malloc(MEMP_PBUF_POOL);
  804990:	83 ec 0c             	sub    $0xc,%esp
  804993:	6a 0d                	push   $0xd
  804995:	e8 a3 fa ff ff       	call   80443d <memp_malloc>
  80499a:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  80499c:	83 c4 10             	add    $0x10,%esp
  80499f:	85 c0                	test   %eax,%eax
  8049a1:	74 a1                	je     804944 <pbuf_alloc+0x9b>
    p->type = type;
  8049a3:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  8049a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  8049ad:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8049b1:	8d 54 07 13          	lea    0x13(%edi,%eax,1),%edx
  8049b5:	83 e2 fc             	and    $0xfffffffc,%edx
  8049b8:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  8049bb:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  8049bf:	0f b7 f6             	movzwl %si,%esi
  8049c2:	83 c0 03             	add    $0x3,%eax
  8049c5:	83 e0 fc             	and    $0xfffffffc,%eax
  8049c8:	89 c1                	mov    %eax,%ecx
  8049ca:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8049cf:	29 c8                	sub    %ecx,%eax
  8049d1:	39 f0                	cmp    %esi,%eax
  8049d3:	0f 4f c6             	cmovg  %esi,%eax
  8049d6:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8049da:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  8049e0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  8049e3:	01 c2                	add    %eax,%edx
  8049e5:	39 d3                	cmp    %edx,%ebx
  8049e7:	72 76                	jb     804a5f <pbuf_alloc+0x1b6>
    p->ref = 1;
  8049e9:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  8049ef:	29 c6                	sub    %eax,%esi
    r = p;
  8049f1:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  8049f3:	85 f6                	test   %esi,%esi
  8049f5:	0f 8e 3f ff ff ff    	jle    80493a <pbuf_alloc+0x91>
      q = memp_malloc(MEMP_PBUF_POOL);
  8049fb:	83 ec 0c             	sub    $0xc,%esp
  8049fe:	6a 0d                	push   $0xd
  804a00:	e8 38 fa ff ff       	call   80443d <memp_malloc>
      if (q == NULL) {
  804a05:	83 c4 10             	add    $0x10,%esp
  804a08:	85 c0                	test   %eax,%eax
  804a0a:	74 6a                	je     804a76 <pbuf_alloc+0x1cd>
      q->type = type;
  804a0c:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804a10:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804a14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804a1a:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804a1c:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804a22:	7f 67                	jg     804a8b <pbuf_alloc+0x1e2>
      q->tot_len = (u16_t)rem_len;
  804a24:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804a28:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804a2d:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804a32:	0f 46 d6             	cmovbe %esi,%edx
  804a35:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804a39:	8d 48 10             	lea    0x10(%eax),%ecx
  804a3c:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804a3f:	f6 c1 03             	test   $0x3,%cl
  804a42:	75 5e                	jne    804aa2 <pbuf_alloc+0x1f9>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a44:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804a48:	03 4f 04             	add    0x4(%edi),%ecx
  804a4b:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804a4e:	72 69                	jb     804ab9 <pbuf_alloc+0x210>
      q->ref = 1;
  804a50:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804a56:	0f b7 d2             	movzwl %dx,%edx
  804a59:	29 d6                	sub    %edx,%esi
      r = q;
  804a5b:	89 c3                	mov    %eax,%ebx
  804a5d:	eb 94                	jmp    8049f3 <pbuf_alloc+0x14a>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a5f:	83 ec 04             	sub    $0x4,%esp
  804a62:	68 48 1a 81 00       	push   $0x811a48
  804a67:	68 a3 00 00 00       	push   $0xa3
  804a6c:	68 c4 18 81 00       	push   $0x8118c4
  804a71:	e8 fa 9a 00 00       	call   80e570 <_panic>
  804a76:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804a78:	83 ec 0c             	sub    $0xc,%esp
  804a7b:	57                   	push   %edi
  804a7c:	e8 62 fd ff ff       	call   8047e3 <pbuf_free>
        return NULL;
  804a81:	83 c4 10             	add    $0x10,%esp
  804a84:	89 df                	mov    %ebx,%edi
  804a86:	e9 b9 fe ff ff       	jmp    804944 <pbuf_alloc+0x9b>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804a8b:	83 ec 04             	sub    $0x4,%esp
  804a8e:	68 4b 19 81 00       	push   $0x81194b
  804a93:	68 bc 00 00 00       	push   $0xbc
  804a98:	68 c4 18 81 00       	push   $0x8118c4
  804a9d:	e8 ce 9a 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804aa2:	83 ec 04             	sub    $0x4,%esp
  804aa5:	68 7c 1a 81 00       	push   $0x811a7c
  804aaa:	68 c2 00 00 00       	push   $0xc2
  804aaf:	68 c4 18 81 00       	push   $0x8118c4
  804ab4:	e8 b7 9a 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804ab9:	83 ec 04             	sub    $0x4,%esp
  804abc:	68 48 1a 81 00       	push   $0x811a48
  804ac1:	68 c5 00 00 00       	push   $0xc5
  804ac6:	68 c4 18 81 00       	push   $0x8118c4
  804acb:	e8 a0 9a 00 00       	call   80e570 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804ad0:	83 ec 0c             	sub    $0xc,%esp
  804ad3:	6a 0c                	push   $0xc
  804ad5:	e8 63 f9 ff ff       	call   80443d <memp_malloc>
  804ada:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804adc:	83 c4 10             	add    $0x10,%esp
  804adf:	85 c0                	test   %eax,%eax
  804ae1:	0f 84 5d fe ff ff    	je     804944 <pbuf_alloc+0x9b>
    p->payload = NULL;
  804ae7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804aee:	66 89 70 08          	mov    %si,0x8(%eax)
  804af2:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804af6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804afc:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804aff:	e9 36 fe ff ff       	jmp    80493a <pbuf_alloc+0x91>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804b04:	83 ec 04             	sub    $0x4,%esp
  804b07:	68 5f 19 81 00       	push   $0x81195f
  804b0c:	68 f1 00 00 00       	push   $0xf1
  804b11:	68 c4 18 81 00       	push   $0x8118c4
  804b16:	e8 55 9a 00 00       	call   80e570 <_panic>

00804b1b <pbuf_realloc>:
{
  804b1b:	55                   	push   %ebp
  804b1c:	89 e5                	mov    %esp,%ebp
  804b1e:	57                   	push   %edi
  804b1f:	56                   	push   %esi
  804b20:	53                   	push   %ebx
  804b21:	83 ec 0c             	sub    $0xc,%esp
  804b24:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b27:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b2a:	85 db                	test   %ebx,%ebx
  804b2c:	74 53                	je     804b81 <pbuf_realloc+0x66>
  804b2e:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b30:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804b34:	77 62                	ja     804b98 <pbuf_realloc+0x7d>
  if (new_len >= p->tot_len) {
  804b36:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804b3a:	66 39 f0             	cmp    %si,%ax
  804b3d:	0f 86 ae 00 00 00    	jbe    804bf1 <pbuf_realloc+0xd6>
  grow = new_len - p->tot_len;
  804b43:	0f b7 ce             	movzwl %si,%ecx
  804b46:	0f b7 f8             	movzwl %ax,%edi
  804b49:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804b4b:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804b4d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804b51:	66 39 f0             	cmp    %si,%ax
  804b54:	73 70                	jae    804bc6 <pbuf_realloc+0xab>
    rem_len -= q->len;
  804b56:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804b58:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804b5e:	7f 4f                	jg     804baf <pbuf_realloc+0x94>
    q->tot_len += (u16_t)grow;
  804b60:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804b64:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804b66:	85 db                	test   %ebx,%ebx
  804b68:	75 e3                	jne    804b4d <pbuf_realloc+0x32>
  804b6a:	83 ec 04             	sub    $0x4,%esp
  804b6d:	68 be 19 81 00       	push   $0x8119be
  804b72:	68 2f 01 00 00       	push   $0x12f
  804b77:	68 c4 18 81 00       	push   $0x8118c4
  804b7c:	e8 ef 99 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b81:	83 ec 04             	sub    $0x4,%esp
  804b84:	68 7a 19 81 00       	push   $0x81197a
  804b89:	68 13 01 00 00       	push   $0x113
  804b8e:	68 c4 18 81 00       	push   $0x8118c4
  804b93:	e8 d8 99 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b98:	83 ec 04             	sub    $0x4,%esp
  804b9b:	68 92 19 81 00       	push   $0x811992
  804ba0:	68 17 01 00 00       	push   $0x117
  804ba5:	68 c4 18 81 00       	push   $0x8118c4
  804baa:	e8 c1 99 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804baf:	83 ec 04             	sub    $0x4,%esp
  804bb2:	68 ad 19 81 00       	push   $0x8119ad
  804bb7:	68 2b 01 00 00       	push   $0x12b
  804bbc:	68 c4 18 81 00       	push   $0x8118c4
  804bc1:	e8 aa 99 00 00       	call   80e570 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804bc6:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804bca:	75 05                	jne    804bd1 <pbuf_realloc+0xb6>
  804bcc:	66 39 f0             	cmp    %si,%ax
  804bcf:	75 28                	jne    804bf9 <pbuf_realloc+0xde>
  q->len = rem_len;
  804bd1:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804bd5:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804bd9:	8b 03                	mov    (%ebx),%eax
  804bdb:	85 c0                	test   %eax,%eax
  804bdd:	74 0c                	je     804beb <pbuf_realloc+0xd0>
    pbuf_free(q->next);
  804bdf:	83 ec 0c             	sub    $0xc,%esp
  804be2:	50                   	push   %eax
  804be3:	e8 fb fb ff ff       	call   8047e3 <pbuf_free>
  804be8:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804beb:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804bf1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804bf4:	5b                   	pop    %ebx
  804bf5:	5e                   	pop    %esi
  804bf6:	5f                   	pop    %edi
  804bf7:	5d                   	pop    %ebp
  804bf8:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804bf9:	8b 43 04             	mov    0x4(%ebx),%eax
  804bfc:	29 d8                	sub    %ebx,%eax
  804bfe:	0f b7 d6             	movzwl %si,%edx
  804c01:	01 d0                	add    %edx,%eax
  804c03:	83 ec 08             	sub    $0x8,%esp
  804c06:	50                   	push   %eax
  804c07:	53                   	push   %ebx
  804c08:	e8 84 f4 ff ff       	call   804091 <mem_realloc>
  804c0d:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804c0f:	83 c4 10             	add    $0x10,%esp
  804c12:	85 c0                	test   %eax,%eax
  804c14:	75 bb                	jne    804bd1 <pbuf_realloc+0xb6>
  804c16:	83 ec 04             	sub    $0x4,%esp
  804c19:	68 d6 19 81 00       	push   $0x8119d6
  804c1e:	68 39 01 00 00       	push   $0x139
  804c23:	68 c4 18 81 00       	push   $0x8118c4
  804c28:	e8 43 99 00 00       	call   80e570 <_panic>

00804c2d <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804c2d:	55                   	push   %ebp
  804c2e:	89 e5                	mov    %esp,%ebp
  804c30:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804c33:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804c38:	85 d2                	test   %edx,%edx
  804c3a:	74 07                	je     804c43 <pbuf_clen+0x16>
    ++len;
  804c3c:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804c3f:	8b 12                	mov    (%edx),%edx
  804c41:	eb f5                	jmp    804c38 <pbuf_clen+0xb>
  }
  return len;
}
  804c43:	5d                   	pop    %ebp
  804c44:	c3                   	ret    

00804c45 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804c45:	55                   	push   %ebp
  804c46:	89 e5                	mov    %esp,%ebp
  804c48:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804c4b:	85 c0                	test   %eax,%eax
  804c4d:	74 05                	je     804c54 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804c4f:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804c54:	5d                   	pop    %ebp
  804c55:	c3                   	ret    

00804c56 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804c56:	55                   	push   %ebp
  804c57:	89 e5                	mov    %esp,%ebp
  804c59:	53                   	push   %ebx
  804c5a:	83 ec 04             	sub    $0x4,%esp
  804c5d:	8b 45 08             	mov    0x8(%ebp),%eax
  804c60:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804c63:	85 c0                	test   %eax,%eax
  804c65:	74 16                	je     804c7d <pbuf_cat+0x27>
  804c67:	85 db                	test   %ebx,%ebx
  804c69:	74 12                	je     804c7d <pbuf_cat+0x27>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804c6b:	8b 10                	mov    (%eax),%edx
  804c6d:	85 d2                	test   %edx,%edx
  804c6f:	74 23                	je     804c94 <pbuf_cat+0x3e>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804c71:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804c75:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804c79:	89 d0                	mov    %edx,%eax
  804c7b:	eb ee                	jmp    804c6b <pbuf_cat+0x15>
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804c7d:	83 ec 04             	sub    $0x4,%esp
  804c80:	68 ac 1a 81 00       	push   $0x811aac
  804c85:	68 42 02 00 00       	push   $0x242
  804c8a:	68 c4 18 81 00       	push   $0x8118c4
  804c8f:	e8 dc 98 00 00       	call   80e570 <_panic>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804c94:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804c98:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804c9c:	75 0f                	jne    804cad <pbuf_cat+0x57>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804c9e:	66 03 53 08          	add    0x8(%ebx),%dx
  804ca2:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804ca6:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804ca8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804cab:	c9                   	leave  
  804cac:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804cad:	83 ec 04             	sub    $0x4,%esp
  804cb0:	68 e4 1a 81 00       	push   $0x811ae4
  804cb5:	68 4a 02 00 00       	push   $0x24a
  804cba:	68 c4 18 81 00       	push   $0x8118c4
  804cbf:	e8 ac 98 00 00       	call   80e570 <_panic>

00804cc4 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804cc4:	55                   	push   %ebp
  804cc5:	89 e5                	mov    %esp,%ebp
  804cc7:	53                   	push   %ebx
  804cc8:	83 ec 0c             	sub    $0xc,%esp
  804ccb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804cce:	53                   	push   %ebx
  804ccf:	ff 75 08             	pushl  0x8(%ebp)
  804cd2:	e8 7f ff ff ff       	call   804c56 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804cd7:	89 1c 24             	mov    %ebx,(%esp)
  804cda:	e8 66 ff ff ff       	call   804c45 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804cdf:	83 c4 10             	add    $0x10,%esp
  804ce2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804ce5:	c9                   	leave  
  804ce6:	c3                   	ret    

00804ce7 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804ce7:	55                   	push   %ebp
  804ce8:	89 e5                	mov    %esp,%ebp
  804cea:	57                   	push   %edi
  804ceb:	56                   	push   %esi
  804cec:	53                   	push   %ebx
  804ced:	83 ec 1c             	sub    $0x1c,%esp
  804cf0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804cf3:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804cf5:	85 f6                	test   %esi,%esi
  804cf7:	74 71                	je     804d6a <pbuf_dechain+0x83>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804cf9:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804cfd:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d01:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804d05:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804d08:	0f b7 d0             	movzwl %ax,%edx
  804d0b:	0f b7 f9             	movzwl %cx,%edi
  804d0e:	29 fa                	sub    %edi,%edx
  804d10:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804d13:	75 3e                	jne    804d53 <pbuf_dechain+0x6c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804d15:	29 c8                	sub    %ecx,%eax
  804d17:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804d1b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804d21:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d25:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804d29:	83 ec 0c             	sub    $0xc,%esp
  804d2c:	56                   	push   %esi
  804d2d:	e8 b1 fa ff ff       	call   8047e3 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d32:	83 c4 10             	add    $0x10,%esp
  804d35:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d39:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804d3d:	75 35                	jne    804d74 <pbuf_dechain+0x8d>
  return ((tail_gone > 0) ? NULL : q);
  804d3f:	84 c0                	test   %al,%al
  804d41:	b8 00 00 00 00       	mov    $0x0,%eax
  804d46:	0f 45 f0             	cmovne %eax,%esi
}
  804d49:	89 f0                	mov    %esi,%eax
  804d4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804d4e:	5b                   	pop    %ebx
  804d4f:	5e                   	pop    %esi
  804d50:	5f                   	pop    %edi
  804d51:	5d                   	pop    %ebp
  804d52:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804d53:	83 ec 04             	sub    $0x4,%esp
  804d56:	68 14 1b 81 00       	push   $0x811b14
  804d5b:	68 80 02 00 00       	push   $0x280
  804d60:	68 c4 18 81 00       	push   $0x8118c4
  804d65:	e8 06 98 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d6a:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d6e:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804d72:	74 d5                	je     804d49 <pbuf_dechain+0x62>
  804d74:	83 ec 04             	sub    $0x4,%esp
  804d77:	68 f1 19 81 00       	push   $0x8119f1
  804d7c:	68 91 02 00 00       	push   $0x291
  804d81:	68 c4 18 81 00       	push   $0x8118c4
  804d86:	e8 e5 97 00 00       	call   80e570 <_panic>

00804d8b <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804d8b:	55                   	push   %ebp
  804d8c:	89 e5                	mov    %esp,%ebp
  804d8e:	57                   	push   %edi
  804d8f:	56                   	push   %esi
  804d90:	53                   	push   %ebx
  804d91:	83 ec 1c             	sub    $0x1c,%esp
  804d94:	8b 7d 08             	mov    0x8(%ebp),%edi
  804d97:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804d9a:	85 ff                	test   %edi,%edi
  804d9c:	74 22                	je     804dc0 <pbuf_copy+0x35>
  804d9e:	85 db                	test   %ebx,%ebx
  804da0:	74 1e                	je     804dc0 <pbuf_copy+0x35>
  804da2:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804da6:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804daa:	72 14                	jb     804dc0 <pbuf_copy+0x35>
  u16_t offset_to=0, offset_from=0, len;
  804dac:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804db2:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804db8:	89 7d 08             	mov    %edi,0x8(%ebp)
  804dbb:	e9 92 00 00 00       	jmp    804e52 <pbuf_copy+0xc7>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804dc0:	83 ec 04             	sub    $0x4,%esp
  804dc3:	68 38 1b 81 00       	push   $0x811b38
  804dc8:	68 b1 02 00 00       	push   $0x2b1
  804dcd:	68 c4 18 81 00       	push   $0x8118c4
  804dd2:	e8 99 97 00 00       	call   80e570 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804dd7:	83 ec 04             	sub    $0x4,%esp
  804dda:	68 06 1a 81 00       	push   $0x811a06
  804ddf:	68 c2 02 00 00       	push   $0x2c2
  804de4:	68 c4 18 81 00       	push   $0x8118c4
  804de9:	e8 82 97 00 00       	call   80e570 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804dee:	8b 45 08             	mov    0x8(%ebp),%eax
  804df1:	8b 00                	mov    (%eax),%eax
  804df3:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  804df6:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804dfc:	e9 c7 00 00 00       	jmp    804ec8 <pbuf_copy+0x13d>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804e01:	83 ec 04             	sub    $0x4,%esp
  804e04:	68 1d 1a 81 00       	push   $0x811a1d
  804e09:	68 c8 02 00 00       	push   $0x2c8
  804e0e:	68 c4 18 81 00       	push   $0x8118c4
  804e13:	e8 58 97 00 00       	call   80e570 <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804e18:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804e1e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e22:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804e26:	0f 84 cf 00 00 00    	je     804efb <pbuf_copy+0x170>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804e2c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804e30:	0f 84 05 01 00 00    	je     804f3b <pbuf_copy+0x1b0>
  804e36:	8b 45 08             	mov    0x8(%ebp),%eax
  804e39:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804e3d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804e40:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  804e44:	0f 84 d1 00 00 00    	je     804f1b <pbuf_copy+0x190>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804e4a:	85 db                	test   %ebx,%ebx
  804e4c:	0f 84 00 01 00 00    	je     804f52 <pbuf_copy+0x1c7>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804e52:	8b 45 08             	mov    0x8(%ebp),%eax
  804e55:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  804e59:	0f b7 ce             	movzwl %si,%ecx
  804e5c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804e60:	29 c1                	sub    %eax,%ecx
  804e62:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804e66:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804e6a:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  804e6c:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  804e70:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
  804e74:	89 f8                	mov    %edi,%eax
  804e76:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804e7a:	29 fe                	sub    %edi,%esi
  804e7c:	39 d1                	cmp    %edx,%ecx
  804e7e:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804e81:	83 ec 04             	sub    $0x4,%esp
  804e84:	0f b7 c6             	movzwl %si,%eax
  804e87:	50                   	push   %eax
  804e88:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804e8c:	03 43 04             	add    0x4(%ebx),%eax
  804e8f:	50                   	push   %eax
  804e90:	0f b7 c7             	movzwl %di,%eax
  804e93:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804e96:	03 41 04             	add    0x4(%ecx),%eax
  804e99:	50                   	push   %eax
  804e9a:	e8 78 9f 00 00       	call   80ee17 <memcpy>
    offset_to += len;
  804e9f:	89 fa                	mov    %edi,%edx
  804ea1:	01 f2                	add    %esi,%edx
  804ea3:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  804ea7:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804eab:	8b 45 08             	mov    0x8(%ebp),%eax
  804eae:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  804eb2:	83 c4 10             	add    $0x10,%esp
  804eb5:	66 39 d0             	cmp    %dx,%ax
  804eb8:	0f 82 19 ff ff ff    	jb     804dd7 <pbuf_copy+0x4c>
    if (offset_to == p_to->len) {
  804ebe:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  804ec2:	0f 84 26 ff ff ff    	je     804dee <pbuf_copy+0x63>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804ec8:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804ecc:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804ed0:	0f 82 2b ff ff ff    	jb     804e01 <pbuf_copy+0x76>
    if (offset_from >= p_from->len) {
  804ed6:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804eda:	0f 85 3e ff ff ff    	jne    804e1e <pbuf_copy+0x93>
      p_from = p_from->next;
  804ee0:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804ee2:	85 db                	test   %ebx,%ebx
  804ee4:	0f 85 2e ff ff ff    	jne    804e18 <pbuf_copy+0x8d>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804eee:	74 62                	je     804f52 <pbuf_copy+0x1c7>
      offset_from = 0;
  804ef0:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804ef6:	e9 3b ff ff ff       	jmp    804e36 <pbuf_copy+0xab>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804efb:	83 3b 00             	cmpl   $0x0,(%ebx)
  804efe:	0f 84 28 ff ff ff    	je     804e2c <pbuf_copy+0xa1>
  804f04:	83 ec 04             	sub    $0x4,%esp
  804f07:	68 68 1b 81 00       	push   $0x811b68
  804f0c:	68 d2 02 00 00       	push   $0x2d2
  804f11:	68 c4 18 81 00       	push   $0x8118c4
  804f16:	e8 55 96 00 00       	call   80e570 <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804f1b:	83 39 00             	cmpl   $0x0,(%ecx)
  804f1e:	0f 84 26 ff ff ff    	je     804e4a <pbuf_copy+0xbf>
  804f24:	83 ec 04             	sub    $0x4,%esp
  804f27:	68 68 1b 81 00       	push   $0x811b68
  804f2c:	68 d7 02 00 00       	push   $0x2d7
  804f31:	68 c4 18 81 00       	push   $0x8118c4
  804f36:	e8 35 96 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804f3b:	83 ec 04             	sub    $0x4,%esp
  804f3e:	68 38 1a 81 00       	push   $0x811a38
  804f43:	68 b6 02 00 00       	push   $0x2b6
  804f48:	68 c4 18 81 00       	push   $0x8118c4
  804f4d:	e8 1e 96 00 00       	call   80e570 <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804f52:	b8 00 00 00 00       	mov    $0x0,%eax
  804f57:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f5a:	5b                   	pop    %ebx
  804f5b:	5e                   	pop    %esi
  804f5c:	5f                   	pop    %edi
  804f5d:	5d                   	pop    %ebp
  804f5e:	c3                   	ret    

00804f5f <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804f5f:	55                   	push   %ebp
  804f60:	89 e5                	mov    %esp,%ebp
  804f62:	57                   	push   %edi
  804f63:	56                   	push   %esi
  804f64:	53                   	push   %ebx
  804f65:	83 ec 1c             	sub    $0x1c,%esp
  804f68:	8b 75 08             	mov    0x8(%ebp),%esi
  804f6b:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804f6f:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804f73:	85 f6                	test   %esi,%esi
  804f75:	74 0e                	je     804f85 <pbuf_copy_partial+0x26>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804f77:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804f7b:	74 1f                	je     804f9c <pbuf_copy_partial+0x3d>

  left = 0;
  804f7d:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804f83:	eb 65                	jmp    804fea <pbuf_copy_partial+0x8b>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804f85:	83 ec 04             	sub    $0x4,%esp
  804f88:	68 94 1b 81 00       	push   $0x811b94
  804f8d:	68 ef 02 00 00       	push   $0x2ef
  804f92:	68 c4 18 81 00       	push   $0x8118c4
  804f97:	e8 d4 95 00 00       	call   80e570 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804f9c:	83 ec 04             	sub    $0x4,%esp
  804f9f:	68 b8 1b 81 00       	push   $0x811bb8
  804fa4:	68 f0 02 00 00       	push   $0x2f0
  804fa9:	68 c4 18 81 00       	push   $0x8118c4
  804fae:	e8 bd 95 00 00       	call   80e570 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  804fb3:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  804fb7:	29 c3                	sub    %eax,%ebx
  804fb9:	66 39 df             	cmp    %bx,%di
  804fbc:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  804fbf:	83 ec 04             	sub    $0x4,%esp
  804fc2:	0f b7 d3             	movzwl %bx,%edx
  804fc5:	52                   	push   %edx
  804fc6:	0f b7 c0             	movzwl %ax,%eax
  804fc9:	03 46 04             	add    0x4(%esi),%eax
  804fcc:	50                   	push   %eax
  804fcd:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804fd1:	03 45 0c             	add    0xc(%ebp),%eax
  804fd4:	50                   	push   %eax
  804fd5:	e8 3d 9e 00 00       	call   80ee17 <memcpy>
      copied_total += buf_copy_len;
  804fda:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      left += buf_copy_len;
      len -= buf_copy_len;
  804fde:	29 df                	sub    %ebx,%edi
  804fe0:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  804fe3:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  804fe8:	8b 36                	mov    (%esi),%esi
  804fea:	66 85 ff             	test   %di,%di
  804fed:	74 16                	je     805005 <pbuf_copy_partial+0xa6>
  804fef:	85 f6                	test   %esi,%esi
  804ff1:	74 12                	je     805005 <pbuf_copy_partial+0xa6>
    if ((offset != 0) && (offset >= p->len)) {
  804ff3:	66 85 c0             	test   %ax,%ax
  804ff6:	74 bb                	je     804fb3 <pbuf_copy_partial+0x54>
  804ff8:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  804ffc:	66 39 c2             	cmp    %ax,%dx
  804fff:	77 b2                	ja     804fb3 <pbuf_copy_partial+0x54>
      offset -= p->len;
  805001:	29 d0                	sub    %edx,%eax
  805003:	eb e3                	jmp    804fe8 <pbuf_copy_partial+0x89>
    }
  }
  return copied_total;
}
  805005:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805009:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80500c:	5b                   	pop    %ebx
  80500d:	5e                   	pop    %esi
  80500e:	5f                   	pop    %edi
  80500f:	5d                   	pop    %ebp
  805010:	c3                   	ret    

00805011 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805011:	55                   	push   %ebp
  805012:	89 e5                	mov    %esp,%ebp
  805014:	83 ec 14             	sub    $0x14,%esp
  805017:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80501a:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80501f:	8b 40 04             	mov    0x4(%eax),%eax
  805022:	ff 30                	pushl  (%eax)
  805024:	e8 35 50 00 00       	call   80a05e <sys_sem_signal>
}
  805029:	83 c4 10             	add    $0x10,%esp
  80502c:	c9                   	leave  
  80502d:	c3                   	ret    

0080502e <sys_mbox_fetch>:
{
  80502e:	55                   	push   %ebp
  80502f:	89 e5                	mov    %esp,%ebp
  805031:	57                   	push   %edi
  805032:	56                   	push   %esi
  805033:	53                   	push   %ebx
  805034:	83 ec 0c             	sub    $0xc,%esp
  805037:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80503a:	eb 40                	jmp    80507c <sys_mbox_fetch+0x4e>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80503c:	83 ec 04             	sub    $0x4,%esp
  80503f:	6a 00                	push   $0x0
  805041:	57                   	push   %edi
  805042:	ff 75 08             	pushl  0x8(%ebp)
  805045:	e8 89 52 00 00       	call   80a2d3 <sys_arch_mbox_fetch>
  80504a:	83 c4 10             	add    $0x10,%esp
}
  80504d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805050:	5b                   	pop    %ebx
  805051:	5e                   	pop    %esi
  805052:	5f                   	pop    %edi
  805053:	5d                   	pop    %ebp
  805054:	c3                   	ret    
      tmptimeout = timeouts->next;
  805055:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805057:	8b 10                	mov    (%eax),%edx
  805059:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  80505b:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80505e:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805061:	83 ec 08             	sub    $0x8,%esp
  805064:	50                   	push   %eax
  805065:	6a 0b                	push   $0xb
  805067:	e8 27 f4 ff ff       	call   804493 <memp_free>
      if (h != NULL) {
  80506c:	83 c4 10             	add    $0x10,%esp
  80506f:	85 db                	test   %ebx,%ebx
  805071:	74 09                	je     80507c <sys_mbox_fetch+0x4e>
        h(arg);
  805073:	83 ec 0c             	sub    $0xc,%esp
  805076:	56                   	push   %esi
  805077:	ff d3                	call   *%ebx
  805079:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  80507c:	e8 e7 53 00 00       	call   80a468 <sys_arch_timeouts>
  805081:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805083:	85 c0                	test   %eax,%eax
  805085:	74 b5                	je     80503c <sys_mbox_fetch+0xe>
  805087:	8b 00                	mov    (%eax),%eax
  805089:	85 c0                	test   %eax,%eax
  80508b:	74 af                	je     80503c <sys_mbox_fetch+0xe>
    if (timeouts->next->time > 0) {
  80508d:	8b 40 04             	mov    0x4(%eax),%eax
  805090:	85 c0                	test   %eax,%eax
  805092:	74 c1                	je     805055 <sys_mbox_fetch+0x27>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  805094:	83 ec 04             	sub    $0x4,%esp
  805097:	50                   	push   %eax
  805098:	57                   	push   %edi
  805099:	ff 75 08             	pushl  0x8(%ebp)
  80509c:	e8 32 52 00 00       	call   80a2d3 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  8050a1:	83 c4 10             	add    $0x10,%esp
  8050a4:	83 f8 ff             	cmp    $0xffffffff,%eax
  8050a7:	74 ac                	je     805055 <sys_mbox_fetch+0x27>
      if (time_needed < timeouts->next->time) {
  8050a9:	8b 1b                	mov    (%ebx),%ebx
  8050ab:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  8050ae:	89 ca                	mov    %ecx,%edx
  8050b0:	29 c2                	sub    %eax,%edx
  8050b2:	39 c1                	cmp    %eax,%ecx
  8050b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8050b9:	0f 46 d0             	cmovbe %eax,%edx
  8050bc:	89 53 04             	mov    %edx,0x4(%ebx)
  8050bf:	eb 8c                	jmp    80504d <sys_mbox_fetch+0x1f>

008050c1 <sys_sem_wait>:
{
  8050c1:	55                   	push   %ebp
  8050c2:	89 e5                	mov    %esp,%ebp
  8050c4:	57                   	push   %edi
  8050c5:	56                   	push   %esi
  8050c6:	53                   	push   %ebx
  8050c7:	83 ec 0c             	sub    $0xc,%esp
  8050ca:	8b 75 08             	mov    0x8(%ebp),%esi
  8050cd:	eb 3d                	jmp    80510c <sys_sem_wait+0x4b>
    sys_arch_sem_wait(sem, 0);
  8050cf:	83 ec 08             	sub    $0x8,%esp
  8050d2:	6a 00                	push   $0x0
  8050d4:	56                   	push   %esi
  8050d5:	e8 f4 4f 00 00       	call   80a0ce <sys_arch_sem_wait>
  8050da:	83 c4 10             	add    $0x10,%esp
}
  8050dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050e0:	5b                   	pop    %ebx
  8050e1:	5e                   	pop    %esi
  8050e2:	5f                   	pop    %edi
  8050e3:	5d                   	pop    %ebp
  8050e4:	c3                   	ret    
      tmptimeout = timeouts->next;
  8050e5:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8050e7:	8b 10                	mov    (%eax),%edx
  8050e9:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8050eb:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8050ee:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8050f1:	83 ec 08             	sub    $0x8,%esp
  8050f4:	50                   	push   %eax
  8050f5:	6a 0b                	push   $0xb
  8050f7:	e8 97 f3 ff ff       	call   804493 <memp_free>
      if (h != NULL) {
  8050fc:	83 c4 10             	add    $0x10,%esp
  8050ff:	85 db                	test   %ebx,%ebx
  805101:	74 09                	je     80510c <sys_sem_wait+0x4b>
        h(arg);
  805103:	83 ec 0c             	sub    $0xc,%esp
  805106:	57                   	push   %edi
  805107:	ff d3                	call   *%ebx
  805109:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  80510c:	e8 57 53 00 00       	call   80a468 <sys_arch_timeouts>
  805111:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805113:	85 c0                	test   %eax,%eax
  805115:	74 b8                	je     8050cf <sys_sem_wait+0xe>
  805117:	8b 00                	mov    (%eax),%eax
  805119:	85 c0                	test   %eax,%eax
  80511b:	74 b2                	je     8050cf <sys_sem_wait+0xe>
    if (timeouts->next->time > 0) {
  80511d:	8b 40 04             	mov    0x4(%eax),%eax
  805120:	85 c0                	test   %eax,%eax
  805122:	74 c1                	je     8050e5 <sys_sem_wait+0x24>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805124:	83 ec 08             	sub    $0x8,%esp
  805127:	50                   	push   %eax
  805128:	56                   	push   %esi
  805129:	e8 a0 4f 00 00       	call   80a0ce <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  80512e:	83 c4 10             	add    $0x10,%esp
  805131:	83 f8 ff             	cmp    $0xffffffff,%eax
  805134:	74 af                	je     8050e5 <sys_sem_wait+0x24>
      if (time_needed < timeouts->next->time) {
  805136:	8b 1b                	mov    (%ebx),%ebx
  805138:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  80513b:	89 ca                	mov    %ecx,%edx
  80513d:	29 c2                	sub    %eax,%edx
  80513f:	39 c1                	cmp    %eax,%ecx
  805141:	b8 00 00 00 00       	mov    $0x0,%eax
  805146:	0f 46 d0             	cmovbe %eax,%edx
  805149:	89 53 04             	mov    %edx,0x4(%ebx)
  80514c:	eb 8f                	jmp    8050dd <sys_sem_wait+0x1c>

0080514e <sys_timeout>:
{
  80514e:	55                   	push   %ebp
  80514f:	89 e5                	mov    %esp,%ebp
  805151:	57                   	push   %edi
  805152:	56                   	push   %esi
  805153:	53                   	push   %ebx
  805154:	83 ec 28             	sub    $0x28,%esp
  805157:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80515a:	6a 0b                	push   $0xb
  80515c:	e8 dc f2 ff ff       	call   80443d <memp_malloc>
  if (timeout == NULL) {
  805161:	83 c4 10             	add    $0x10,%esp
  805164:	85 c0                	test   %eax,%eax
  805166:	74 40                	je     8051a8 <sys_timeout+0x5a>
  805168:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  80516a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805170:	8b 45 0c             	mov    0xc(%ebp),%eax
  805173:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  805176:	8b 45 10             	mov    0x10(%ebp),%eax
  805179:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  80517c:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  80517f:	e8 e4 52 00 00       	call   80a468 <sys_arch_timeouts>
  if (timeouts == NULL) {
  805184:	85 c0                	test   %eax,%eax
  805186:	74 37                	je     8051bf <sys_timeout+0x71>
  if (timeouts->next == NULL) {
  805188:	8b 10                	mov    (%eax),%edx
  80518a:	85 d2                	test   %edx,%edx
  80518c:	74 48                	je     8051d6 <sys_timeout+0x88>
  if (timeouts->next->time > msecs) {
  80518e:	8b 4a 04             	mov    0x4(%edx),%ecx
  805191:	39 f1                	cmp    %esi,%ecx
  805193:	76 47                	jbe    8051dc <sys_timeout+0x8e>
    timeouts->next->time -= msecs;
  805195:	29 f1                	sub    %esi,%ecx
  805197:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  80519a:	8b 10                	mov    (%eax),%edx
  80519c:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  80519e:	89 18                	mov    %ebx,(%eax)
}
  8051a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8051a3:	5b                   	pop    %ebx
  8051a4:	5e                   	pop    %esi
  8051a5:	5f                   	pop    %edi
  8051a6:	5d                   	pop    %ebp
  8051a7:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8051a8:	83 ec 04             	sub    $0x4,%esp
  8051ab:	68 dd 1b 81 00       	push   $0x811bdd
  8051b0:	68 c3 00 00 00       	push   $0xc3
  8051b5:	68 fa 1b 81 00       	push   $0x811bfa
  8051ba:	e8 b1 93 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8051bf:	83 ec 04             	sub    $0x4,%esp
  8051c2:	68 0e 1c 81 00       	push   $0x811c0e
  8051c7:	68 d1 00 00 00       	push   $0xd1
  8051cc:	68 fa 1b 81 00       	push   $0x811bfa
  8051d1:	e8 9a 93 00 00       	call   80e570 <_panic>
    timeouts->next = timeout;
  8051d6:	89 18                	mov    %ebx,(%eax)
    return;
  8051d8:	eb c6                	jmp    8051a0 <sys_timeout+0x52>
      if (t->next == NULL || t->next->time > timeout->time) {
  8051da:	89 c2                	mov    %eax,%edx
      timeout->time -= t->time;
  8051dc:	8b 7b 04             	mov    0x4(%ebx),%edi
  8051df:	8b 42 04             	mov    0x4(%edx),%eax
  8051e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8051e5:	89 f9                	mov    %edi,%ecx
  8051e7:	29 c1                	sub    %eax,%ecx
  8051e9:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  8051ec:	8b 02                	mov    (%edx),%eax
  8051ee:	85 c0                	test   %eax,%eax
  8051f0:	74 17                	je     805209 <sys_timeout+0xbb>
  8051f2:	8b 70 04             	mov    0x4(%eax),%esi
  8051f5:	89 75 e0             	mov    %esi,-0x20(%ebp)
  8051f8:	39 f1                	cmp    %esi,%ecx
  8051fa:	73 de                	jae    8051da <sys_timeout+0x8c>
  8051fc:	8b 75 e4             	mov    -0x1c(%ebp),%esi
          t->next->time -= timeout->time;
  8051ff:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  805202:	29 f9                	sub    %edi,%ecx
  805204:	01 ce                	add    %ecx,%esi
  805206:	89 70 04             	mov    %esi,0x4(%eax)
        timeout->next = t->next;
  805209:	8b 02                	mov    (%edx),%eax
  80520b:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  80520d:	89 1a                	mov    %ebx,(%edx)
        break;
  80520f:	eb 8f                	jmp    8051a0 <sys_timeout+0x52>

00805211 <sys_untimeout>:
{
  805211:	55                   	push   %ebp
  805212:	89 e5                	mov    %esp,%ebp
  805214:	57                   	push   %edi
  805215:	56                   	push   %esi
  805216:	53                   	push   %ebx
  805217:	83 ec 0c             	sub    $0xc,%esp
  80521a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80521d:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  805220:	e8 43 52 00 00       	call   80a468 <sys_arch_timeouts>
  if (timeouts == NULL) {
  805225:	85 c0                	test   %eax,%eax
  805227:	74 0d                	je     805236 <sys_untimeout+0x25>
  if (timeouts->next == NULL) {
  805229:	8b 10                	mov    (%eax),%edx
  80522b:	85 d2                	test   %edx,%edx
  80522d:	74 5a                	je     805289 <sys_untimeout+0x78>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80522f:	bf 00 00 00 00       	mov    $0x0,%edi
  805234:	eb 27                	jmp    80525d <sys_untimeout+0x4c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805236:	83 ec 04             	sub    $0x4,%esp
  805239:	68 2c 1c 81 00       	push   $0x811c2c
  80523e:	68 00 01 00 00       	push   $0x100
  805243:	68 fa 1b 81 00       	push   $0x811bfa
  805248:	e8 23 93 00 00       	call   80e570 <_panic>
        timeouts->next = t->next;
  80524d:	8b 0a                	mov    (%edx),%ecx
  80524f:	89 08                	mov    %ecx,(%eax)
  805251:	eb 1c                	jmp    80526f <sys_untimeout+0x5e>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805253:	8b 0a                	mov    (%edx),%ecx
  805255:	89 d7                	mov    %edx,%edi
  805257:	85 c9                	test   %ecx,%ecx
  805259:	74 2e                	je     805289 <sys_untimeout+0x78>
  80525b:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80525d:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805260:	75 f1                	jne    805253 <sys_untimeout+0x42>
  805262:	39 72 0c             	cmp    %esi,0xc(%edx)
  805265:	75 ec                	jne    805253 <sys_untimeout+0x42>
      if (prev_t == NULL)
  805267:	85 ff                	test   %edi,%edi
  805269:	74 e2                	je     80524d <sys_untimeout+0x3c>
        prev_t->next = t->next;
  80526b:	8b 02                	mov    (%edx),%eax
  80526d:	89 07                	mov    %eax,(%edi)
      if (t->next != NULL)
  80526f:	8b 02                	mov    (%edx),%eax
  805271:	85 c0                	test   %eax,%eax
  805273:	74 06                	je     80527b <sys_untimeout+0x6a>
        t->next->time += t->time;
  805275:	8b 4a 04             	mov    0x4(%edx),%ecx
  805278:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80527b:	83 ec 08             	sub    $0x8,%esp
  80527e:	52                   	push   %edx
  80527f:	6a 0b                	push   $0xb
  805281:	e8 0d f2 ff ff       	call   804493 <memp_free>
      return;
  805286:	83 c4 10             	add    $0x10,%esp
}
  805289:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80528c:	5b                   	pop    %ebx
  80528d:	5e                   	pop    %esi
  80528e:	5f                   	pop    %edi
  80528f:	5d                   	pop    %ebp
  805290:	c3                   	ret    

00805291 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  805291:	55                   	push   %ebp
  805292:	89 e5                	mov    %esp,%ebp
  805294:	83 ec 18             	sub    $0x18,%esp
  805297:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80529a:	8d 4d 08             	lea    0x8(%ebp),%ecx
  80529d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8052a0:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8052a6:	85 c0                	test   %eax,%eax
  8052a8:	75 1c                	jne    8052c6 <sys_sem_wait_timeout+0x35>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  8052aa:	83 ec 0c             	sub    $0xc,%esp
  8052ad:	ff 75 08             	pushl  0x8(%ebp)
  8052b0:	e8 0c fe ff ff       	call   8050c1 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052b5:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8052b8:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  8052bd:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8052c2:	74 19                	je     8052dd <sys_sem_wait_timeout+0x4c>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  8052c4:	c9                   	leave  
  8052c5:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8052c6:	83 ec 04             	sub    $0x4,%esp
  8052c9:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8052cc:	52                   	push   %edx
  8052cd:	68 11 50 80 00       	push   $0x805011
  8052d2:	50                   	push   %eax
  8052d3:	e8 76 fe ff ff       	call   80514e <sys_timeout>
  8052d8:	83 c4 10             	add    $0x10,%esp
  8052db:	eb cd                	jmp    8052aa <sys_sem_wait_timeout+0x19>
    sys_untimeout(sswt_handler, &sswt_cb);
  8052dd:	83 ec 08             	sub    $0x8,%esp
  8052e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8052e3:	50                   	push   %eax
  8052e4:	68 11 50 80 00       	push   $0x805011
  8052e9:	e8 23 ff ff ff       	call   805211 <sys_untimeout>
    return 1;
  8052ee:	83 c4 10             	add    $0x10,%esp
  8052f1:	b8 01 00 00 00       	mov    $0x1,%eax
  8052f6:	eb cc                	jmp    8052c4 <sys_sem_wait_timeout+0x33>

008052f8 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  8052f8:	55                   	push   %ebp
  8052f9:	89 e5                	mov    %esp,%ebp
  8052fb:	53                   	push   %ebx
  8052fc:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8052ff:	6a 00                	push   $0x0
  805301:	e8 9b 4a 00 00       	call   809da1 <sys_sem_new>
  805306:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805308:	83 c4 08             	add    $0x8,%esp
  80530b:	ff 75 08             	pushl  0x8(%ebp)
  80530e:	50                   	push   %eax
  80530f:	e8 7d ff ff ff       	call   805291 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805314:	89 1c 24             	mov    %ebx,(%esp)
  805317:	e8 06 4b 00 00       	call   809e22 <sys_sem_free>
}
  80531c:	83 c4 10             	add    $0x10,%esp
  80531f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805322:	c9                   	leave  
  805323:	c3                   	ret    

00805324 <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805324:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  805329:	c3                   	ret    

0080532a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80532a:	55                   	push   %ebp
  80532b:	89 e5                	mov    %esp,%ebp
  80532d:	57                   	push   %edi
  80532e:	56                   	push   %esi
  80532f:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805330:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805336:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80533c:	8b 3d 44 b2 b3 00    	mov    0xb3b244,%edi
  805342:	0f b7 05 0c 40 81 00 	movzwl 0x81400c,%eax
    port = TCP_LOCAL_PORT_RANGE_START;
  805349:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80534e:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  805352:	0f 48 c1             	cmovs  %ecx,%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805355:	89 da                	mov    %ebx,%edx
  805357:	85 d2                	test   %edx,%edx
  805359:	74 0b                	je     805366 <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  80535b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80535f:	74 ed                	je     80534e <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805361:	8b 52 0c             	mov    0xc(%edx),%edx
  805364:	eb f1                	jmp    805357 <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805366:	89 f2                	mov    %esi,%edx
  805368:	85 d2                	test   %edx,%edx
  80536a:	74 0b                	je     805377 <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  80536c:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805370:	74 dc                	je     80534e <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805372:	8b 52 0c             	mov    0xc(%edx),%edx
  805375:	eb f1                	jmp    805368 <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805377:	89 fa                	mov    %edi,%edx
  805379:	85 d2                	test   %edx,%edx
  80537b:	74 0b                	je     805388 <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  80537d:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805381:	74 cb                	je     80534e <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805383:	8b 52 0c             	mov    0xc(%edx),%edx
  805386:	eb f1                	jmp    805379 <tcp_new_port+0x4f>
  805388:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
      goto again;
    }
  }
  return port;
}
  80538e:	5b                   	pop    %ebx
  80538f:	5e                   	pop    %esi
  805390:	5f                   	pop    %edi
  805391:	5d                   	pop    %ebp
  805392:	c3                   	ret    

00805393 <tcp_bind>:
{
  805393:	55                   	push   %ebp
  805394:	89 e5                	mov    %esp,%ebp
  805396:	57                   	push   %edi
  805397:	56                   	push   %esi
  805398:	53                   	push   %ebx
  805399:	83 ec 0c             	sub    $0xc,%esp
  80539c:	8b 75 08             	mov    0x8(%ebp),%esi
  80539f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8053a2:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8053a5:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8053a9:	75 0f                	jne    8053ba <tcp_bind+0x27>
  8053ab:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  8053ad:	66 85 d2             	test   %dx,%dx
  8053b0:	74 1f                	je     8053d1 <tcp_bind+0x3e>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8053b2:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  8053b8:	eb 21                	jmp    8053db <tcp_bind+0x48>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8053ba:	83 ec 04             	sub    $0x4,%esp
  8053bd:	68 4c 1c 81 00       	push   $0x811c4c
  8053c2:	68 05 01 00 00       	push   $0x105
  8053c7:	68 2e 1e 81 00       	push   $0x811e2e
  8053cc:	e8 9f 91 00 00       	call   80e570 <_panic>
    port = tcp_new_port();
  8053d1:	e8 54 ff ff ff       	call   80532a <tcp_new_port>
  8053d6:	eb da                	jmp    8053b2 <tcp_bind+0x1f>
      cpcb != NULL; cpcb = cpcb->next) {
  8053d8:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8053db:	85 d2                	test   %edx,%edx
  8053dd:	74 2c                	je     80540b <tcp_bind+0x78>
    if (cpcb->local_port == port) {
  8053df:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8053e3:	75 f3                	jne    8053d8 <tcp_bind+0x45>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8053e5:	8b 0a                	mov    (%edx),%ecx
  8053e7:	85 db                	test   %ebx,%ebx
  8053e9:	0f 84 d4 00 00 00    	je     8054c3 <tcp_bind+0x130>
  8053ef:	85 c9                	test   %ecx,%ecx
  8053f1:	0f 84 cc 00 00 00    	je     8054c3 <tcp_bind+0x130>
          ip_addr_isany(ipaddr) ||
  8053f7:	8b 3b                	mov    (%ebx),%edi
  8053f9:	39 f9                	cmp    %edi,%ecx
  8053fb:	74 04                	je     805401 <tcp_bind+0x6e>
  8053fd:	85 ff                	test   %edi,%edi
  8053ff:	75 d7                	jne    8053d8 <tcp_bind+0x45>
        return ERR_USE;
  805401:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805406:	e9 bd 00 00 00       	jmp    8054c8 <tcp_bind+0x135>
  for(cpcb = tcp_active_pcbs;
  80540b:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  805411:	eb 03                	jmp    805416 <tcp_bind+0x83>
      cpcb != NULL; cpcb = cpcb->next) {
  805413:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  805416:	85 d2                	test   %edx,%edx
  805418:	74 2c                	je     805446 <tcp_bind+0xb3>
    if (cpcb->local_port == port) {
  80541a:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80541e:	75 f3                	jne    805413 <tcp_bind+0x80>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805420:	8b 0a                	mov    (%edx),%ecx
  805422:	85 db                	test   %ebx,%ebx
  805424:	0f 84 a6 00 00 00    	je     8054d0 <tcp_bind+0x13d>
  80542a:	85 c9                	test   %ecx,%ecx
  80542c:	0f 84 9e 00 00 00    	je     8054d0 <tcp_bind+0x13d>
          ip_addr_isany(ipaddr) ||
  805432:	8b 3b                	mov    (%ebx),%edi
  805434:	39 f9                	cmp    %edi,%ecx
  805436:	74 04                	je     80543c <tcp_bind+0xa9>
  805438:	85 ff                	test   %edi,%edi
  80543a:	75 d7                	jne    805413 <tcp_bind+0x80>
        return ERR_USE;
  80543c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805441:	e9 82 00 00 00       	jmp    8054c8 <tcp_bind+0x135>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805446:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  80544c:	eb 03                	jmp    805451 <tcp_bind+0xbe>
  80544e:	8b 52 0c             	mov    0xc(%edx),%edx
  805451:	85 d2                	test   %edx,%edx
  805453:	74 21                	je     805476 <tcp_bind+0xe3>
    if (cpcb->local_port == port) {
  805455:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805459:	75 f3                	jne    80544e <tcp_bind+0xbb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80545b:	8b 0a                	mov    (%edx),%ecx
  80545d:	85 db                	test   %ebx,%ebx
  80545f:	74 76                	je     8054d7 <tcp_bind+0x144>
  805461:	85 c9                	test   %ecx,%ecx
  805463:	74 72                	je     8054d7 <tcp_bind+0x144>
          ip_addr_isany(ipaddr) ||
  805465:	8b 3b                	mov    (%ebx),%edi
  805467:	39 f9                	cmp    %edi,%ecx
  805469:	74 04                	je     80546f <tcp_bind+0xdc>
  80546b:	85 ff                	test   %edi,%edi
  80546d:	75 df                	jne    80544e <tcp_bind+0xbb>
        return ERR_USE;
  80546f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805474:	eb 52                	jmp    8054c8 <tcp_bind+0x135>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805476:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  80547c:	eb 03                	jmp    805481 <tcp_bind+0xee>
  80547e:	8b 52 0c             	mov    0xc(%edx),%edx
  805481:	85 d2                	test   %edx,%edx
  805483:	74 13                	je     805498 <tcp_bind+0x105>
    if (cpcb->local_port == port) {
  805485:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805489:	75 f3                	jne    80547e <tcp_bind+0xeb>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80548b:	8b 3b                	mov    (%ebx),%edi
  80548d:	39 3a                	cmp    %edi,(%edx)
  80548f:	75 ed                	jne    80547e <tcp_bind+0xeb>
        return ERR_USE;
  805491:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805496:	eb 30                	jmp    8054c8 <tcp_bind+0x135>
  if (!ip_addr_isany(ipaddr)) {
  805498:	85 db                	test   %ebx,%ebx
  80549a:	74 09                	je     8054a5 <tcp_bind+0x112>
  80549c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80549f:	74 04                	je     8054a5 <tcp_bind+0x112>
    pcb->local_ip = *ipaddr;
  8054a1:	8b 13                	mov    (%ebx),%edx
  8054a3:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  8054a5:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8054a9:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8054ae:	89 46 0c             	mov    %eax,0xc(%esi)
  8054b1:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  8054b7:	e8 f5 cc ff ff       	call   8021b1 <tcp_timer_needed>
  return ERR_OK;
  8054bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8054c1:	eb 05                	jmp    8054c8 <tcp_bind+0x135>
        return ERR_USE;
  8054c3:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  8054c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8054cb:	5b                   	pop    %ebx
  8054cc:	5e                   	pop    %esi
  8054cd:	5f                   	pop    %edi
  8054ce:	5d                   	pop    %ebp
  8054cf:	c3                   	ret    
        return ERR_USE;
  8054d0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054d5:	eb f1                	jmp    8054c8 <tcp_bind+0x135>
        return ERR_USE;
  8054d7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054dc:	eb ea                	jmp    8054c8 <tcp_bind+0x135>

008054de <tcp_listen_with_backlog>:
{
  8054de:	55                   	push   %ebp
  8054df:	89 e5                	mov    %esp,%ebp
  8054e1:	57                   	push   %edi
  8054e2:	56                   	push   %esi
  8054e3:	53                   	push   %ebx
  8054e4:	83 ec 1c             	sub    $0x1c,%esp
  8054e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8054ea:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8054ee:	0f 85 80 00 00 00    	jne    805574 <tcp_listen_with_backlog+0x96>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  8054f4:	83 ec 0c             	sub    $0xc,%esp
  8054f7:	6a 03                	push   $0x3
  8054f9:	e8 3f ef ff ff       	call   80443d <memp_malloc>
  8054fe:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805500:	83 c4 10             	add    $0x10,%esp
  805503:	85 c0                	test   %eax,%eax
  805505:	0f 84 eb 00 00 00    	je     8055f6 <tcp_listen_with_backlog+0x118>
  lpcb->callback_arg = pcb->callback_arg;
  80550b:	8b 43 18             	mov    0x18(%ebx),%eax
  80550e:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805511:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805515:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805519:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  805520:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805524:	83 c8 02             	or     $0x2,%eax
  805527:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  80552b:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80552f:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805532:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805536:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805539:	8b 03                	mov    (%ebx),%eax
  80553b:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80553d:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  805543:	39 da                	cmp    %ebx,%edx
  805545:	74 44                	je     80558b <tcp_listen_with_backlog+0xad>
  805547:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80554d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  805551:	89 df                	mov    %ebx,%edi
  805553:	85 d2                	test   %edx,%edx
  805555:	0f 84 87 00 00 00    	je     8055e2 <tcp_listen_with_backlog+0x104>
  80555b:	8b 42 0c             	mov    0xc(%edx),%eax
  80555e:	39 f8                	cmp    %edi,%eax
  805560:	0f 94 c3             	sete   %bl
  805563:	85 c0                	test   %eax,%eax
  805565:	0f 95 c1             	setne  %cl
  805568:	84 cb                	test   %cl,%bl
  80556a:	75 60                	jne    8055cc <tcp_listen_with_backlog+0xee>
  80556c:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  805570:	89 c2                	mov    %eax,%edx
  805572:	eb df                	jmp    805553 <tcp_listen_with_backlog+0x75>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805574:	83 ec 04             	sub    $0x4,%esp
  805577:	68 78 1c 81 00       	push   $0x811c78
  80557c:	68 60 01 00 00       	push   $0x160
  805581:	68 2e 1e 81 00       	push   $0x811e2e
  805586:	e8 e5 8f 00 00       	call   80e570 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80558b:	8b 43 0c             	mov    0xc(%ebx),%eax
  80558e:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805593:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  80559a:	83 ec 08             	sub    $0x8,%esp
  80559d:	53                   	push   %ebx
  80559e:	6a 02                	push   $0x2
  8055a0:	e8 ee ee ff ff       	call   804493 <memp_free>
  lpcb->accept = tcp_accept_null;
  8055a5:	c7 46 20 24 53 80 00 	movl   $0x805324,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  8055ac:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8055b1:	89 46 0c             	mov    %eax,0xc(%esi)
  8055b4:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  8055ba:	e8 f2 cb ff ff       	call   8021b1 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  8055bf:	83 c4 10             	add    $0x10,%esp
}
  8055c2:	89 f0                	mov    %esi,%eax
  8055c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8055c7:	5b                   	pop    %ebx
  8055c8:	5e                   	pop    %esi
  8055c9:	5f                   	pop    %edi
  8055ca:	5d                   	pop    %ebp
  8055cb:	c3                   	ret    
  8055cc:	89 fb                	mov    %edi,%ebx
  8055ce:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8055d2:	74 06                	je     8055da <tcp_listen_with_backlog+0xfc>
  8055d4:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055da:	8b 43 0c             	mov    0xc(%ebx),%eax
  8055dd:	89 42 0c             	mov    %eax,0xc(%edx)
  8055e0:	eb b1                	jmp    805593 <tcp_listen_with_backlog+0xb5>
  8055e2:	89 fb                	mov    %edi,%ebx
  8055e4:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8055e8:	74 a9                	je     805593 <tcp_listen_with_backlog+0xb5>
  8055ea:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8055f1:	00 00 00 
  8055f4:	eb 9d                	jmp    805593 <tcp_listen_with_backlog+0xb5>
    return NULL;
  8055f6:	be 00 00 00 00       	mov    $0x0,%esi
  8055fb:	eb c5                	jmp    8055c2 <tcp_listen_with_backlog+0xe4>

008055fd <tcp_recved>:
{
  8055fd:	55                   	push   %ebp
  8055fe:	89 e5                	mov    %esp,%ebp
  805600:	56                   	push   %esi
  805601:	53                   	push   %ebx
  805602:	8b 45 08             	mov    0x8(%ebp),%eax
  805605:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805608:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  80560c:	0f b7 ca             	movzwl %dx,%ecx
  80560f:	0f b7 f3             	movzwl %bx,%esi
  805612:	01 f1                	add    %esi,%ecx
  805614:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  80561a:	76 27                	jbe    805643 <tcp_recved+0x46>
    pcb->rcv_wnd = TCP_WND;
  80561c:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805622:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  805628:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  80562c:	f6 c2 03             	test   $0x3,%dl
  80562f:	75 3b                	jne    80566c <tcp_recved+0x6f>
    tcp_ack(pcb);
  805631:	f6 c2 01             	test   $0x1,%dl
  805634:	75 1f                	jne    805655 <tcp_recved+0x58>
  805636:	83 ca 01             	or     $0x1,%edx
  805639:	88 50 20             	mov    %dl,0x20(%eax)
}
  80563c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80563f:	5b                   	pop    %ebx
  805640:	5e                   	pop    %esi
  805641:	5d                   	pop    %ebp
  805642:	c3                   	ret    
    pcb->rcv_wnd += len;
  805643:	01 da                	add    %ebx,%edx
  805645:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805649:	66 3b 50 34          	cmp    0x34(%eax),%dx
  80564d:	72 d9                	jb     805628 <tcp_recved+0x2b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80564f:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  805653:	eb d3                	jmp    805628 <tcp_recved+0x2b>
    tcp_ack(pcb);
  805655:	83 e2 fe             	and    $0xfffffffe,%edx
  805658:	83 ca 02             	or     $0x2,%edx
  80565b:	88 50 20             	mov    %dl,0x20(%eax)
  80565e:	83 ec 0c             	sub    $0xc,%esp
  805661:	50                   	push   %eax
  805662:	e8 bf 29 00 00       	call   808026 <tcp_output>
  805667:	83 c4 10             	add    $0x10,%esp
  80566a:	eb d0                	jmp    80563c <tcp_recved+0x3f>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80566c:	f6 c2 01             	test   $0x1,%dl
  80566f:	74 cb                	je     80563c <tcp_recved+0x3f>
  805671:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805677:	76 c3                	jbe    80563c <tcp_recved+0x3f>
    tcp_ack_now(pcb);
  805679:	83 ca 02             	or     $0x2,%edx
  80567c:	88 50 20             	mov    %dl,0x20(%eax)
  80567f:	83 ec 0c             	sub    $0xc,%esp
  805682:	50                   	push   %eax
  805683:	e8 9e 29 00 00       	call   808026 <tcp_output>
  805688:	83 c4 10             	add    $0x10,%esp
}
  80568b:	eb af                	jmp    80563c <tcp_recved+0x3f>

0080568d <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80568d:	55                   	push   %ebp
  80568e:	89 e5                	mov    %esp,%ebp
  805690:	53                   	push   %ebx
  805691:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805694:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  80569a:	eb 21                	jmp    8056bd <tcp_fasttmr+0x30>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80569c:	83 ec 0c             	sub    $0xc,%esp
  80569f:	50                   	push   %eax
  8056a0:	e8 3e f1 ff ff       	call   8047e3 <pbuf_free>
  8056a5:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  8056a8:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8056af:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8056b2:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  8056b6:	a8 01                	test   $0x1,%al
  8056b8:	75 2d                	jne    8056e7 <tcp_fasttmr+0x5a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8056ba:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8056bd:	85 db                	test   %ebx,%ebx
  8056bf:	74 3e                	je     8056ff <tcp_fasttmr+0x72>
    if (pcb->refused_data != NULL) {
  8056c1:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8056c7:	85 c0                	test   %eax,%eax
  8056c9:	74 e7                	je     8056b2 <tcp_fasttmr+0x25>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8056cb:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  8056d1:	85 d2                	test   %edx,%edx
  8056d3:	74 c7                	je     80569c <tcp_fasttmr+0xf>
  8056d5:	6a 00                	push   $0x0
  8056d7:	50                   	push   %eax
  8056d8:	53                   	push   %ebx
  8056d9:	ff 73 18             	pushl  0x18(%ebx)
  8056dc:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  8056de:	83 c4 10             	add    $0x10,%esp
  8056e1:	84 c0                	test   %al,%al
  8056e3:	74 c3                	je     8056a8 <tcp_fasttmr+0x1b>
  8056e5:	eb cb                	jmp    8056b2 <tcp_fasttmr+0x25>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  8056e7:	83 c8 02             	or     $0x2,%eax
  8056ea:	88 43 20             	mov    %al,0x20(%ebx)
  8056ed:	83 ec 0c             	sub    $0xc,%esp
  8056f0:	53                   	push   %ebx
  8056f1:	e8 30 29 00 00       	call   808026 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8056f6:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  8056fa:	83 c4 10             	add    $0x10,%esp
  8056fd:	eb bb                	jmp    8056ba <tcp_fasttmr+0x2d>
    }
  }
}
  8056ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805702:	c9                   	leave  
  805703:	c3                   	ret    

00805704 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805704:	55                   	push   %ebp
  805705:	89 e5                	mov    %esp,%ebp
  805707:	56                   	push   %esi
  805708:	53                   	push   %ebx
  805709:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  80570c:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
  805711:	85 db                	test   %ebx,%ebx
  805713:	74 23                	je     805738 <tcp_seg_free+0x34>
    if (seg->p != NULL) {
  805715:	8b 43 04             	mov    0x4(%ebx),%eax
  805718:	85 c0                	test   %eax,%eax
  80571a:	74 0e                	je     80572a <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  80571c:	83 ec 0c             	sub    $0xc,%esp
  80571f:	50                   	push   %eax
  805720:	e8 be f0 ff ff       	call   8047e3 <pbuf_free>
  805725:	89 c6                	mov    %eax,%esi
  805727:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  80572a:	83 ec 08             	sub    $0x8,%esp
  80572d:	53                   	push   %ebx
  80572e:	6a 04                	push   $0x4
  805730:	e8 5e ed ff ff       	call   804493 <memp_free>
  805735:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  805738:	89 f0                	mov    %esi,%eax
  80573a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80573d:	5b                   	pop    %ebx
  80573e:	5e                   	pop    %esi
  80573f:	5d                   	pop    %ebp
  805740:	c3                   	ret    

00805741 <tcp_segs_free>:
{
  805741:	55                   	push   %ebp
  805742:	89 e5                	mov    %esp,%ebp
  805744:	56                   	push   %esi
  805745:	53                   	push   %ebx
  805746:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  805749:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  80574e:	85 c0                	test   %eax,%eax
  805750:	74 14                	je     805766 <tcp_segs_free+0x25>
    next = seg->next;
  805752:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  805754:	83 ec 0c             	sub    $0xc,%esp
  805757:	50                   	push   %eax
  805758:	e8 a7 ff ff ff       	call   805704 <tcp_seg_free>
  80575d:	01 c3                	add    %eax,%ebx
    seg = next;
  80575f:	83 c4 10             	add    $0x10,%esp
  805762:	89 f0                	mov    %esi,%eax
  805764:	eb e8                	jmp    80574e <tcp_segs_free+0xd>
}
  805766:	89 d8                	mov    %ebx,%eax
  805768:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80576b:	5b                   	pop    %ebx
  80576c:	5e                   	pop    %esi
  80576d:	5d                   	pop    %ebp
  80576e:	c3                   	ret    

0080576f <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  80576f:	55                   	push   %ebp
  805770:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805772:	8b 45 08             	mov    0x8(%ebp),%eax
  805775:	8b 55 0c             	mov    0xc(%ebp),%edx
  805778:	88 50 14             	mov    %dl,0x14(%eax)
}
  80577b:	5d                   	pop    %ebp
  80577c:	c3                   	ret    

0080577d <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  80577d:	55                   	push   %ebp
  80577e:	89 e5                	mov    %esp,%ebp
  805780:	53                   	push   %ebx
  805781:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805784:	6a 04                	push   $0x4
  805786:	e8 b2 ec ff ff       	call   80443d <memp_malloc>
  80578b:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  80578d:	83 c4 10             	add    $0x10,%esp
  805790:	85 c0                	test   %eax,%eax
  805792:	74 1c                	je     8057b0 <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805794:	83 ec 04             	sub    $0x4,%esp
  805797:	6a 14                	push   $0x14
  805799:	ff 75 08             	pushl  0x8(%ebp)
  80579c:	50                   	push   %eax
  80579d:	e8 75 96 00 00       	call   80ee17 <memcpy>
  pbuf_ref(cseg->p);
  8057a2:	83 c4 04             	add    $0x4,%esp
  8057a5:	ff 73 04             	pushl  0x4(%ebx)
  8057a8:	e8 98 f4 ff ff       	call   804c45 <pbuf_ref>
  return cseg;
  8057ad:	83 c4 10             	add    $0x10,%esp
}
  8057b0:	89 d8                	mov    %ebx,%eax
  8057b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8057b5:	c9                   	leave  
  8057b6:	c3                   	ret    

008057b7 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8057b7:	55                   	push   %ebp
  8057b8:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8057ba:	8b 45 08             	mov    0x8(%ebp),%eax
  8057bd:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057c0:	89 50 18             	mov    %edx,0x18(%eax)
}
  8057c3:	5d                   	pop    %ebp
  8057c4:	c3                   	ret    

008057c5 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8057c5:	55                   	push   %ebp
  8057c6:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  8057c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8057cb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057ce:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  8057d4:	5d                   	pop    %ebp
  8057d5:	c3                   	ret    

008057d6 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  8057d6:	55                   	push   %ebp
  8057d7:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  8057d9:	8b 45 08             	mov    0x8(%ebp),%eax
  8057dc:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057df:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  8057e5:	5d                   	pop    %ebp
  8057e6:	c3                   	ret    

008057e7 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  8057e7:	55                   	push   %ebp
  8057e8:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  8057ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8057ed:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057f0:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  8057f6:	5d                   	pop    %ebp
  8057f7:	c3                   	ret    

008057f8 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  8057f8:	55                   	push   %ebp
  8057f9:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  8057fb:	8b 45 08             	mov    0x8(%ebp),%eax
  8057fe:	8b 55 0c             	mov    0xc(%ebp),%edx
  805801:	89 50 20             	mov    %edx,0x20(%eax)
}
  805804:	5d                   	pop    %ebp
  805805:	c3                   	ret    

00805806 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805806:	55                   	push   %ebp
  805807:	89 e5                	mov    %esp,%ebp
  805809:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80580c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80580f:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805815:	8b 55 10             	mov    0x10(%ebp),%edx
  805818:	88 50 31             	mov    %dl,0x31(%eax)
}
  80581b:	5d                   	pop    %ebp
  80581c:	c3                   	ret    

0080581d <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  80581d:	55                   	push   %ebp
  80581e:	89 e5                	mov    %esp,%ebp
  805820:	53                   	push   %ebx
  805821:	83 ec 04             	sub    $0x4,%esp
  805824:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805827:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  80582a:	83 f8 0a             	cmp    $0xa,%eax
  80582d:	74 05                	je     805834 <tcp_pcb_purge+0x17>
  80582f:	83 f8 01             	cmp    $0x1,%eax
  805832:	77 05                	ja     805839 <tcp_pcb_purge+0x1c>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  805834:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805837:	c9                   	leave  
  805838:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  805839:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80583f:	85 c0                	test   %eax,%eax
  805841:	74 16                	je     805859 <tcp_pcb_purge+0x3c>
      pbuf_free(pcb->refused_data);
  805843:	83 ec 0c             	sub    $0xc,%esp
  805846:	50                   	push   %eax
  805847:	e8 97 ef ff ff       	call   8047e3 <pbuf_free>
      pcb->refused_data = NULL;
  80584c:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805853:	00 00 00 
  805856:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  805859:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  80585f:	83 ec 0c             	sub    $0xc,%esp
  805862:	ff 73 7c             	pushl  0x7c(%ebx)
  805865:	e8 d7 fe ff ff       	call   805741 <tcp_segs_free>
    pcb->ooseq = NULL;
  80586a:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  805871:	83 c4 04             	add    $0x4,%esp
  805874:	ff 73 74             	pushl  0x74(%ebx)
  805877:	e8 c5 fe ff ff       	call   805741 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  80587c:	83 c4 04             	add    $0x4,%esp
  80587f:	ff 73 78             	pushl  0x78(%ebx)
  805882:	e8 ba fe ff ff       	call   805741 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805887:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  80588e:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  805895:	83 c4 10             	add    $0x10,%esp
}
  805898:	eb 9a                	jmp    805834 <tcp_pcb_purge+0x17>

0080589a <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  80589a:	55                   	push   %ebp
  80589b:	89 e5                	mov    %esp,%ebp
  80589d:	57                   	push   %edi
  80589e:	56                   	push   %esi
  80589f:	53                   	push   %ebx
  8058a0:	83 ec 0c             	sub    $0xc,%esp
  8058a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8058a6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  8058a9:	8b 10                	mov    (%eax),%edx
  8058ab:	39 da                	cmp    %ebx,%edx
  8058ad:	74 2f                	je     8058de <tcp_pcb_remove+0x44>
  8058af:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8058b5:	bf 00 00 00 00       	mov    $0x0,%edi
  8058ba:	89 de                	mov    %ebx,%esi
  8058bc:	85 d2                	test   %edx,%edx
  8058be:	0f 84 82 00 00 00    	je     805946 <tcp_pcb_remove+0xac>
  8058c4:	8b 42 0c             	mov    0xc(%edx),%eax
  8058c7:	39 f0                	cmp    %esi,%eax
  8058c9:	0f 94 c3             	sete   %bl
  8058cc:	85 c0                	test   %eax,%eax
  8058ce:	0f 95 c1             	setne  %cl
  8058d1:	84 cb                	test   %cl,%bl
  8058d3:	75 5b                	jne    805930 <tcp_pcb_remove+0x96>
  8058d5:	bf 01 00 00 00       	mov    $0x1,%edi
  8058da:	89 c2                	mov    %eax,%edx
  8058dc:	eb de                	jmp    8058bc <tcp_pcb_remove+0x22>
  8058de:	8b 53 0c             	mov    0xc(%ebx),%edx
  8058e1:	89 10                	mov    %edx,(%eax)
  8058e3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  8058ea:	83 ec 0c             	sub    $0xc,%esp
  8058ed:	53                   	push   %ebx
  8058ee:	e8 2a ff ff ff       	call   80581d <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8058f3:	8b 43 10             	mov    0x10(%ebx),%eax
  8058f6:	83 c4 10             	add    $0x10,%esp
  8058f9:	83 f8 0a             	cmp    $0xa,%eax
  8058fc:	74 6e                	je     80596c <tcp_pcb_remove+0xd2>
  8058fe:	83 f8 01             	cmp    $0x1,%eax
  805901:	74 69                	je     80596c <tcp_pcb_remove+0xd2>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805903:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  805907:	a8 01                	test   $0x1,%al
  805909:	75 4f                	jne    80595a <tcp_pcb_remove+0xc0>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  80590b:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80590f:	75 63                	jne    805974 <tcp_pcb_remove+0xda>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805911:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805915:	75 74                	jne    80598b <tcp_pcb_remove+0xf1>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805917:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  80591b:	0f 85 81 00 00 00    	jne    8059a2 <tcp_pcb_remove+0x108>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805921:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805928:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80592b:	5b                   	pop    %ebx
  80592c:	5e                   	pop    %esi
  80592d:	5f                   	pop    %edi
  80592e:	5d                   	pop    %ebp
  80592f:	c3                   	ret    
  805930:	89 f3                	mov    %esi,%ebx
  805932:	89 f8                	mov    %edi,%eax
  805934:	84 c0                	test   %al,%al
  805936:	74 06                	je     80593e <tcp_pcb_remove+0xa4>
  805938:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(pcblist, pcb);
  80593e:	8b 43 0c             	mov    0xc(%ebx),%eax
  805941:	89 42 0c             	mov    %eax,0xc(%edx)
  805944:	eb 9d                	jmp    8058e3 <tcp_pcb_remove+0x49>
  805946:	89 f3                	mov    %esi,%ebx
  805948:	89 f8                	mov    %edi,%eax
  80594a:	84 c0                	test   %al,%al
  80594c:	74 95                	je     8058e3 <tcp_pcb_remove+0x49>
  80594e:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805955:	00 00 00 
  805958:	eb 89                	jmp    8058e3 <tcp_pcb_remove+0x49>
    pcb->flags |= TF_ACK_NOW;
  80595a:	83 c8 02             	or     $0x2,%eax
  80595d:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805960:	83 ec 0c             	sub    $0xc,%esp
  805963:	53                   	push   %ebx
  805964:	e8 bd 26 00 00       	call   808026 <tcp_output>
  805969:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  80596c:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805970:	74 af                	je     805921 <tcp_pcb_remove+0x87>
  805972:	eb 97                	jmp    80590b <tcp_pcb_remove+0x71>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805974:	83 ec 04             	sub    $0x4,%esp
  805977:	68 42 1e 81 00       	push   $0x811e42
  80597c:	68 b4 04 00 00       	push   $0x4b4
  805981:	68 2e 1e 81 00       	push   $0x811e2e
  805986:	e8 e5 8b 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  80598b:	83 ec 04             	sub    $0x4,%esp
  80598e:	68 5a 1e 81 00       	push   $0x811e5a
  805993:	68 b5 04 00 00       	push   $0x4b5
  805998:	68 2e 1e 81 00       	push   $0x811e2e
  80599d:	e8 ce 8b 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8059a2:	83 ec 04             	sub    $0x4,%esp
  8059a5:	68 73 1e 81 00       	push   $0x811e73
  8059aa:	68 b7 04 00 00       	push   $0x4b7
  8059af:	68 2e 1e 81 00       	push   $0x811e2e
  8059b4:	e8 b7 8b 00 00       	call   80e570 <_panic>

008059b9 <tcp_close>:
{
  8059b9:	55                   	push   %ebp
  8059ba:	89 e5                	mov    %esp,%ebp
  8059bc:	57                   	push   %edi
  8059bd:	56                   	push   %esi
  8059be:	53                   	push   %ebx
  8059bf:	83 ec 0c             	sub    $0xc,%esp
  8059c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  switch (pcb->state) {
  8059c5:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8059c9:	0f 87 3e 01 00 00    	ja     805b0d <tcp_close+0x154>
  8059cf:	8b 43 10             	mov    0x10(%ebx),%eax
  8059d2:	ff 24 85 8c 1e 81 00 	jmp    *0x811e8c(,%eax,4)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8059d9:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8059df:	39 da                	cmp    %ebx,%edx
  8059e1:	74 2b                	je     805a0e <tcp_close+0x55>
  8059e3:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8059e9:	bf 00 00 00 00       	mov    $0x0,%edi
  8059ee:	89 de                	mov    %ebx,%esi
  8059f0:	85 d2                	test   %edx,%edx
  8059f2:	74 57                	je     805a4b <tcp_close+0x92>
  8059f4:	8b 42 0c             	mov    0xc(%edx),%eax
  8059f7:	39 f0                	cmp    %esi,%eax
  8059f9:	0f 94 c3             	sete   %bl
  8059fc:	85 c0                	test   %eax,%eax
  8059fe:	0f 95 c1             	setne  %cl
  805a01:	84 cb                	test   %cl,%bl
  805a03:	75 30                	jne    805a35 <tcp_close+0x7c>
  805a05:	bf 01 00 00 00       	mov    $0x1,%edi
  805a0a:	89 c2                	mov    %eax,%edx
  805a0c:	eb e2                	jmp    8059f0 <tcp_close+0x37>
  805a0e:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a11:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805a16:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805a1d:	83 ec 08             	sub    $0x8,%esp
  805a20:	53                   	push   %ebx
  805a21:	6a 02                	push   $0x2
  805a23:	e8 6b ea ff ff       	call   804493 <memp_free>
    break;
  805a28:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805a2b:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805a30:	e9 9a 00 00 00       	jmp    805acf <tcp_close+0x116>
  805a35:	89 f3                	mov    %esi,%ebx
  805a37:	89 f8                	mov    %edi,%eax
  805a39:	84 c0                	test   %al,%al
  805a3b:	74 06                	je     805a43 <tcp_close+0x8a>
  805a3d:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805a43:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a46:	89 42 0c             	mov    %eax,0xc(%edx)
  805a49:	eb cb                	jmp    805a16 <tcp_close+0x5d>
  805a4b:	89 f3                	mov    %esi,%ebx
  805a4d:	89 f8                	mov    %edi,%eax
  805a4f:	84 c0                	test   %al,%al
  805a51:	74 c3                	je     805a16 <tcp_close+0x5d>
  805a53:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805a5a:	00 00 00 
  805a5d:	eb b7                	jmp    805a16 <tcp_close+0x5d>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805a5f:	83 ec 08             	sub    $0x8,%esp
  805a62:	53                   	push   %ebx
  805a63:	68 44 b2 b3 00       	push   $0xb3b244
  805a68:	e8 2d fe ff ff       	call   80589a <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805a6d:	83 c4 08             	add    $0x8,%esp
  805a70:	53                   	push   %ebx
  805a71:	6a 03                	push   $0x3
  805a73:	e8 1b ea ff ff       	call   804493 <memp_free>
    break;
  805a78:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805a7b:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805a80:	eb 4d                	jmp    805acf <tcp_close+0x116>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805a82:	83 ec 08             	sub    $0x8,%esp
  805a85:	53                   	push   %ebx
  805a86:	68 3c b2 b3 00       	push   $0xb3b23c
  805a8b:	e8 0a fe ff ff       	call   80589a <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805a90:	83 c4 08             	add    $0x8,%esp
  805a93:	53                   	push   %ebx
  805a94:	6a 02                	push   $0x2
  805a96:	e8 f8 e9 ff ff       	call   804493 <memp_free>
    break;
  805a9b:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805a9e:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805aa3:	eb 2a                	jmp    805acf <tcp_close+0x116>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805aa5:	83 ec 08             	sub    $0x8,%esp
  805aa8:	6a 01                	push   $0x1
  805aaa:	53                   	push   %ebx
  805aab:	e8 00 25 00 00       	call   807fb0 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805ab0:	83 c4 10             	add    $0x10,%esp
  805ab3:	84 c0                	test   %al,%al
  805ab5:	75 18                	jne    805acf <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805ab7:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    tcp_output(pcb);
  805abe:	83 ec 0c             	sub    $0xc,%esp
  805ac1:	53                   	push   %ebx
  805ac2:	e8 5f 25 00 00       	call   808026 <tcp_output>
  805ac7:	83 c4 10             	add    $0x10,%esp
  805aca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805acf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805ad2:	5b                   	pop    %ebx
  805ad3:	5e                   	pop    %esi
  805ad4:	5f                   	pop    %edi
  805ad5:	5d                   	pop    %ebp
  805ad6:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805ad7:	83 ec 08             	sub    $0x8,%esp
  805ada:	6a 01                	push   $0x1
  805adc:	53                   	push   %ebx
  805add:	e8 ce 24 00 00       	call   807fb0 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805ae2:	83 c4 10             	add    $0x10,%esp
  805ae5:	84 c0                	test   %al,%al
  805ae7:	75 e6                	jne    805acf <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805ae9:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805af0:	eb cc                	jmp    805abe <tcp_close+0x105>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805af2:	83 ec 08             	sub    $0x8,%esp
  805af5:	6a 01                	push   $0x1
  805af7:	53                   	push   %ebx
  805af8:	e8 b3 24 00 00       	call   807fb0 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805afd:	83 c4 10             	add    $0x10,%esp
  805b00:	84 c0                	test   %al,%al
  805b02:	75 cb                	jne    805acf <tcp_close+0x116>
      pcb->state = LAST_ACK;
  805b04:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805b0b:	eb b1                	jmp    805abe <tcp_close+0x105>
    err = ERR_OK;
  805b0d:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805b12:	eb bb                	jmp    805acf <tcp_close+0x116>

00805b14 <tcp_recv_null>:
{
  805b14:	55                   	push   %ebp
  805b15:	89 e5                	mov    %esp,%ebp
  805b17:	83 ec 08             	sub    $0x8,%esp
  805b1a:	8b 45 10             	mov    0x10(%ebp),%eax
  805b1d:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805b20:	85 c0                	test   %eax,%eax
  805b22:	74 13                	je     805b37 <tcp_recv_null+0x23>
    pbuf_free(p);
  805b24:	83 ec 0c             	sub    $0xc,%esp
  805b27:	50                   	push   %eax
  805b28:	e8 b6 ec ff ff       	call   8047e3 <pbuf_free>
  805b2d:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805b30:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b35:	c9                   	leave  
  805b36:	c3                   	ret    
  return ERR_OK;
  805b37:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805b3c:	84 d2                	test   %dl,%dl
  805b3e:	75 f5                	jne    805b35 <tcp_recv_null+0x21>
    return tcp_close(pcb);
  805b40:	83 ec 0c             	sub    $0xc,%esp
  805b43:	ff 75 0c             	pushl  0xc(%ebp)
  805b46:	e8 6e fe ff ff       	call   8059b9 <tcp_close>
  805b4b:	83 c4 10             	add    $0x10,%esp
  805b4e:	eb e5                	jmp    805b35 <tcp_recv_null+0x21>

00805b50 <tcp_abort>:
{
  805b50:	55                   	push   %ebp
  805b51:	89 e5                	mov    %esp,%ebp
  805b53:	57                   	push   %edi
  805b54:	56                   	push   %esi
  805b55:	53                   	push   %ebx
  805b56:	83 ec 2c             	sub    $0x2c,%esp
  805b59:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805b5c:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805b60:	0f 84 c2 00 00 00    	je     805c28 <tcp_abort+0xd8>
    seqno = pcb->snd_nxt;
  805b66:	8b 43 54             	mov    0x54(%ebx),%eax
  805b69:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805b6c:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805b6f:	8b 03                	mov    (%ebx),%eax
  805b71:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805b74:	8b 43 04             	mov    0x4(%ebx),%eax
  805b77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805b7a:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805b7e:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805b82:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805b86:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805b8a:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805b90:	8b 43 18             	mov    0x18(%ebx),%eax
  805b93:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b96:	83 ec 08             	sub    $0x8,%esp
  805b99:	53                   	push   %ebx
  805b9a:	68 3c b2 b3 00       	push   $0xb3b23c
  805b9f:	e8 f6 fc ff ff       	call   80589a <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805ba4:	8b 43 78             	mov    0x78(%ebx),%eax
  805ba7:	83 c4 10             	add    $0x10,%esp
  805baa:	85 c0                	test   %eax,%eax
  805bac:	74 0c                	je     805bba <tcp_abort+0x6a>
      tcp_segs_free(pcb->unacked);
  805bae:	83 ec 0c             	sub    $0xc,%esp
  805bb1:	50                   	push   %eax
  805bb2:	e8 8a fb ff ff       	call   805741 <tcp_segs_free>
  805bb7:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805bba:	8b 43 74             	mov    0x74(%ebx),%eax
  805bbd:	85 c0                	test   %eax,%eax
  805bbf:	74 0c                	je     805bcd <tcp_abort+0x7d>
      tcp_segs_free(pcb->unsent);
  805bc1:	83 ec 0c             	sub    $0xc,%esp
  805bc4:	50                   	push   %eax
  805bc5:	e8 77 fb ff ff       	call   805741 <tcp_segs_free>
  805bca:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805bcd:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805bd0:	85 c0                	test   %eax,%eax
  805bd2:	74 0c                	je     805be0 <tcp_abort+0x90>
      tcp_segs_free(pcb->ooseq);
  805bd4:	83 ec 0c             	sub    $0xc,%esp
  805bd7:	50                   	push   %eax
  805bd8:	e8 64 fb ff ff       	call   805741 <tcp_segs_free>
  805bdd:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805be0:	83 ec 08             	sub    $0x8,%esp
  805be3:	53                   	push   %ebx
  805be4:	6a 02                	push   $0x2
  805be6:	e8 a8 e8 ff ff       	call   804493 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805beb:	83 c4 10             	add    $0x10,%esp
  805bee:	85 f6                	test   %esi,%esi
  805bf0:	74 0d                	je     805bff <tcp_abort+0xaf>
  805bf2:	83 ec 08             	sub    $0x8,%esp
  805bf5:	6a fb                	push   $0xfffffffb
  805bf7:	ff 75 cc             	pushl  -0x34(%ebp)
  805bfa:	ff d6                	call   *%esi
  805bfc:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805bff:	83 ec 08             	sub    $0x8,%esp
  805c02:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805c06:	50                   	push   %eax
  805c07:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805c0b:	50                   	push   %eax
  805c0c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805c0f:	50                   	push   %eax
  805c10:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805c13:	50                   	push   %eax
  805c14:	57                   	push   %edi
  805c15:	ff 75 d4             	pushl  -0x2c(%ebp)
  805c18:	e8 a9 28 00 00       	call   8084c6 <tcp_rst>
  805c1d:	83 c4 20             	add    $0x20,%esp
}
  805c20:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805c23:	5b                   	pop    %ebx
  805c24:	5e                   	pop    %esi
  805c25:	5f                   	pop    %edi
  805c26:	5d                   	pop    %ebp
  805c27:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805c28:	83 ec 08             	sub    $0x8,%esp
  805c2b:	53                   	push   %ebx
  805c2c:	68 50 b2 b3 00       	push   $0xb3b250
  805c31:	e8 64 fc ff ff       	call   80589a <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805c36:	83 c4 08             	add    $0x8,%esp
  805c39:	53                   	push   %ebx
  805c3a:	6a 02                	push   $0x2
  805c3c:	e8 52 e8 ff ff       	call   804493 <memp_free>
  805c41:	83 c4 10             	add    $0x10,%esp
  805c44:	eb da                	jmp    805c20 <tcp_abort+0xd0>

00805c46 <tcp_slowtmr>:
{
  805c46:	55                   	push   %ebp
  805c47:	89 e5                	mov    %esp,%ebp
  805c49:	57                   	push   %edi
  805c4a:	56                   	push   %esi
  805c4b:	53                   	push   %ebx
  805c4c:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805c4f:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240
  pcb = tcp_active_pcbs;
  805c56:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  err = ERR_OK;
  805c5c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805c60:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805c67:	e9 2a 02 00 00       	jmp    805e96 <tcp_slowtmr+0x250>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805c6c:	83 ec 04             	sub    $0x4,%esp
  805c6f:	68 9c 1c 81 00       	push   $0x811c9c
  805c74:	68 36 02 00 00       	push   $0x236
  805c79:	68 2e 1e 81 00       	push   $0x811e2e
  805c7e:	e8 ed 88 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805c83:	83 ec 04             	sub    $0x4,%esp
  805c86:	68 c8 1c 81 00       	push   $0x811cc8
  805c8b:	68 37 02 00 00       	push   $0x237
  805c90:	68 2e 1e 81 00       	push   $0x811e2e
  805c95:	e8 d6 88 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805c9a:	83 ec 04             	sub    $0x4,%esp
  805c9d:	68 f4 1c 81 00       	push   $0x811cf4
  805ca2:	68 38 02 00 00       	push   $0x238
  805ca7:	68 2e 1e 81 00       	push   $0x811e2e
  805cac:	e8 bf 88 00 00       	call   80e570 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805cb1:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805cb5:	80 fa 06             	cmp    $0x6,%dl
  805cb8:	0f 84 d0 00 00 00    	je     805d8e <tcp_slowtmr+0x148>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805cbe:	80 fa 0c             	cmp    $0xc,%dl
  805cc1:	0f 85 0b 02 00 00    	jne    805ed2 <tcp_slowtmr+0x28c>
  805cc7:	be 01 00 00 00       	mov    $0x1,%esi
  805ccc:	e9 c2 00 00 00       	jmp    805d93 <tcp_slowtmr+0x14d>
        if(pcb->rtime >= 0)
  805cd1:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805cd5:	66 85 c9             	test   %cx,%cx
  805cd8:	78 07                	js     805ce1 <tcp_slowtmr+0x9b>
          ++pcb->rtime;
  805cda:	83 c1 01             	add    $0x1,%ecx
  805cdd:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805ce1:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805ce5:	0f 84 45 02 00 00    	je     805f30 <tcp_slowtmr+0x2ea>
  805ceb:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805cef:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805cf3:	0f 8c 37 02 00 00    	jl     805f30 <tcp_slowtmr+0x2ea>
          if (pcb->state != SYN_SENT) {
  805cf9:	83 f8 02             	cmp    $0x2,%eax
  805cfc:	74 1f                	je     805d1d <tcp_slowtmr+0xd7>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805cfe:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805d02:	66 c1 f8 03          	sar    $0x3,%ax
  805d06:	98                   	cwtl   
  805d07:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805d0b:	01 c8                	add    %ecx,%eax
  805d0d:	0f b6 d2             	movzbl %dl,%edx
  805d10:	0f b6 8a b4 1e 81 00 	movzbl 0x811eb4(%edx),%ecx
  805d17:	d3 e0                	shl    %cl,%eax
  805d19:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805d1d:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805d23:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805d27:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805d2b:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805d30:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805d33:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805d37:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805d3a:	66 39 d0             	cmp    %dx,%ax
  805d3d:	0f 42 c1             	cmovb  %ecx,%eax
  805d40:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805d44:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805d48:	83 ec 0c             	sub    $0xc,%esp
  805d4b:	53                   	push   %ebx
  805d4c:	e8 9e 28 00 00       	call   8085ef <tcp_rexmit_rto>
  805d51:	83 c4 10             	add    $0x10,%esp
  805d54:	e9 d7 01 00 00       	jmp    805f30 <tcp_slowtmr+0x2ea>
    pcb_remove = 0;
  805d59:	be 00 00 00 00       	mov    $0x0,%esi
  805d5e:	e9 cd 01 00 00       	jmp    805f30 <tcp_slowtmr+0x2ea>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805d63:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805d68:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805d6b:	83 f8 29             	cmp    $0x29,%eax
  805d6e:	89 f0                	mov    %esi,%eax
  805d70:	1c ff                	sbb    $0xff,%al
  805d72:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  805d74:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805d77:	85 c9                	test   %ecx,%ecx
  805d79:	75 1f                	jne    805d9a <tcp_slowtmr+0x154>
  805d7b:	e9 d0 00 00 00       	jmp    805e50 <tcp_slowtmr+0x20a>
        tcp_abort(pcb);
  805d80:	83 ec 0c             	sub    $0xc,%esp
  805d83:	53                   	push   %ebx
  805d84:	e8 c7 fd ff ff       	call   805b50 <tcp_abort>
  805d89:	83 c4 10             	add    $0x10,%esp
  805d8c:	eb 05                	jmp    805d93 <tcp_slowtmr+0x14d>
  805d8e:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  805d93:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805d96:	85 c9                	test   %ecx,%ecx
  805d98:	74 16                	je     805db0 <tcp_slowtmr+0x16a>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805d9a:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805da0:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805da3:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805da7:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805daa:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  805dac:	39 c2                	cmp    %eax,%edx
  805dae:	73 7b                	jae    805e2b <tcp_slowtmr+0x1e5>
    if (pcb->state == SYN_RCVD) {
  805db0:	8b 43 10             	mov    0x10(%ebx),%eax
  805db3:	83 f8 03             	cmp    $0x3,%eax
  805db6:	0f 84 87 00 00 00    	je     805e43 <tcp_slowtmr+0x1fd>
    if (pcb->state == LAST_ACK) {
  805dbc:	83 f8 09             	cmp    $0x9,%eax
  805dbf:	0f 85 8b 00 00 00    	jne    805e50 <tcp_slowtmr+0x20a>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805dc5:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805dca:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805dcd:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805dd2:	76 7c                	jbe    805e50 <tcp_slowtmr+0x20a>
      tcp_pcb_purge(pcb);      
  805dd4:	83 ec 0c             	sub    $0xc,%esp
  805dd7:	53                   	push   %ebx
  805dd8:	e8 40 fa ff ff       	call   80581d <tcp_pcb_purge>
      if (prev != NULL) {
  805ddd:	83 c4 10             	add    $0x10,%esp
  805de0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  805de4:	0f 84 e1 01 00 00    	je     805fcb <tcp_slowtmr+0x385>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805dea:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805df0:	0f 84 be 01 00 00    	je     805fb4 <tcp_slowtmr+0x36e>
        prev->next = pcb->next;
  805df6:	8b 43 0c             	mov    0xc(%ebx),%eax
  805df9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805dfc:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805dff:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805e05:	85 c0                	test   %eax,%eax
  805e07:	74 0d                	je     805e16 <tcp_slowtmr+0x1d0>
  805e09:	83 ec 08             	sub    $0x8,%esp
  805e0c:	6a fb                	push   $0xfffffffb
  805e0e:	ff 73 18             	pushl  0x18(%ebx)
  805e11:	ff d0                	call   *%eax
  805e13:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  805e16:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  805e19:	83 ec 08             	sub    $0x8,%esp
  805e1c:	53                   	push   %ebx
  805e1d:	6a 02                	push   $0x2
  805e1f:	e8 6f e6 ff ff       	call   804493 <memp_free>
  805e24:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  805e27:	89 f3                	mov    %esi,%ebx
  805e29:	eb 6b                	jmp    805e96 <tcp_slowtmr+0x250>
      tcp_segs_free(pcb->ooseq);
  805e2b:	83 ec 0c             	sub    $0xc,%esp
  805e2e:	51                   	push   %ecx
  805e2f:	e8 0d f9 ff ff       	call   805741 <tcp_segs_free>
      pcb->ooseq = NULL;
  805e34:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805e3b:	83 c4 10             	add    $0x10,%esp
  805e3e:	e9 6d ff ff ff       	jmp    805db0 <tcp_slowtmr+0x16a>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e43:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e48:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805e4b:	83 f8 28             	cmp    $0x28,%eax
  805e4e:	77 84                	ja     805dd4 <tcp_slowtmr+0x18e>
    if (pcb_remove) {
  805e50:	89 f0                	mov    %esi,%eax
  805e52:	84 c0                	test   %al,%al
  805e54:	0f 85 7a ff ff ff    	jne    805dd4 <tcp_slowtmr+0x18e>
      ++pcb->polltmr;
  805e5a:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805e5e:	83 c0 01             	add    $0x1,%eax
  805e61:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805e64:	3a 43 31             	cmp    0x31(%ebx),%al
  805e67:	72 27                	jb     805e90 <tcp_slowtmr+0x24a>
        pcb->polltmr = 0;
  805e69:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  805e6d:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805e73:	85 c0                	test   %eax,%eax
  805e75:	74 0f                	je     805e86 <tcp_slowtmr+0x240>
  805e77:	83 ec 08             	sub    $0x8,%esp
  805e7a:	53                   	push   %ebx
  805e7b:	ff 73 18             	pushl  0x18(%ebx)
  805e7e:	ff d0                	call   *%eax
  805e80:	88 45 e3             	mov    %al,-0x1d(%ebp)
  805e83:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805e86:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  805e8a:	0f 84 67 01 00 00    	je     805ff7 <tcp_slowtmr+0x3b1>
      prev = pcb;
  805e90:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  805e93:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  805e96:	85 db                	test   %ebx,%ebx
  805e98:	0f 84 6a 01 00 00    	je     806008 <tcp_slowtmr+0x3c2>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805e9e:	8b 43 10             	mov    0x10(%ebx),%eax
  805ea1:	85 c0                	test   %eax,%eax
  805ea3:	0f 84 c3 fd ff ff    	je     805c6c <tcp_slowtmr+0x26>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805ea9:	83 f8 01             	cmp    $0x1,%eax
  805eac:	0f 84 d1 fd ff ff    	je     805c83 <tcp_slowtmr+0x3d>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805eb2:	83 f8 0a             	cmp    $0xa,%eax
  805eb5:	0f 84 df fd ff ff    	je     805c9a <tcp_slowtmr+0x54>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805ebb:	83 f8 02             	cmp    $0x2,%eax
  805ebe:	0f 84 ed fd ff ff    	je     805cb1 <tcp_slowtmr+0x6b>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805ec4:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805ec8:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  805ecd:	80 fa 0c             	cmp    $0xc,%dl
  805ed0:	74 5e                	je     805f30 <tcp_slowtmr+0x2ea>
      if (pcb->persist_backoff > 0) {
  805ed2:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  805ed9:	89 f1                	mov    %esi,%ecx
  805edb:	84 c9                	test   %cl,%cl
  805edd:	0f 84 ee fd ff ff    	je     805cd1 <tcp_slowtmr+0x8b>
        pcb->persist_cnt++;
  805ee3:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805ee9:	83 c0 01             	add    $0x1,%eax
  805eec:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805ef2:	0f b6 d1             	movzbl %cl,%edx
  805ef5:	bf ac 1e 81 00       	mov    $0x811eac,%edi
  805efa:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  805eff:	39 d0                	cmp    %edx,%eax
  805f01:	0f 82 52 fe ff ff    	jb     805d59 <tcp_slowtmr+0x113>
          pcb->persist_cnt = 0;
  805f07:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805f0e:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805f11:	80 f9 06             	cmp    $0x6,%cl
  805f14:	77 09                	ja     805f1f <tcp_slowtmr+0x2d9>
            pcb->persist_backoff++;
  805f16:	8d 46 01             	lea    0x1(%esi),%eax
  805f19:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  805f1f:	83 ec 0c             	sub    $0xc,%esp
  805f22:	53                   	push   %ebx
  805f23:	e8 93 28 00 00       	call   8087bb <tcp_zero_window_probe>
  805f28:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  805f2b:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  805f30:	8b 43 10             	mov    0x10(%ebx),%eax
  805f33:	83 f8 06             	cmp    $0x6,%eax
  805f36:	0f 84 27 fe ff ff    	je     805d63 <tcp_slowtmr+0x11d>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805f3c:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805f40:	0f 84 4d fe ff ff    	je     805d93 <tcp_slowtmr+0x14d>
  805f46:	83 f8 04             	cmp    $0x4,%eax
  805f49:	74 09                	je     805f54 <tcp_slowtmr+0x30e>
  805f4b:	83 f8 07             	cmp    $0x7,%eax
  805f4e:	0f 85 3f fe ff ff    	jne    805d93 <tcp_slowtmr+0x14d>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f54:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  805f5a:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805f5d:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  805f63:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  805f69:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f6e:	f7 e2                	mul    %edx
  805f70:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f73:	39 d1                	cmp    %edx,%ecx
  805f75:	0f 87 05 fe ff ff    	ja     805d80 <tcp_slowtmr+0x13a>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  805f7b:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805f82:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805f88:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  805f8a:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f8f:	f7 e2                	mul    %edx
  805f91:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f94:	39 d1                	cmp    %edx,%ecx
  805f96:	0f 86 f7 fd ff ff    	jbe    805d93 <tcp_slowtmr+0x14d>
        tcp_keepalive(pcb);
  805f9c:	83 ec 0c             	sub    $0xc,%esp
  805f9f:	53                   	push   %ebx
  805fa0:	e8 f0 26 00 00       	call   808695 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805fa5:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805fac:	83 c4 10             	add    $0x10,%esp
  805faf:	e9 df fd ff ff       	jmp    805d93 <tcp_slowtmr+0x14d>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805fb4:	83 ec 04             	sub    $0x4,%esp
  805fb7:	68 24 1d 81 00       	push   $0x811d24
  805fbc:	68 c1 02 00 00       	push   $0x2c1
  805fc1:	68 2e 1e 81 00       	push   $0x811e2e
  805fc6:	e8 a5 85 00 00       	call   80e570 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805fcb:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805fd1:	75 0d                	jne    805fe0 <tcp_slowtmr+0x39a>
        tcp_active_pcbs = pcb->next;
  805fd3:	8b 43 0c             	mov    0xc(%ebx),%eax
  805fd6:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  805fdb:	e9 1f fe ff ff       	jmp    805dff <tcp_slowtmr+0x1b9>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805fe0:	83 ec 04             	sub    $0x4,%esp
  805fe3:	68 50 1d 81 00       	push   $0x811d50
  805fe8:	68 c5 02 00 00       	push   $0x2c5
  805fed:	68 2e 1e 81 00       	push   $0x811e2e
  805ff2:	e8 79 85 00 00       	call   80e570 <_panic>
          tcp_output(pcb);
  805ff7:	83 ec 0c             	sub    $0xc,%esp
  805ffa:	53                   	push   %ebx
  805ffb:	e8 26 20 00 00       	call   808026 <tcp_output>
  806000:	83 c4 10             	add    $0x10,%esp
  806003:	e9 88 fe ff ff       	jmp    805e90 <tcp_slowtmr+0x24a>
  pcb = tcp_tw_pcbs;
  806008:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  80600e:	eb 48                	jmp    806058 <tcp_slowtmr+0x412>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806010:	83 ec 04             	sub    $0x4,%esp
  806013:	68 7c 1d 81 00       	push   $0x811d7c
  806018:	68 e5 02 00 00       	push   $0x2e5
  80601d:	68 2e 1e 81 00       	push   $0x811e2e
  806022:	e8 49 85 00 00       	call   80e570 <_panic>
      tcp_pcb_purge(pcb);      
  806027:	83 ec 0c             	sub    $0xc,%esp
  80602a:	56                   	push   %esi
  80602b:	e8 ed f7 ff ff       	call   80581d <tcp_pcb_purge>
      if (prev != NULL) {
  806030:	83 c4 10             	add    $0x10,%esp
  806033:	85 db                	test   %ebx,%ebx
  806035:	74 58                	je     80608f <tcp_slowtmr+0x449>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806037:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  80603d:	74 39                	je     806078 <tcp_slowtmr+0x432>
        prev->next = pcb->next;
  80603f:	8b 46 0c             	mov    0xc(%esi),%eax
  806042:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  806045:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806048:	83 ec 08             	sub    $0x8,%esp
  80604b:	56                   	push   %esi
  80604c:	6a 02                	push   $0x2
  80604e:	e8 40 e4 ff ff       	call   804493 <memp_free>
  806053:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806056:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  806058:	85 f6                	test   %esi,%esi
  80605a:	74 5c                	je     8060b8 <tcp_slowtmr+0x472>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80605c:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806060:	75 ae                	jne    806010 <tcp_slowtmr+0x3ca>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806062:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806067:	2b 46 2c             	sub    0x2c(%esi),%eax
  80606a:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80606f:	77 b6                	ja     806027 <tcp_slowtmr+0x3e1>
      prev = pcb;
  806071:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  806073:	8b 76 0c             	mov    0xc(%esi),%esi
  806076:	eb e0                	jmp    806058 <tcp_slowtmr+0x412>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806078:	83 ec 04             	sub    $0x4,%esp
  80607b:	68 ac 1d 81 00       	push   $0x811dac
  806080:	68 f4 02 00 00       	push   $0x2f4
  806085:	68 2e 1e 81 00       	push   $0x811e2e
  80608a:	e8 e1 84 00 00       	call   80e570 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80608f:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  806095:	75 0a                	jne    8060a1 <tcp_slowtmr+0x45b>
        tcp_tw_pcbs = pcb->next;
  806097:	8b 46 0c             	mov    0xc(%esi),%eax
  80609a:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
  80609f:	eb a4                	jmp    806045 <tcp_slowtmr+0x3ff>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8060a1:	83 ec 04             	sub    $0x4,%esp
  8060a4:	68 d4 1d 81 00       	push   $0x811dd4
  8060a9:	68 f8 02 00 00       	push   $0x2f8
  8060ae:	68 2e 1e 81 00       	push   $0x811e2e
  8060b3:	e8 b8 84 00 00       	call   80e570 <_panic>
}
  8060b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8060bb:	5b                   	pop    %ebx
  8060bc:	5e                   	pop    %esi
  8060bd:	5f                   	pop    %edi
  8060be:	5d                   	pop    %ebp
  8060bf:	c3                   	ret    

008060c0 <tcp_tmr>:
{
  8060c0:	55                   	push   %ebp
  8060c1:	89 e5                	mov    %esp,%ebp
  8060c3:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  8060c6:	e8 c2 f5 ff ff       	call   80568d <tcp_fasttmr>
  if (++tcp_timer & 1) {
  8060cb:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  8060d2:	83 c0 01             	add    $0x1,%eax
  8060d5:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  8060da:	a8 01                	test   $0x1,%al
  8060dc:	75 02                	jne    8060e0 <tcp_tmr+0x20>
}
  8060de:	c9                   	leave  
  8060df:	c3                   	ret    
    tcp_slowtmr();
  8060e0:	e8 61 fb ff ff       	call   805c46 <tcp_slowtmr>
}
  8060e5:	eb f7                	jmp    8060de <tcp_tmr+0x1e>

008060e7 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8060e7:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8060ec:	03 05 08 40 81 00    	add    0x814008,%eax
  8060f2:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  8060f7:	c3                   	ret    

008060f8 <tcp_alloc>:
{
  8060f8:	55                   	push   %ebp
  8060f9:	89 e5                	mov    %esp,%ebp
  8060fb:	57                   	push   %edi
  8060fc:	56                   	push   %esi
  8060fd:	53                   	push   %ebx
  8060fe:	83 ec 28             	sub    $0x28,%esp
  806101:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  806105:	6a 02                	push   $0x2
  806107:	e8 31 e3 ff ff       	call   80443d <memp_malloc>
  80610c:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  80610e:	83 c4 10             	add    $0x10,%esp
  806111:	85 c0                	test   %eax,%eax
  806113:	0f 84 a0 00 00 00    	je     8061b9 <tcp_alloc+0xc1>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806119:	83 ec 04             	sub    $0x4,%esp
  80611c:	68 a8 00 00 00       	push   $0xa8
  806121:	6a 00                	push   $0x0
  806123:	53                   	push   %ebx
  806124:	e8 44 8c 00 00       	call   80ed6d <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806129:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  80612d:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  806133:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  806139:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  80613f:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  806145:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  806149:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80614d:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  806153:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  806159:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80615f:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  806165:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  80616b:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  806171:	e8 71 ff ff ff       	call   8060e7 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806176:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806179:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  80617c:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  80617f:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  806182:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  806185:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80618a:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  80618d:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  806191:	c7 83 88 00 00 00 14 	movl   $0x805b14,0x88(%ebx)
  806198:	5b 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80619b:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  8061a2:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  8061a5:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  8061ac:	83 c4 10             	add    $0x10,%esp
}
  8061af:	89 d8                	mov    %ebx,%eax
  8061b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8061b4:	5b                   	pop    %ebx
  8061b5:	5e                   	pop    %esi
  8061b6:	5f                   	pop    %edi
  8061b7:	5d                   	pop    %ebp
  8061b8:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8061b9:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061be:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  inactivity = 0;
  8061c4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8061c9:	eb 03                	jmp    8061ce <tcp_alloc+0xd6>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8061cb:	8b 40 0c             	mov    0xc(%eax),%eax
  8061ce:	85 c0                	test   %eax,%eax
  8061d0:	74 0f                	je     8061e1 <tcp_alloc+0xe9>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061d2:	89 fa                	mov    %edi,%edx
  8061d4:	2b 50 2c             	sub    0x2c(%eax),%edx
  8061d7:	39 ca                	cmp    %ecx,%edx
  8061d9:	72 f0                	jb     8061cb <tcp_alloc+0xd3>
      inactivity = tcp_ticks - pcb->tmr;
  8061db:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8061dd:	89 c3                	mov    %eax,%ebx
  8061df:	eb ea                	jmp    8061cb <tcp_alloc+0xd3>
  if (inactive != NULL) {
  8061e1:	85 db                	test   %ebx,%ebx
  8061e3:	74 0c                	je     8061f1 <tcp_alloc+0xf9>
    tcp_abort(inactive);
  8061e5:	83 ec 0c             	sub    $0xc,%esp
  8061e8:	53                   	push   %ebx
  8061e9:	e8 62 f9 ff ff       	call   805b50 <tcp_abort>
  8061ee:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  8061f1:	83 ec 0c             	sub    $0xc,%esp
  8061f4:	6a 02                	push   $0x2
  8061f6:	e8 42 e2 ff ff       	call   80443d <memp_malloc>
  8061fb:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  8061fd:	83 c4 10             	add    $0x10,%esp
  806200:	85 c0                	test   %eax,%eax
  806202:	0f 85 11 ff ff ff    	jne    806119 <tcp_alloc+0x21>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806208:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80620d:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  806213:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  806216:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  80621b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806222:	89 df                	mov    %ebx,%edi
  806224:	89 f1                	mov    %esi,%ecx
  806226:	88 4d e7             	mov    %cl,-0x19(%ebp)
  806229:	eb 03                	jmp    80622e <tcp_alloc+0x136>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80622b:	8b 40 0c             	mov    0xc(%eax),%eax
  80622e:	85 c0                	test   %eax,%eax
  806230:	74 29                	je     80625b <tcp_alloc+0x163>
    if (pcb->prio <= prio &&
  806232:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  806236:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80623a:	38 d3                	cmp    %dl,%bl
  80623c:	89 d6                	mov    %edx,%esi
  80623e:	0f 46 f3             	cmovbe %ebx,%esi
  806241:	89 f3                	mov    %esi,%ebx
  806243:	38 cb                	cmp    %cl,%bl
  806245:	72 e4                	jb     80622b <tcp_alloc+0x133>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806247:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80624a:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  80624d:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  806250:	72 d9                	jb     80622b <tcp_alloc+0x133>
      mprio = pcb->prio;
  806252:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  806254:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  806257:	89 c7                	mov    %eax,%edi
  806259:	eb d0                	jmp    80622b <tcp_alloc+0x133>
  if (inactive != NULL) {
  80625b:	85 ff                	test   %edi,%edi
  80625d:	74 0c                	je     80626b <tcp_alloc+0x173>
    tcp_abort(inactive);
  80625f:	83 ec 0c             	sub    $0xc,%esp
  806262:	57                   	push   %edi
  806263:	e8 e8 f8 ff ff       	call   805b50 <tcp_abort>
  806268:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  80626b:	83 ec 0c             	sub    $0xc,%esp
  80626e:	6a 02                	push   $0x2
  806270:	e8 c8 e1 ff ff       	call   80443d <memp_malloc>
  806275:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  806277:	83 c4 10             	add    $0x10,%esp
  80627a:	85 c0                	test   %eax,%eax
  80627c:	0f 84 2d ff ff ff    	je     8061af <tcp_alloc+0xb7>
  806282:	e9 92 fe ff ff       	jmp    806119 <tcp_alloc+0x21>

00806287 <tcp_new>:
{
  806287:	55                   	push   %ebp
  806288:	89 e5                	mov    %esp,%ebp
  80628a:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80628d:	6a 40                	push   $0x40
  80628f:	e8 64 fe ff ff       	call   8060f8 <tcp_alloc>
}
  806294:	c9                   	leave  
  806295:	c3                   	ret    

00806296 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806296:	55                   	push   %ebp
  806297:	89 e5                	mov    %esp,%ebp
  806299:	56                   	push   %esi
  80629a:	53                   	push   %ebx
  80629b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80629e:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  8062a0:	83 ec 0c             	sub    $0xc,%esp
  8062a3:	ff 75 0c             	pushl  0xc(%ebp)
  8062a6:	e8 f6 01 00 00       	call   8064a1 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  8062ab:	83 c4 10             	add    $0x10,%esp
  8062ae:	85 c0                	test   %eax,%eax
  8062b0:	74 14                	je     8062c6 <tcp_eff_send_mss+0x30>
  8062b2:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8062b6:	66 85 c0             	test   %ax,%ax
  8062b9:	74 0b                	je     8062c6 <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  8062bb:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8062be:	66 39 c3             	cmp    %ax,%bx
  8062c1:	0f 46 c3             	cmovbe %ebx,%eax
  8062c4:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  8062c6:	89 f0                	mov    %esi,%eax
  8062c8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8062cb:	5b                   	pop    %ebx
  8062cc:	5e                   	pop    %esi
  8062cd:	5d                   	pop    %ebp
  8062ce:	c3                   	ret    

008062cf <tcp_connect>:
{
  8062cf:	55                   	push   %ebp
  8062d0:	89 e5                	mov    %esp,%ebp
  8062d2:	57                   	push   %edi
  8062d3:	56                   	push   %esi
  8062d4:	53                   	push   %ebx
  8062d5:	83 ec 1c             	sub    $0x1c,%esp
  8062d8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8062db:	8b 75 0c             	mov    0xc(%ebp),%esi
  8062de:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8062e1:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8062e5:	0f 85 bd 00 00 00    	jne    8063a8 <tcp_connect+0xd9>
  if (ipaddr != NULL) {
  8062eb:	85 f6                	test   %esi,%esi
  8062ed:	0f 84 67 01 00 00    	je     80645a <tcp_connect+0x18b>
    pcb->remote_ip = *ipaddr;
  8062f3:	8b 16                	mov    (%esi),%edx
  8062f5:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  8062f8:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  8062fc:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  806301:	0f 84 b8 00 00 00    	je     8063bf <tcp_connect+0xf0>
  iss = tcp_next_iss();
  806307:	e8 db fd ff ff       	call   8060e7 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  80630c:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  806313:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  806316:	83 e8 01             	sub    $0x1,%eax
  806319:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  80631c:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  80631f:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  806325:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  80632b:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806331:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806337:	83 ec 08             	sub    $0x8,%esp
  80633a:	56                   	push   %esi
  80633b:	68 18 02 00 00       	push   $0x218
  806340:	e8 51 ff ff ff       	call   806296 <tcp_eff_send_mss>
  806345:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  806349:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  80634f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  806352:	01 c0                	add    %eax,%eax
  806354:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  806358:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  80635f:	8b 45 14             	mov    0x14(%ebp),%eax
  806362:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806368:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  80636e:	83 c4 10             	add    $0x10,%esp
  806371:	39 da                	cmp    %ebx,%edx
  806373:	74 58                	je     8063cd <tcp_connect+0xfe>
  806375:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80637b:	bf 00 00 00 00       	mov    $0x0,%edi
  806380:	89 de                	mov    %ebx,%esi
  806382:	85 d2                	test   %edx,%edx
  806384:	0f 84 ae 00 00 00    	je     806438 <tcp_connect+0x169>
  80638a:	8b 42 0c             	mov    0xc(%edx),%eax
  80638d:	39 f0                	cmp    %esi,%eax
  80638f:	0f 94 c3             	sete   %bl
  806392:	85 c0                	test   %eax,%eax
  806394:	0f 95 c1             	setne  %cl
  806397:	84 cb                	test   %cl,%bl
  806399:	0f 85 83 00 00 00    	jne    806422 <tcp_connect+0x153>
  80639f:	bf 01 00 00 00       	mov    $0x1,%edi
  8063a4:	89 c2                	mov    %eax,%edx
  8063a6:	eb da                	jmp    806382 <tcp_connect+0xb3>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8063a8:	83 ec 04             	sub    $0x4,%esp
  8063ab:	68 fc 1d 81 00       	push   $0x811dfc
  8063b0:	68 ec 01 00 00       	push   $0x1ec
  8063b5:	68 2e 1e 81 00       	push   $0x811e2e
  8063ba:	e8 b1 81 00 00       	call   80e570 <_panic>
    pcb->local_port = tcp_new_port();
  8063bf:	e8 66 ef ff ff       	call   80532a <tcp_new_port>
  8063c4:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  8063c8:	e9 3a ff ff ff       	jmp    806307 <tcp_connect+0x38>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8063cd:	8b 43 0c             	mov    0xc(%ebx),%eax
  8063d0:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  TCP_REG(&tcp_active_pcbs, pcb);
  8063d5:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  8063da:	89 43 0c             	mov    %eax,0xc(%ebx)
  8063dd:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  8063e3:	e8 c9 bd ff ff       	call   8021b1 <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  8063e8:	83 ec 0c             	sub    $0xc,%esp
  8063eb:	68 b4 05 04 02       	push   $0x20405b4
  8063f0:	e8 ea 12 00 00       	call   8076df <htonl>
  8063f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  8063f8:	83 c4 0c             	add    $0xc,%esp
  8063fb:	6a 04                	push   $0x4
  8063fd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806400:	50                   	push   %eax
  806401:	6a 00                	push   $0x0
  806403:	6a 02                	push   $0x2
  806405:	6a 00                	push   $0x0
  806407:	6a 00                	push   $0x0
  806409:	53                   	push   %ebx
  80640a:	e8 fa 14 00 00       	call   807909 <tcp_enqueue>
  80640f:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  806411:	83 c4 20             	add    $0x20,%esp
  806414:	84 c0                	test   %al,%al
  806416:	74 34                	je     80644c <tcp_connect+0x17d>
} 
  806418:	89 f0                	mov    %esi,%eax
  80641a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80641d:	5b                   	pop    %ebx
  80641e:	5e                   	pop    %esi
  80641f:	5f                   	pop    %edi
  806420:	5d                   	pop    %ebp
  806421:	c3                   	ret    
  806422:	89 f3                	mov    %esi,%ebx
  806424:	89 f8                	mov    %edi,%eax
  806426:	84 c0                	test   %al,%al
  806428:	74 06                	je     806430 <tcp_connect+0x161>
  80642a:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806430:	8b 43 0c             	mov    0xc(%ebx),%eax
  806433:	89 42 0c             	mov    %eax,0xc(%edx)
  806436:	eb 9d                	jmp    8063d5 <tcp_connect+0x106>
  806438:	89 f3                	mov    %esi,%ebx
  80643a:	89 f8                	mov    %edi,%eax
  80643c:	84 c0                	test   %al,%al
  80643e:	74 95                	je     8063d5 <tcp_connect+0x106>
  806440:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  806447:	00 00 00 
  80644a:	eb 89                	jmp    8063d5 <tcp_connect+0x106>
    tcp_output(pcb);
  80644c:	83 ec 0c             	sub    $0xc,%esp
  80644f:	53                   	push   %ebx
  806450:	e8 d1 1b 00 00       	call   808026 <tcp_output>
  806455:	83 c4 10             	add    $0x10,%esp
  806458:	eb be                	jmp    806418 <tcp_connect+0x149>
    return ERR_VAL;
  80645a:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  80645f:	eb b7                	jmp    806418 <tcp_connect+0x149>

00806461 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  806461:	55                   	push   %ebp
  806462:	89 e5                	mov    %esp,%ebp
  806464:	53                   	push   %ebx
  806465:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806468:	8b 45 08             	mov    0x8(%ebp),%eax
  80646b:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80646d:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806470:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806475:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806478:	77 24                	ja     80649e <ip_addr_isbroadcast+0x3d>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  80647a:	b8 00 00 00 00       	mov    $0x0,%eax
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  80647f:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  806483:	74 19                	je     80649e <ip_addr_isbroadcast+0x3d>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806485:	8b 59 04             	mov    0x4(%ecx),%ebx
  806488:	39 d3                	cmp    %edx,%ebx
  80648a:	74 12                	je     80649e <ip_addr_isbroadcast+0x3d>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  80648c:	8b 49 08             	mov    0x8(%ecx),%ecx
  80648f:	31 d3                	xor    %edx,%ebx
  806491:	85 cb                	test   %ecx,%ebx
  806493:	75 09                	jne    80649e <ip_addr_isbroadcast+0x3d>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806495:	f7 d1                	not    %ecx
  806497:	21 ca                	and    %ecx,%edx
  806499:	39 ca                	cmp    %ecx,%edx
  80649b:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  80649e:	5b                   	pop    %ebx
  80649f:	5d                   	pop    %ebp
  8064a0:	c3                   	ret    

008064a1 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  8064a1:	55                   	push   %ebp
  8064a2:	89 e5                	mov    %esp,%ebp
  8064a4:	56                   	push   %esi
  8064a5:	53                   	push   %ebx
  8064a6:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8064a9:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  8064af:	eb 02                	jmp    8064b3 <ip_route+0x12>
  8064b1:	8b 1b                	mov    (%ebx),%ebx
  8064b3:	85 db                	test   %ebx,%ebx
  8064b5:	74 1c                	je     8064d3 <ip_route+0x32>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  8064b7:	83 ec 0c             	sub    $0xc,%esp
  8064ba:	53                   	push   %ebx
  8064bb:	e8 47 e2 ff ff       	call   804707 <netif_is_up>
  8064c0:	83 c4 10             	add    $0x10,%esp
  8064c3:	84 c0                	test   %al,%al
  8064c5:	74 ea                	je     8064b1 <ip_route+0x10>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  8064c7:	8b 06                	mov    (%esi),%eax
  8064c9:	33 43 04             	xor    0x4(%ebx),%eax
  8064cc:	85 43 08             	test   %eax,0x8(%ebx)
  8064cf:	75 e0                	jne    8064b1 <ip_route+0x10>
  8064d1:	eb 1e                	jmp    8064f1 <ip_route+0x50>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8064d3:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  8064d8:	85 c0                	test   %eax,%eax
  8064da:	74 1e                	je     8064fa <ip_route+0x59>
  8064dc:	83 ec 0c             	sub    $0xc,%esp
  8064df:	50                   	push   %eax
  8064e0:	e8 22 e2 ff ff       	call   804707 <netif_is_up>
  8064e5:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8064e8:	84 c0                	test   %al,%al
  8064ea:	0f 45 1d 38 b2 b3 00 	cmovne 0xb3b238,%ebx
}
  8064f1:	89 d8                	mov    %ebx,%eax
  8064f3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8064f6:	5b                   	pop    %ebx
  8064f7:	5e                   	pop    %esi
  8064f8:	5d                   	pop    %ebp
  8064f9:	c3                   	ret    
    return NULL;
  8064fa:	89 c3                	mov    %eax,%ebx
  8064fc:	eb f3                	jmp    8064f1 <ip_route+0x50>

008064fe <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8064fe:	55                   	push   %ebp
  8064ff:	89 e5                	mov    %esp,%ebp
  806501:	57                   	push   %edi
  806502:	56                   	push   %esi
  806503:	53                   	push   %ebx
  806504:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806507:	8b 45 08             	mov    0x8(%ebp),%eax
  80650a:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  80650d:	0f b7 07             	movzwl (%edi),%eax
  806510:	50                   	push   %eax
  806511:	e8 bc 11 00 00       	call   8076d2 <ntohs>
  806516:	66 c1 e8 0c          	shr    $0xc,%ax
  80651a:	83 c4 10             	add    $0x10,%esp
  80651d:	66 83 f8 04          	cmp    $0x4,%ax
  806521:	74 1b                	je     80653e <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806523:	83 ec 0c             	sub    $0xc,%esp
  806526:	ff 75 08             	pushl  0x8(%ebp)
  806529:	e8 b5 e2 ff ff       	call   8047e3 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80652e:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  806531:	b8 00 00 00 00       	mov    $0x0,%eax
  806536:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806539:	5b                   	pop    %ebx
  80653a:	5e                   	pop    %esi
  80653b:	5f                   	pop    %edi
  80653c:	5d                   	pop    %ebp
  80653d:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  80653e:	83 ec 0c             	sub    $0xc,%esp
  806541:	0f b7 07             	movzwl (%edi),%eax
  806544:	50                   	push   %eax
  806545:	e8 88 11 00 00       	call   8076d2 <ntohs>
  80654a:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  80654e:	83 e0 3c             	and    $0x3c,%eax
  806551:	89 c6                	mov    %eax,%esi
  806553:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806557:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80655b:	89 04 24             	mov    %eax,(%esp)
  80655e:	e8 6f 11 00 00       	call   8076d2 <ntohs>
  806563:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806565:	83 c4 10             	add    $0x10,%esp
  806568:	8b 45 08             	mov    0x8(%ebp),%eax
  80656b:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80656f:	72 06                	jb     806577 <ip_input+0x79>
  806571:	66 39 58 08          	cmp    %bx,0x8(%eax)
  806575:	73 10                	jae    806587 <ip_input+0x89>
    pbuf_free(p);
  806577:	83 ec 0c             	sub    $0xc,%esp
  80657a:	ff 75 08             	pushl  0x8(%ebp)
  80657d:	e8 61 e2 ff ff       	call   8047e3 <pbuf_free>
    return ERR_OK;
  806582:	83 c4 10             	add    $0x10,%esp
  806585:	eb aa                	jmp    806531 <ip_input+0x33>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806587:	83 ec 08             	sub    $0x8,%esp
  80658a:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80658e:	50                   	push   %eax
  80658f:	57                   	push   %edi
  806590:	e8 02 10 00 00       	call   807597 <inet_chksum>
  806595:	83 c4 10             	add    $0x10,%esp
  806598:	66 85 c0             	test   %ax,%ax
  80659b:	75 27                	jne    8065c4 <ip_input+0xc6>
  pbuf_realloc(p, iphdr_len);
  80659d:	83 ec 08             	sub    $0x8,%esp
  8065a0:	0f b7 db             	movzwl %bx,%ebx
  8065a3:	53                   	push   %ebx
  8065a4:	ff 75 08             	pushl  0x8(%ebp)
  8065a7:	e8 6f e5 ff ff       	call   804b1b <pbuf_realloc>
  8065ac:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  8065af:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  8065b2:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8065b7:	8d 47 10             	lea    0x10(%edi),%eax
  8065ba:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8065bd:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8065c0:	89 df                	mov    %ebx,%edi
  8065c2:	eb 2e                	jmp    8065f2 <ip_input+0xf4>
    pbuf_free(p);
  8065c4:	83 ec 0c             	sub    $0xc,%esp
  8065c7:	ff 75 08             	pushl  0x8(%ebp)
  8065ca:	e8 14 e2 ff ff       	call   8047e3 <pbuf_free>
    return ERR_OK;
  8065cf:	83 c4 10             	add    $0x10,%esp
  8065d2:	e9 5a ff ff ff       	jmp    806531 <ip_input+0x33>
      if (first) {
  8065d7:	85 f6                	test   %esi,%esi
  8065d9:	74 56                	je     806631 <ip_input+0x133>
        netif = netif_list;
  8065db:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
      if (netif == inp) {
  8065e1:	39 df                	cmp    %ebx,%edi
  8065e3:	74 50                	je     806635 <ip_input+0x137>
  8065e5:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  8065ea:	85 db                	test   %ebx,%ebx
  8065ec:	0f 84 20 01 00 00    	je     806712 <ip_input+0x214>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  8065f2:	83 ec 0c             	sub    $0xc,%esp
  8065f5:	53                   	push   %ebx
  8065f6:	e8 0c e1 ff ff       	call   804707 <netif_is_up>
  8065fb:	83 c4 10             	add    $0x10,%esp
  8065fe:	84 c0                	test   %al,%al
  806600:	74 d5                	je     8065d7 <ip_input+0xd9>
  806602:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806605:	74 d0                	je     8065d7 <ip_input+0xd9>
  806607:	8b 43 04             	mov    0x4(%ebx),%eax
  80660a:	85 c0                	test   %eax,%eax
  80660c:	74 c9                	je     8065d7 <ip_input+0xd9>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80660e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806611:	3b 42 10             	cmp    0x10(%edx),%eax
  806614:	74 4a                	je     806660 <ip_input+0x162>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806616:	83 ec 08             	sub    $0x8,%esp
  806619:	53                   	push   %ebx
  80661a:	ff 75 dc             	pushl  -0x24(%ebp)
  80661d:	e8 3f fe ff ff       	call   806461 <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806622:	83 c4 10             	add    $0x10,%esp
  806625:	84 c0                	test   %al,%al
  806627:	74 ae                	je     8065d7 <ip_input+0xd9>
  806629:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80662c:	e9 fc 00 00 00       	jmp    80672d <ip_input+0x22f>
        netif = netif->next;
  806631:	8b 1b                	mov    (%ebx),%ebx
  806633:	eb ac                	jmp    8065e1 <ip_input+0xe3>
        netif = netif->next;
  806635:	8b 1b                	mov    (%ebx),%ebx
  806637:	eb ac                	jmp    8065e5 <ip_input+0xe7>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806639:	83 ec 0c             	sub    $0xc,%esp
  80663c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806640:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  806645:	50                   	push   %eax
  806646:	e8 87 10 00 00       	call   8076d2 <ntohs>
  80664b:	83 c4 10             	add    $0x10,%esp
  80664e:	66 83 f8 44          	cmp    $0x44,%ax
  806652:	0f 85 d5 00 00 00    	jne    80672d <ip_input+0x22f>
        netif = inp;
  806658:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80665b:	e9 10 01 00 00       	jmp    806770 <ip_input+0x272>
  806660:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806663:	e9 c5 00 00 00       	jmp    80672d <ip_input+0x22f>
      pbuf_free(p);
  806668:	83 ec 0c             	sub    $0xc,%esp
  80666b:	ff 75 08             	pushl  0x8(%ebp)
  80666e:	e8 70 e1 ff ff       	call   8047e3 <pbuf_free>
      return ERR_OK;
  806673:	83 c4 10             	add    $0x10,%esp
  806676:	e9 b6 fe ff ff       	jmp    806531 <ip_input+0x33>
    pbuf_free(p);
  80667b:	83 ec 0c             	sub    $0xc,%esp
  80667e:	ff 75 08             	pushl  0x8(%ebp)
  806681:	e8 5d e1 ff ff       	call   8047e3 <pbuf_free>
    return ERR_OK;
  806686:	83 c4 10             	add    $0x10,%esp
  806689:	e9 a3 fe ff ff       	jmp    806531 <ip_input+0x33>
      udp_input(p, inp);
  80668e:	83 ec 08             	sub    $0x8,%esp
  806691:	ff 75 0c             	pushl  0xc(%ebp)
  806694:	ff 75 08             	pushl  0x8(%ebp)
  806697:	e8 6f 22 00 00       	call   80890b <udp_input>
      break;
  80669c:	83 c4 10             	add    $0x10,%esp
  80669f:	e9 8d fe ff ff       	jmp    806531 <ip_input+0x33>
      tcp_input(p, inp);
  8066a4:	83 ec 08             	sub    $0x8,%esp
  8066a7:	ff 75 0c             	pushl  0xc(%ebp)
  8066aa:	ff 75 08             	pushl  0x8(%ebp)
  8066ad:	e8 7d 69 00 00       	call   80d02f <tcp_input>
      break;
  8066b2:	83 c4 10             	add    $0x10,%esp
  8066b5:	e9 77 fe ff ff       	jmp    806531 <ip_input+0x33>
      icmp_input(p, inp);
  8066ba:	83 ec 08             	sub    $0x8,%esp
  8066bd:	ff 75 0c             	pushl  0xc(%ebp)
  8066c0:	ff 75 08             	pushl  0x8(%ebp)
  8066c3:	e8 68 79 00 00       	call   80e030 <icmp_input>
      break;
  8066c8:	83 c4 10             	add    $0x10,%esp
  8066cb:	e9 61 fe ff ff       	jmp    806531 <ip_input+0x33>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8066d0:	8b 5f 10             	mov    0x10(%edi),%ebx
  8066d3:	83 ec 0c             	sub    $0xc,%esp
  8066d6:	68 00 00 00 f0       	push   $0xf0000000
  8066db:	e8 16 12 00 00       	call   8078f6 <ntohl>
  8066e0:	21 c3                	and    %eax,%ebx
  8066e2:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8066e9:	e8 08 12 00 00       	call   8078f6 <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8066ee:	83 c4 10             	add    $0x10,%esp
  8066f1:	39 c3                	cmp    %eax,%ebx
  8066f3:	0f 84 18 01 00 00    	je     806811 <ip_input+0x313>
        p->payload = iphdr;
  8066f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8066fc:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8066ff:	83 ec 08             	sub    $0x8,%esp
  806702:	6a 02                	push   $0x2
  806704:	50                   	push   %eax
  806705:	e8 40 7c 00 00       	call   80e34a <icmp_dest_unreach>
  80670a:	83 c4 10             	add    $0x10,%esp
  80670d:	e9 ff 00 00 00       	jmp    806811 <ip_input+0x313>
  806712:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806715:	83 ec 0c             	sub    $0xc,%esp
  806718:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80671c:	50                   	push   %eax
  80671d:	e8 b0 0f 00 00       	call   8076d2 <ntohs>
  806722:	83 c4 10             	add    $0x10,%esp
  806725:	3c 11                	cmp    $0x11,%al
  806727:	0f 84 0c ff ff ff    	je     806639 <ip_input+0x13b>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80672d:	83 ec 08             	sub    $0x8,%esp
  806730:	ff 75 0c             	pushl  0xc(%ebp)
  806733:	8d 47 0c             	lea    0xc(%edi),%eax
  806736:	50                   	push   %eax
  806737:	e8 25 fd ff ff       	call   806461 <ip_addr_isbroadcast>
  80673c:	83 c4 10             	add    $0x10,%esp
  80673f:	84 c0                	test   %al,%al
  806741:	0f 85 21 ff ff ff    	jne    806668 <ip_input+0x16a>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806747:	8b 77 0c             	mov    0xc(%edi),%esi
  80674a:	83 ec 0c             	sub    $0xc,%esp
  80674d:	68 00 00 00 f0       	push   $0xf0000000
  806752:	e8 9f 11 00 00       	call   8078f6 <ntohl>
  806757:	21 c6                	and    %eax,%esi
  806759:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806760:	e8 91 11 00 00       	call   8078f6 <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806765:	83 c4 10             	add    $0x10,%esp
  806768:	39 c6                	cmp    %eax,%esi
  80676a:	0f 84 f8 fe ff ff    	je     806668 <ip_input+0x16a>
  if (netif == NULL) {
  806770:	85 db                	test   %ebx,%ebx
  806772:	0f 84 03 ff ff ff    	je     80667b <ip_input+0x17d>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806778:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  80677c:	83 ec 0c             	sub    $0xc,%esp
  80677f:	68 ff 3f 00 00       	push   $0x3fff
  806784:	e8 3c 0f 00 00       	call   8076c5 <htons>
  806789:	83 c4 10             	add    $0x10,%esp
  80678c:	66 85 c3             	test   %ax,%bx
  80678f:	74 1c                	je     8067ad <ip_input+0x2af>
    p = ip_reass(p);
  806791:	83 ec 0c             	sub    $0xc,%esp
  806794:	ff 75 08             	pushl  0x8(%ebp)
  806797:	e8 95 04 00 00       	call   806c31 <ip_reass>
  80679c:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  80679f:	83 c4 10             	add    $0x10,%esp
  8067a2:	85 c0                	test   %eax,%eax
  8067a4:	0f 84 87 fd ff ff    	je     806531 <ip_input+0x33>
    iphdr = p->payload;
  8067aa:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  8067ad:	83 ec 08             	sub    $0x8,%esp
  8067b0:	ff 75 0c             	pushl  0xc(%ebp)
  8067b3:	ff 75 08             	pushl  0x8(%ebp)
  8067b6:	e8 cb 75 00 00       	call   80dd86 <raw_input>
  8067bb:	83 c4 10             	add    $0x10,%esp
  8067be:	84 c0                	test   %al,%al
  8067c0:	0f 85 6b fd ff ff    	jne    806531 <ip_input+0x33>
    switch (IPH_PROTO(iphdr)) {
  8067c6:	83 ec 0c             	sub    $0xc,%esp
  8067c9:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8067cd:	50                   	push   %eax
  8067ce:	e8 ff 0e 00 00       	call   8076d2 <ntohs>
  8067d3:	0f b6 c0             	movzbl %al,%eax
  8067d6:	83 c4 10             	add    $0x10,%esp
  8067d9:	66 83 f8 06          	cmp    $0x6,%ax
  8067dd:	0f 84 c1 fe ff ff    	je     8066a4 <ip_input+0x1a6>
  8067e3:	66 83 f8 11          	cmp    $0x11,%ax
  8067e7:	0f 84 a1 fe ff ff    	je     80668e <ip_input+0x190>
  8067ed:	66 83 f8 01          	cmp    $0x1,%ax
  8067f1:	0f 84 c3 fe ff ff    	je     8066ba <ip_input+0x1bc>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8067f7:	83 ec 08             	sub    $0x8,%esp
  8067fa:	ff 75 0c             	pushl  0xc(%ebp)
  8067fd:	8d 47 10             	lea    0x10(%edi),%eax
  806800:	50                   	push   %eax
  806801:	e8 5b fc ff ff       	call   806461 <ip_addr_isbroadcast>
  806806:	83 c4 10             	add    $0x10,%esp
  806809:	84 c0                	test   %al,%al
  80680b:	0f 84 bf fe ff ff    	je     8066d0 <ip_input+0x1d2>
      pbuf_free(p);
  806811:	83 ec 0c             	sub    $0xc,%esp
  806814:	ff 75 08             	pushl  0x8(%ebp)
  806817:	e8 c7 df ff ff       	call   8047e3 <pbuf_free>
  80681c:	83 c4 10             	add    $0x10,%esp
  80681f:	e9 0d fd ff ff       	jmp    806531 <ip_input+0x33>

00806824 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806824:	55                   	push   %ebp
  806825:	89 e5                	mov    %esp,%ebp
  806827:	57                   	push   %edi
  806828:	56                   	push   %esi
  806829:	53                   	push   %ebx
  80682a:	83 ec 1c             	sub    $0x1c,%esp
  80682d:	8b 75 08             	mov    0x8(%ebp),%esi
  806830:	8b 7d 14             	mov    0x14(%ebp),%edi
  806833:	8b 45 18             	mov    0x18(%ebp),%eax
  806836:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806839:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80683c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  80683f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806843:	0f 84 42 01 00 00    	je     80698b <ip_output_if+0x167>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806849:	83 ec 08             	sub    $0x8,%esp
  80684c:	6a 14                	push   $0x14
  80684e:	56                   	push   %esi
  80684f:	e8 c2 de ff ff       	call   804716 <pbuf_header>
  806854:	83 c4 10             	add    $0x10,%esp
  806857:	84 c0                	test   %al,%al
  806859:	0f 85 4b 01 00 00    	jne    8069aa <ip_output_if+0x186>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80685f:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806862:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806867:	0f 86 02 01 00 00    	jbe    80696f <ip_output_if+0x14b>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80686d:	83 ec 0c             	sub    $0xc,%esp
  806870:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806874:	50                   	push   %eax
  806875:	e8 58 0e 00 00       	call   8076d2 <ntohs>
  80687a:	0f b6 c0             	movzbl %al,%eax
  80687d:	c1 e7 08             	shl    $0x8,%edi
  806880:	09 c7                	or     %eax,%edi
  806882:	0f b7 ff             	movzwl %di,%edi
  806885:	89 3c 24             	mov    %edi,(%esp)
  806888:	e8 38 0e 00 00       	call   8076c5 <htons>
  80688d:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806891:	0f b7 c0             	movzwl %ax,%eax
  806894:	89 04 24             	mov    %eax,(%esp)
  806897:	e8 36 0e 00 00       	call   8076d2 <ntohs>
  80689c:	89 c2                	mov    %eax,%edx
  80689e:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8068a4:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  8068a8:	09 d0                	or     %edx,%eax
  8068aa:	0f b7 c0             	movzwl %ax,%eax
  8068ad:	89 04 24             	mov    %eax,(%esp)
  8068b0:	e8 10 0e 00 00       	call   8076c5 <htons>
  8068b5:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  8068b9:	8b 45 10             	mov    0x10(%ebp),%eax
  8068bc:	8b 00                	mov    (%eax),%eax
  8068be:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  8068c1:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8068c5:	80 cc 45             	or     $0x45,%ah
  8068c8:	89 04 24             	mov    %eax,(%esp)
  8068cb:	e8 f5 0d 00 00       	call   8076c5 <htons>
  8068d0:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8068d3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8068d7:	89 04 24             	mov    %eax,(%esp)
  8068da:	e8 e6 0d 00 00       	call   8076c5 <htons>
  8068df:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  8068e3:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8068e9:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  8068f0:	89 04 24             	mov    %eax,(%esp)
  8068f3:	e8 cd 0d 00 00       	call   8076c5 <htons>
  8068f8:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  8068fc:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  806903:	01 

    if (ip_addr_isany(src)) {
  806904:	83 c4 10             	add    $0x10,%esp
  806907:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80690b:	74 09                	je     806916 <ip_output_if+0xf2>
  80690d:	8b 45 0c             	mov    0xc(%ebp),%eax
  806910:	8b 00                	mov    (%eax),%eax
  806912:	85 c0                	test   %eax,%eax
  806914:	75 70                	jne    806986 <ip_output_if+0x162>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806916:	b8 00 00 00 00       	mov    $0x0,%eax
  80691b:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  80691f:	74 06                	je     806927 <ip_output_if+0x103>
  806921:	8b 45 20             	mov    0x20(%ebp),%eax
  806924:	8b 40 04             	mov    0x4(%eax),%eax
  806927:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  80692a:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806930:	83 ec 08             	sub    $0x8,%esp
  806933:	6a 14                	push   $0x14
  806935:	53                   	push   %ebx
  806936:	e8 5c 0c 00 00       	call   807597 <inet_chksum>
  80693b:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  80693f:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806942:	8b 45 20             	mov    0x20(%ebp),%eax
  806945:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806949:	66 85 c0             	test   %ax,%ax
  80694c:	74 06                	je     806954 <ip_output_if+0x130>
  80694e:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806952:	72 42                	jb     806996 <ip_output_if+0x172>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806954:	83 ec 04             	sub    $0x4,%esp
  806957:	ff 75 10             	pushl  0x10(%ebp)
  80695a:	56                   	push   %esi
  80695b:	ff 75 20             	pushl  0x20(%ebp)
  80695e:	8b 45 20             	mov    0x20(%ebp),%eax
  806961:	ff 50 14             	call   *0x14(%eax)
  806964:	83 c4 10             	add    $0x10,%esp
  }
}
  806967:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80696a:	5b                   	pop    %ebx
  80696b:	5e                   	pop    %esi
  80696c:	5f                   	pop    %edi
  80696d:	5d                   	pop    %ebp
  80696e:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  80696f:	83 ec 04             	sub    $0x4,%esp
  806972:	68 cc 1e 81 00       	push   $0x811ecc
  806977:	68 ee 01 00 00       	push   $0x1ee
  80697c:	68 f9 1e 81 00       	push   $0x811ef9
  806981:	e8 ea 7b 00 00       	call   80e570 <_panic>
      ip_addr_set(&(iphdr->src), src);
  806986:	89 43 0c             	mov    %eax,0xc(%ebx)
  806989:	eb 9f                	jmp    80692a <ip_output_if+0x106>
    dest = &(iphdr->dest);
  80698b:	8b 46 04             	mov    0x4(%esi),%eax
  80698e:	83 c0 10             	add    $0x10,%eax
  806991:	89 45 10             	mov    %eax,0x10(%ebp)
  806994:	eb ac                	jmp    806942 <ip_output_if+0x11e>
    return ip_frag(p,netif,dest);
  806996:	83 ec 04             	sub    $0x4,%esp
  806999:	ff 75 10             	pushl  0x10(%ebp)
  80699c:	ff 75 20             	pushl  0x20(%ebp)
  80699f:	56                   	push   %esi
  8069a0:	e8 5e 07 00 00       	call   807103 <ip_frag>
  8069a5:	83 c4 10             	add    $0x10,%esp
  8069a8:	eb bd                	jmp    806967 <ip_output_if+0x143>
      return ERR_BUF;
  8069aa:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8069af:	eb b6                	jmp    806967 <ip_output_if+0x143>

008069b1 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8069b1:	55                   	push   %ebp
  8069b2:	89 e5                	mov    %esp,%ebp
  8069b4:	57                   	push   %edi
  8069b5:	56                   	push   %esi
  8069b6:	53                   	push   %ebx
  8069b7:	83 ec 18             	sub    $0x18,%esp
  8069ba:	8b 5d 14             	mov    0x14(%ebp),%ebx
  8069bd:	8b 75 18             	mov    0x18(%ebp),%esi
  8069c0:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  8069c3:	ff 75 10             	pushl  0x10(%ebp)
  8069c6:	e8 d6 fa ff ff       	call   8064a1 <ip_route>
  8069cb:	83 c4 10             	add    $0x10,%esp
  8069ce:	85 c0                	test   %eax,%eax
  8069d0:	74 2d                	je     8069ff <ip_output+0x4e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  8069d2:	83 ec 04             	sub    $0x4,%esp
  8069d5:	50                   	push   %eax
  8069d6:	89 f8                	mov    %edi,%eax
  8069d8:	0f b6 f8             	movzbl %al,%edi
  8069db:	57                   	push   %edi
  8069dc:	89 f0                	mov    %esi,%eax
  8069de:	0f b6 f0             	movzbl %al,%esi
  8069e1:	56                   	push   %esi
  8069e2:	0f b6 db             	movzbl %bl,%ebx
  8069e5:	53                   	push   %ebx
  8069e6:	ff 75 10             	pushl  0x10(%ebp)
  8069e9:	ff 75 0c             	pushl  0xc(%ebp)
  8069ec:	ff 75 08             	pushl  0x8(%ebp)
  8069ef:	e8 30 fe ff ff       	call   806824 <ip_output_if>
  8069f4:	83 c4 20             	add    $0x20,%esp
}
  8069f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8069fa:	5b                   	pop    %ebx
  8069fb:	5e                   	pop    %esi
  8069fc:	5f                   	pop    %edi
  8069fd:	5d                   	pop    %ebp
  8069fe:	c3                   	ret    
    return ERR_RTE;
  8069ff:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806a04:	eb f1                	jmp    8069f7 <ip_output+0x46>

00806a06 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806a06:	55                   	push   %ebp
  806a07:	89 e5                	mov    %esp,%ebp
  806a09:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806a0c:	39 05 e0 49 b3 00    	cmp    %eax,0xb349e0
  806a12:	74 18                	je     806a2c <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806a14:	85 d2                	test   %edx,%edx
  806a16:	74 1e                	je     806a36 <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806a18:	8b 08                	mov    (%eax),%ecx
  806a1a:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806a1c:	83 ec 08             	sub    $0x8,%esp
  806a1f:	50                   	push   %eax
  806a20:	6a 05                	push   $0x5
  806a22:	e8 6c da ff ff       	call   804493 <memp_free>
}
  806a27:	83 c4 10             	add    $0x10,%esp
  806a2a:	c9                   	leave  
  806a2b:	c3                   	ret    
    reassdatagrams = ipr->next;
  806a2c:	8b 10                	mov    (%eax),%edx
  806a2e:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806a34:	eb e6                	jmp    806a1c <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806a36:	83 ec 04             	sub    $0x4,%esp
  806a39:	68 11 1f 81 00       	push   $0x811f11
  806a3e:	68 29 01 00 00       	push   $0x129
  806a43:	68 2a 1f 81 00       	push   $0x811f2a
  806a48:	e8 23 7b 00 00       	call   80e570 <_panic>

00806a4d <ip_reass_free_complete_datagram>:
{
  806a4d:	55                   	push   %ebp
  806a4e:	89 e5                	mov    %esp,%ebp
  806a50:	57                   	push   %edi
  806a51:	56                   	push   %esi
  806a52:	53                   	push   %ebx
  806a53:	83 ec 1c             	sub    $0x1c,%esp
  806a56:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806a59:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806a5c:	39 c2                	cmp    %eax,%edx
  806a5e:	74 53                	je     806ab3 <ip_reass_free_complete_datagram+0x66>
  if (prev != NULL) {
  806a60:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a63:	85 c0                	test   %eax,%eax
  806a65:	74 07                	je     806a6e <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806a67:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806a6a:	39 10                	cmp    %edx,(%eax)
  806a6c:	75 5c                	jne    806aca <ip_reass_free_complete_datagram+0x7d>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a71:	8b 58 04             	mov    0x4(%eax),%ebx
  806a74:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806a77:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806a7c:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806a81:	74 5e                	je     806ae1 <ip_reass_free_complete_datagram+0x94>
  p = ipr->p;
  806a83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a86:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806a89:	85 db                	test   %ebx,%ebx
  806a8b:	0f 84 8f 00 00 00    	je     806b20 <ip_reass_free_complete_datagram+0xd3>
    iprh = (struct ip_reass_helper *)p->payload;
  806a91:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806a94:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806a96:	83 ec 0c             	sub    $0xc,%esp
  806a99:	53                   	push   %ebx
  806a9a:	e8 8e e1 ff ff       	call   804c2d <pbuf_clen>
  806a9f:	0f b6 c0             	movzbl %al,%eax
  806aa2:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806aa4:	89 1c 24             	mov    %ebx,(%esp)
  806aa7:	e8 37 dd ff ff       	call   8047e3 <pbuf_free>
  806aac:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806aaf:	89 fb                	mov    %edi,%ebx
  806ab1:	eb d6                	jmp    806a89 <ip_reass_free_complete_datagram+0x3c>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806ab3:	83 ec 04             	sub    $0x4,%esp
  806ab6:	68 47 1f 81 00       	push   $0x811f47
  806abb:	68 99 00 00 00       	push   $0x99
  806ac0:	68 2a 1f 81 00       	push   $0x811f2a
  806ac5:	e8 a6 7a 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806aca:	83 ec 04             	sub    $0x4,%esp
  806acd:	68 53 1f 81 00       	push   $0x811f53
  806ad2:	68 9b 00 00 00       	push   $0x9b
  806ad7:	68 2a 1f 81 00       	push   $0x811f2a
  806adc:	e8 8f 7a 00 00       	call   80e570 <_panic>
    ipr->p = iprh->next_pbuf;
  806ae1:	8b 00                	mov    (%eax),%eax
  806ae3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806ae6:	89 41 04             	mov    %eax,0x4(%ecx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806ae9:	83 ec 04             	sub    $0x4,%esp
  806aec:	6a 14                	push   $0x14
  806aee:	8d 41 08             	lea    0x8(%ecx),%eax
  806af1:	50                   	push   %eax
  806af2:	ff 73 04             	pushl  0x4(%ebx)
  806af5:	e8 1d 83 00 00       	call   80ee17 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806afa:	83 c4 08             	add    $0x8,%esp
  806afd:	6a 01                	push   $0x1
  806aff:	53                   	push   %ebx
  806b00:	e8 28 79 00 00       	call   80e42d <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806b05:	89 1c 24             	mov    %ebx,(%esp)
  806b08:	e8 20 e1 ff ff       	call   804c2d <pbuf_clen>
  806b0d:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806b10:	89 1c 24             	mov    %ebx,(%esp)
  806b13:	e8 cb dc ff ff       	call   8047e3 <pbuf_free>
  806b18:	83 c4 10             	add    $0x10,%esp
  806b1b:	e9 63 ff ff ff       	jmp    806a83 <ip_reass_free_complete_datagram+0x36>
  ip_reass_dequeue_datagram(ipr, prev);
  806b20:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806b23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b26:	e8 db fe ff ff       	call   806a06 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806b2b:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806b32:	0f b7 d0             	movzwl %ax,%edx
  806b35:	39 f2                	cmp    %esi,%edx
  806b37:	7c 12                	jl     806b4b <ip_reass_free_complete_datagram+0xfe>
  ip_reass_pbufcount -= pbufs_freed;
  806b39:	29 f0                	sub    %esi,%eax
  806b3b:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc
}
  806b41:	89 f0                	mov    %esi,%eax
  806b43:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806b46:	5b                   	pop    %ebx
  806b47:	5e                   	pop    %esi
  806b48:	5f                   	pop    %edi
  806b49:	5d                   	pop    %ebp
  806b4a:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806b4b:	83 ec 04             	sub    $0x4,%esp
  806b4e:	68 65 1f 81 00       	push   $0x811f65
  806b53:	68 bc 00 00 00       	push   $0xbc
  806b58:	68 2a 1f 81 00       	push   $0x811f2a
  806b5d:	e8 0e 7a 00 00       	call   80e570 <_panic>

00806b62 <ip_reass_remove_oldest_datagram>:
{
  806b62:	55                   	push   %ebp
  806b63:	89 e5                	mov    %esp,%ebp
  806b65:	57                   	push   %edi
  806b66:	56                   	push   %esi
  806b67:	53                   	push   %ebx
  806b68:	83 ec 1c             	sub    $0x1c,%esp
  806b6b:	89 c6                	mov    %eax,%esi
  806b6d:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806b70:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806b77:	eb 5b                	jmp    806bd4 <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806b79:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806b7d:	85 c0                	test   %eax,%eax
  806b7f:	74 33                	je     806bb4 <ip_reass_remove_oldest_datagram+0x52>
          oldest = r;
  806b81:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806b85:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806b88:	0f 46 c1             	cmovbe %ecx,%eax
      if (r->next != NULL) {
  806b8b:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806b8d:	85 ff                	test   %edi,%edi
  806b8f:	0f 45 d1             	cmovne %ecx,%edx
  806b92:	89 f9                	mov    %edi,%ecx
    while (r != NULL) {
  806b94:	85 c9                	test   %ecx,%ecx
  806b96:	74 20                	je     806bb8 <ip_reass_remove_oldest_datagram+0x56>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806b98:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806b9b:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806b9e:	75 d9                	jne    806b79 <ip_reass_remove_oldest_datagram+0x17>
  806ba0:	8b 7e 10             	mov    0x10(%esi),%edi
  806ba3:	39 79 18             	cmp    %edi,0x18(%ecx)
  806ba6:	75 d1                	jne    806b79 <ip_reass_remove_oldest_datagram+0x17>
  806ba8:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806bac:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806bb0:	75 c7                	jne    806b79 <ip_reass_remove_oldest_datagram+0x17>
  806bb2:	eb d7                	jmp    806b8b <ip_reass_remove_oldest_datagram+0x29>
          oldest = r;
  806bb4:	89 c8                	mov    %ecx,%eax
  806bb6:	eb d3                	jmp    806b8b <ip_reass_remove_oldest_datagram+0x29>
  806bb8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    if (oldest != NULL) {
  806bbb:	85 c0                	test   %eax,%eax
  806bbd:	74 08                	je     806bc7 <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806bbf:	e8 89 fe ff ff       	call   806a4d <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806bc4:	01 45 e0             	add    %eax,-0x20(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806bc7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806bca:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806bcd:	7d 1f                	jge    806bee <ip_reass_remove_oldest_datagram+0x8c>
  806bcf:	83 fb 01             	cmp    $0x1,%ebx
  806bd2:	7e 1a                	jle    806bee <ip_reass_remove_oldest_datagram+0x8c>
    r = reassdatagrams;
  806bd4:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
    other_datagrams = 0;
  806bda:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806bdf:	ba 00 00 00 00       	mov    $0x0,%edx
    oldest = NULL;
  806be4:	b8 00 00 00 00       	mov    $0x0,%eax
  806be9:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    while (r != NULL) {
  806bec:	eb a6                	jmp    806b94 <ip_reass_remove_oldest_datagram+0x32>
}
  806bee:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806bf1:	83 c4 1c             	add    $0x1c,%esp
  806bf4:	5b                   	pop    %ebx
  806bf5:	5e                   	pop    %esi
  806bf6:	5f                   	pop    %edi
  806bf7:	5d                   	pop    %ebp
  806bf8:	c3                   	ret    

00806bf9 <ip_reass_tmr>:
{
  806bf9:	55                   	push   %ebp
  806bfa:	89 e5                	mov    %esp,%ebp
  806bfc:	56                   	push   %esi
  806bfd:	53                   	push   %ebx
  r = reassdatagrams;
  806bfe:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806c03:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806c08:	eb 0b                	jmp    806c15 <ip_reass_tmr+0x1c>
      r = r->next;
  806c0a:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806c0c:	89 da                	mov    %ebx,%edx
  806c0e:	e8 3a fe ff ff       	call   806a4d <ip_reass_free_complete_datagram>
      r = r->next;
  806c13:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806c15:	85 c0                	test   %eax,%eax
  806c17:	74 14                	je     806c2d <ip_reass_tmr+0x34>
    if (r->timer > 0) {
  806c19:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806c1d:	84 d2                	test   %dl,%dl
  806c1f:	74 e9                	je     806c0a <ip_reass_tmr+0x11>
      r->timer--;
  806c21:	83 ea 01             	sub    $0x1,%edx
  806c24:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806c27:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806c29:	8b 00                	mov    (%eax),%eax
  806c2b:	eb e8                	jmp    806c15 <ip_reass_tmr+0x1c>
}
  806c2d:	5b                   	pop    %ebx
  806c2e:	5e                   	pop    %esi
  806c2f:	5d                   	pop    %ebp
  806c30:	c3                   	ret    

00806c31 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806c31:	55                   	push   %ebp
  806c32:	89 e5                	mov    %esp,%ebp
  806c34:	57                   	push   %edi
  806c35:	56                   	push   %esi
  806c36:	53                   	push   %ebx
  806c37:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806c3a:	8b 45 08             	mov    0x8(%ebp),%eax
  806c3d:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806c40:	0f b7 03             	movzwl (%ebx),%eax
  806c43:	50                   	push   %eax
  806c44:	e8 89 0a 00 00       	call   8076d2 <ntohs>
  806c49:	66 c1 e8 08          	shr    $0x8,%ax
  806c4d:	83 e0 0f             	and    $0xf,%eax
  806c50:	83 c4 10             	add    $0x10,%esp
  806c53:	83 f8 05             	cmp    $0x5,%eax
  806c56:	0f 85 dc 01 00 00    	jne    806e38 <ip_reass+0x207>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806c5c:	83 ec 0c             	sub    $0xc,%esp
  806c5f:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806c63:	50                   	push   %eax
  806c64:	e8 69 0a 00 00       	call   8076d2 <ntohs>
  806c69:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806c6d:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806c71:	89 04 24             	mov    %eax,(%esp)
  806c74:	e8 59 0a 00 00       	call   8076d2 <ntohs>
  806c79:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806c7d:	0f b7 03             	movzwl (%ebx),%eax
  806c80:	89 04 24             	mov    %eax,(%esp)
  806c83:	e8 4a 0a 00 00       	call   8076d2 <ntohs>
  806c88:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806c8c:	83 c4 04             	add    $0x4,%esp
  806c8f:	ff 75 08             	pushl  0x8(%ebp)
  806c92:	e8 96 df ff ff       	call   804c2d <pbuf_clen>
  806c97:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806c9a:	0f b6 f0             	movzbl %al,%esi
  806c9d:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806ca4:	01 f0                	add    %esi,%eax
  806ca6:	83 c4 10             	add    $0x10,%esp
  806ca9:	83 f8 0a             	cmp    $0xa,%eax
  806cac:	7f 0d                	jg     806cbb <ip_reass+0x8a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806cae:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806cb4:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806cb9:	eb 28                	jmp    806ce3 <ip_reass+0xb2>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806cbb:	89 f2                	mov    %esi,%edx
  806cbd:	89 d8                	mov    %ebx,%eax
  806cbf:	e8 9e fe ff ff       	call   806b62 <ip_reass_remove_oldest_datagram>
  806cc4:	85 c0                	test   %eax,%eax
  806cc6:	0f 84 6c 01 00 00    	je     806e38 <ip_reass+0x207>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806ccc:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806cd3:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806cd5:	83 f8 0a             	cmp    $0xa,%eax
  806cd8:	7e d4                	jle    806cae <ip_reass+0x7d>
  806cda:	e9 59 01 00 00       	jmp    806e38 <ip_reass+0x207>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806cdf:	89 f8                	mov    %edi,%eax
  806ce1:	8b 3f                	mov    (%edi),%edi
  806ce3:	85 ff                	test   %edi,%edi
  806ce5:	0f 84 f5 00 00 00    	je     806de0 <ip_reass+0x1af>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806ceb:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806cee:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806cf1:	75 ec                	jne    806cdf <ip_reass+0xae>
  806cf3:	8b 53 10             	mov    0x10(%ebx),%edx
  806cf6:	39 57 18             	cmp    %edx,0x18(%edi)
  806cf9:	75 e4                	jne    806cdf <ip_reass+0xae>
  806cfb:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806cff:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806d03:	75 da                	jne    806cdf <ip_reass+0xae>
  806d05:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806d08:	83 ec 0c             	sub    $0xc,%esp
  806d0b:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d0f:	50                   	push   %eax
  806d10:	e8 bd 09 00 00       	call   8076d2 <ntohs>
  806d15:	83 c4 10             	add    $0x10,%esp
  806d18:	66 a9 ff 1f          	test   $0x1fff,%ax
  806d1c:	0f 84 4b 01 00 00    	je     806e6d <ip_reass+0x23c>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806d22:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806d26:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806d2d:	83 ec 0c             	sub    $0xc,%esp
  806d30:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d34:	50                   	push   %eax
  806d35:	e8 98 09 00 00       	call   8076d2 <ntohs>
  806d3a:	83 c4 10             	add    $0x10,%esp
  806d3d:	f6 c4 20             	test   $0x20,%ah
  806d40:	75 20                	jne    806d62 <ip_reass+0x131>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806d42:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806d46:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806d4a:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806d4e:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d51:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806d55:	66 c1 ea 06          	shr    $0x6,%dx
  806d59:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806d5c:	29 d0                	sub    %edx,%eax
  806d5e:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806d62:	8b 45 08             	mov    0x8(%ebp),%eax
  806d65:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d68:	83 ec 0c             	sub    $0xc,%esp
  806d6b:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806d6f:	50                   	push   %eax
  806d70:	e8 5d 09 00 00       	call   8076d2 <ntohs>
  806d75:	89 c6                	mov    %eax,%esi
  806d77:	0f b7 03             	movzwl (%ebx),%eax
  806d7a:	89 04 24             	mov    %eax,(%esp)
  806d7d:	e8 50 09 00 00       	call   8076d2 <ntohs>
  806d82:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806d86:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d8a:	89 04 24             	mov    %eax,(%esp)
  806d8d:	e8 40 09 00 00       	call   8076d2 <ntohs>
  806d92:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  iprh = (struct ip_reass_helper*)new_p->payload;
  806d99:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806d9c:	8b 51 04             	mov    0x4(%ecx),%edx
  806d9f:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  806da2:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806da8:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806dac:	01 de                	add    %ebx,%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806dae:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806db2:	66 c1 e8 06          	shr    $0x6,%ax
  806db6:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  806db9:	29 c6                	sub    %eax,%esi
  806dbb:	66 89 75 de          	mov    %si,-0x22(%ebp)
  806dbf:	66 89 72 06          	mov    %si,0x6(%edx)
  for (q = ipr->p; q != NULL;) {
  806dc3:	8b 47 04             	mov    0x4(%edi),%eax
  806dc6:	89 45 d8             	mov    %eax,-0x28(%ebp)
  806dc9:	83 c4 10             	add    $0x10,%esp
  int valid = 1;
  806dcc:	b9 01 00 00 00       	mov    $0x1,%ecx
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806dd1:	be 00 00 00 00       	mov    $0x0,%esi
  806dd6:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806dd9:	89 cf                	mov    %ecx,%edi
  806ddb:	e9 25 01 00 00       	jmp    806f05 <ip_reass+0x2d4>
  806de0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  806de3:	83 ec 0c             	sub    $0xc,%esp
  806de6:	6a 05                	push   $0x5
  806de8:	e8 50 d6 ff ff       	call   80443d <memp_malloc>
  806ded:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806def:	83 c4 10             	add    $0x10,%esp
  806df2:	85 c0                	test   %eax,%eax
  806df4:	74 35                	je     806e2b <ip_reass+0x1fa>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806df6:	83 ec 04             	sub    $0x4,%esp
  806df9:	6a 20                	push   $0x20
  806dfb:	6a 00                	push   $0x0
  806dfd:	57                   	push   %edi
  806dfe:	e8 6a 7f 00 00       	call   80ed6d <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806e03:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  806e07:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806e0c:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806e0e:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806e14:	83 c4 0c             	add    $0xc,%esp
  806e17:	6a 14                	push   $0x14
  806e19:	53                   	push   %ebx
  806e1a:	8d 47 08             	lea    0x8(%edi),%eax
  806e1d:	50                   	push   %eax
  806e1e:	e8 f4 7f 00 00       	call   80ee17 <memcpy>
  806e23:	83 c4 10             	add    $0x10,%esp
  806e26:	e9 f7 fe ff ff       	jmp    806d22 <ip_reass+0xf1>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806e2b:	89 f2                	mov    %esi,%edx
  806e2d:	89 d8                	mov    %ebx,%eax
  806e2f:	e8 2e fd ff ff       	call   806b62 <ip_reass_remove_oldest_datagram>
  806e34:	39 c6                	cmp    %eax,%esi
  806e36:	7e 20                	jle    806e58 <ip_reass+0x227>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  806e38:	83 ec 0c             	sub    $0xc,%esp
  806e3b:	ff 75 08             	pushl  0x8(%ebp)
  806e3e:	e8 a0 d9 ff ff       	call   8047e3 <pbuf_free>
  return NULL;
  806e43:	83 c4 10             	add    $0x10,%esp
  806e46:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  806e4d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806e50:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806e53:	5b                   	pop    %ebx
  806e54:	5e                   	pop    %esi
  806e55:	5f                   	pop    %edi
  806e56:	5d                   	pop    %ebp
  806e57:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  806e58:	83 ec 0c             	sub    $0xc,%esp
  806e5b:	6a 05                	push   $0x5
  806e5d:	e8 db d5 ff ff       	call   80443d <memp_malloc>
  806e62:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  806e64:	83 c4 10             	add    $0x10,%esp
  806e67:	85 c0                	test   %eax,%eax
  806e69:	75 8b                	jne    806df6 <ip_reass+0x1c5>
  806e6b:	eb cb                	jmp    806e38 <ip_reass+0x207>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806e6d:	83 ec 0c             	sub    $0xc,%esp
  806e70:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806e74:	50                   	push   %eax
  806e75:	e8 58 08 00 00       	call   8076d2 <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806e7a:	83 c4 10             	add    $0x10,%esp
  806e7d:	66 a9 ff 1f          	test   $0x1fff,%ax
  806e81:	0f 84 9b fe ff ff    	je     806d22 <ip_reass+0xf1>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806e87:	83 ec 04             	sub    $0x4,%esp
  806e8a:	6a 14                	push   $0x14
  806e8c:	53                   	push   %ebx
  806e8d:	8d 47 08             	lea    0x8(%edi),%eax
  806e90:	50                   	push   %eax
  806e91:	e8 81 7f 00 00       	call   80ee17 <memcpy>
  806e96:	83 c4 10             	add    $0x10,%esp
  806e99:	e9 84 fe ff ff       	jmp    806d22 <ip_reass+0xf1>
  806e9e:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806ea1:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  806ea4:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806ea7:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806ea9:	85 f6                	test   %esi,%esi
  806eab:	74 4c                	je     806ef9 <ip_reass+0x2c8>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806ead:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806eb1:	0f 82 c5 01 00 00    	jb     80707c <ip_reass+0x44b>
  806eb7:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  806ebb:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806ebf:	0f 87 b7 01 00 00    	ja     80707c <ip_reass+0x44b>
        iprh_prev->next_pbuf = new_p;
  806ec5:	8b 45 08             	mov    0x8(%ebp),%eax
  806ec8:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806eca:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806ece:	0f 84 cb 01 00 00    	je     80709f <ip_reass+0x46e>
    if (valid) {
  806ed4:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806ed8:	0f 84 c1 01 00 00    	je     80709f <ip_reass+0x46e>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806ede:	8b 4f 04             	mov    0x4(%edi),%ecx
  806ee1:	8b 59 04             	mov    0x4(%ecx),%ebx
  806ee4:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806ee9:	0f 85 b0 01 00 00    	jne    80709f <ip_reass+0x46e>
        q = iprh->next_pbuf;
  806eef:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806ef2:	8b 16                	mov    (%esi),%edx
  806ef4:	e9 85 00 00 00       	jmp    806f7e <ip_reass+0x34d>
        ipr->p = new_p;
  806ef9:	8b 45 08             	mov    0x8(%ebp),%eax
  806efc:	89 47 04             	mov    %eax,0x4(%edi)
  806eff:	eb c9                	jmp    806eca <ip_reass+0x299>
    q = iprh_tmp->next_pbuf;
  806f01:	8b 02                	mov    (%edx),%eax
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806f03:	89 d6                	mov    %edx,%esi
  for (q = ipr->p; q != NULL;) {
  806f05:	85 c0                	test   %eax,%eax
  806f07:	0f 84 c8 01 00 00    	je     8070d5 <ip_reass+0x4a4>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806f0d:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  806f10:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  806f14:	66 39 cb             	cmp    %cx,%bx
  806f17:	72 85                	jb     806e9e <ip_reass+0x26d>
    } else if(iprh->start == iprh_tmp->start) {
  806f19:	0f 84 5d 01 00 00    	je     80707c <ip_reass+0x44b>
    } else if(iprh->start < iprh_tmp->end) {
  806f1f:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  806f23:	0f 82 53 01 00 00    	jb     80707c <ip_reass+0x44b>
      if (iprh_prev != NULL) {
  806f29:	85 f6                	test   %esi,%esi
  806f2b:	74 d4                	je     806f01 <ip_reass+0x2d0>
          valid = 0;
  806f2d:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806f31:	b8 00 00 00 00       	mov    $0x0,%eax
  806f36:	0f 45 f8             	cmovne %eax,%edi
  806f39:	eb c6                	jmp    806f01 <ip_reass+0x2d0>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806f3b:	83 ec 04             	sub    $0x4,%esp
  806f3e:	68 80 1f 81 00       	push   $0x811f80
  806f43:	68 83 01 00 00       	push   $0x183
  806f48:	68 2a 1f 81 00       	push   $0x811f2a
  806f4d:	e8 1e 76 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806f52:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  806f56:	75 0b                	jne    806f63 <ip_reass+0x332>
      ipr->p = new_p;
  806f58:	8b 45 08             	mov    0x8(%ebp),%eax
  806f5b:	89 47 04             	mov    %eax,0x4(%edi)
  806f5e:	e9 67 ff ff ff       	jmp    806eca <ip_reass+0x299>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806f63:	83 ec 04             	sub    $0x4,%esp
  806f66:	68 ac 1f 81 00       	push   $0x811fac
  806f6b:	68 8c 01 00 00       	push   $0x18c
  806f70:	68 2a 1f 81 00       	push   $0x811f2a
  806f75:	e8 f6 75 00 00       	call   80e570 <_panic>
          q = iprh->next_pbuf;
  806f7a:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  806f7c:	89 c6                	mov    %eax,%esi
        while (q != NULL) {
  806f7e:	85 d2                	test   %edx,%edx
  806f80:	74 12                	je     806f94 <ip_reass+0x363>
          iprh = (struct ip_reass_helper*)q->payload;
  806f82:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806f85:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806f89:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806f8d:	74 eb                	je     806f7a <ip_reass+0x349>
  806f8f:	e9 0b 01 00 00       	jmp    80709f <ip_reass+0x46e>
  806f94:	89 75 e0             	mov    %esi,-0x20(%ebp)
          LWIP_ASSERT("sanity check",
  806f97:	39 f3                	cmp    %esi,%ebx
  806f99:	0f 84 98 00 00 00    	je     807037 <ip_reass+0x406>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  806f9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806fa2:	83 38 00             	cmpl   $0x0,(%eax)
  806fa5:	0f 85 a3 00 00 00    	jne    80704e <ip_reass+0x41d>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  806fab:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  806faf:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806fb2:	66 39 46 06          	cmp    %ax,0x6(%esi)
  806fb6:	0f 85 a9 00 00 00    	jne    807065 <ip_reass+0x434>
    ipr->datagram_len += IP_HLEN;
  806fbc:	83 c0 14             	add    $0x14,%eax
  806fbf:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  806fc3:	8b 71 04             	mov    0x4(%ecx),%esi
  806fc6:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  806fc8:	83 ec 04             	sub    $0x4,%esp
  806fcb:	6a 14                	push   $0x14
  806fcd:	8d 47 08             	lea    0x8(%edi),%eax
  806fd0:	50                   	push   %eax
  806fd1:	56                   	push   %esi
  806fd2:	e8 40 7e 00 00       	call   80ee17 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  806fd7:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  806fdb:	89 04 24             	mov    %eax,(%esp)
  806fde:	e8 e2 06 00 00       	call   8076c5 <htons>
  806fe3:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  806fe7:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  806fed:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  806ff3:	83 c4 08             	add    $0x8,%esp
  806ff6:	6a 14                	push   $0x14
  806ff8:	56                   	push   %esi
  806ff9:	e8 99 05 00 00       	call   807597 <inet_chksum>
  806ffe:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  807002:	8b 47 04             	mov    0x4(%edi),%eax
  807005:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  807008:	83 c4 10             	add    $0x10,%esp
  80700b:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80700e:	89 c7                	mov    %eax,%edi
  807010:	85 db                	test   %ebx,%ebx
  807012:	0f 84 93 00 00 00    	je     8070ab <ip_reass+0x47a>
      iprh = (struct ip_reass_helper*)r->payload;
  807018:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  80701b:	83 ec 08             	sub    $0x8,%esp
  80701e:	6a ec                	push   $0xffffffec
  807020:	53                   	push   %ebx
  807021:	e8 f0 d6 ff ff       	call   804716 <pbuf_header>
      pbuf_cat(p, r);
  807026:	83 c4 08             	add    $0x8,%esp
  807029:	53                   	push   %ebx
  80702a:	57                   	push   %edi
  80702b:	e8 26 dc ff ff       	call   804c56 <pbuf_cat>
      r = iprh->next_pbuf;
  807030:	8b 1e                	mov    (%esi),%ebx
  807032:	83 c4 10             	add    $0x10,%esp
  807035:	eb d9                	jmp    807010 <ip_reass+0x3df>
          LWIP_ASSERT("sanity check",
  807037:	83 ec 04             	sub    $0x4,%esp
  80703a:	68 9e 1f 81 00       	push   $0x811f9e
  80703f:	68 ae 01 00 00       	push   $0x1ae
  807044:	68 2a 1f 81 00       	push   $0x811f2a
  807049:	e8 22 75 00 00       	call   80e570 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80704e:	83 ec 04             	sub    $0x4,%esp
  807051:	68 e4 1f 81 00       	push   $0x811fe4
  807056:	68 b0 01 00 00       	push   $0x1b0
  80705b:	68 2a 1f 81 00       	push   $0x811f2a
  807060:	e8 0b 75 00 00       	call   80e570 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807065:	83 ec 04             	sub    $0x4,%esp
  807068:	68 08 20 81 00       	push   $0x812008
  80706d:	68 b2 01 00 00       	push   $0x1b2
  807072:	68 2a 1f 81 00       	push   $0x811f2a
  807077:	e8 f4 74 00 00       	call   80e570 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80707c:	83 ec 0c             	sub    $0xc,%esp
  80707f:	ff 75 08             	pushl  0x8(%ebp)
  807082:	e8 a6 db ff ff       	call   804c2d <pbuf_clen>
  807087:	0f b6 c0             	movzbl %al,%eax
  80708a:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  807091:	83 c4 04             	add    $0x4,%esp
  807094:	ff 75 08             	pushl  0x8(%ebp)
  807097:	e8 47 d7 ff ff       	call   8047e3 <pbuf_free>
  80709c:	83 c4 10             	add    $0x10,%esp
  return NULL;
  80709f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8070a6:	e9 a2 fd ff ff       	jmp    806e4d <ip_reass+0x21c>
  8070ab:	8b 7d e0             	mov    -0x20(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8070ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8070b1:	89 f8                	mov    %edi,%eax
  8070b3:	e8 4e f9 ff ff       	call   806a06 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  8070b8:	83 ec 0c             	sub    $0xc,%esp
  8070bb:	ff 75 e4             	pushl  -0x1c(%ebp)
  8070be:	e8 6a db ff ff       	call   804c2d <pbuf_clen>
  8070c3:	0f b6 c0             	movzbl %al,%eax
  8070c6:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
    return p;
  8070cd:	83 c4 10             	add    $0x10,%esp
  8070d0:	e9 78 fd ff ff       	jmp    806e4d <ip_reass+0x21c>
  8070d5:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8070d8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  8070db:	85 f6                	test   %esi,%esi
  8070dd:	0f 84 6f fe ff ff    	je     806f52 <ip_reass+0x321>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8070e3:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8070e7:	66 39 c3             	cmp    %ax,%bx
  8070ea:	0f 82 4b fe ff ff    	jb     806f3b <ip_reass+0x30a>
      iprh_prev->next_pbuf = new_p;
  8070f0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8070f3:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  8070f5:	8b 75 e0             	mov    -0x20(%ebp),%esi
  8070f8:	66 3b 46 04          	cmp    0x4(%esi),%ax
  8070fc:	75 a1                	jne    80709f <ip_reass+0x46e>
  8070fe:	e9 c7 fd ff ff       	jmp    806eca <ip_reass+0x299>

00807103 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807103:	55                   	push   %ebp
  807104:	89 e5                	mov    %esp,%ebp
  807106:	57                   	push   %edi
  807107:	56                   	push   %esi
  807108:	53                   	push   %ebx
  807109:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  80710c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80710f:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807113:	6a 02                	push   $0x2
  807115:	6a 00                	push   $0x0
  807117:	6a 02                	push   $0x2
  807119:	e8 8b d7 ff ff       	call   8048a9 <pbuf_alloc>
  80711e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  807121:	83 c4 10             	add    $0x10,%esp
  807124:	85 c0                	test   %eax,%eax
  807126:	0f 84 c6 00 00 00    	je     8071f2 <ip_frag+0xef>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  80712c:	66 89 70 0a          	mov    %si,0xa(%eax)
  807130:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807134:	bb 03 44 b3 00       	mov    $0xb34403,%ebx
  807139:	83 e3 fc             	and    $0xfffffffc,%ebx
  80713c:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  80713f:	83 ec 04             	sub    $0x4,%esp
  807142:	6a 14                	push   $0x14
  807144:	8b 45 08             	mov    0x8(%ebp),%eax
  807147:	ff 70 04             	pushl  0x4(%eax)
  80714a:	53                   	push   %ebx
  80714b:	e8 c7 7c 00 00       	call   80ee17 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  807150:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807154:	89 04 24             	mov    %eax,(%esp)
  807157:	e8 76 05 00 00       	call   8076d2 <ntohs>
  ofo = tmp & IP_OFFMASK;
  80715c:	89 c7                	mov    %eax,%edi
  80715e:	66 81 e7 ff 1f       	and    $0x1fff,%di
  807163:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
  omf = tmp & IP_MF;
  807167:	66 25 00 20          	and    $0x2000,%ax
  80716b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  80716f:	8b 45 08             	mov    0x8(%ebp),%eax
  807172:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807176:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80717a:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  80717d:	0f b7 f6             	movzwl %si,%esi
  807180:	8d 46 f3             	lea    -0xd(%esi),%eax
  807183:	83 c4 10             	add    $0x10,%esp
  807186:	89 f2                	mov    %esi,%edx
  807188:	83 ea 14             	sub    $0x14,%edx
  80718b:	0f 49 c2             	cmovns %edx,%eax
  80718e:	c1 f8 03             	sar    $0x3,%eax
  807191:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807195:	c1 e0 03             	shl    $0x3,%eax
  807198:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80719c:	0f b7 d0             	movzwl %ax,%edx
  80719f:	89 55 cc             	mov    %edx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8071a2:	83 c0 14             	add    $0x14,%eax
  8071a5:	0f b7 c0             	movzwl %ax,%eax
  8071a8:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  8071ab:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    last = (left <= mtu - IP_HLEN);
  8071b1:	8d 46 ed             	lea    -0x13(%esi),%eax
  8071b4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8071b7:	8d 43 14             	lea    0x14(%ebx),%eax
  8071ba:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (left) {
  8071bd:	e9 e3 00 00 00       	jmp    8072a5 <ip_frag+0x1a2>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8071c2:	83 ec 0c             	sub    $0xc,%esp
  8071c5:	ff 75 dc             	pushl  -0x24(%ebp)
  8071c8:	e8 16 d6 ff ff       	call   8047e3 <pbuf_free>
      return ERR_MEM;
  8071cd:	83 c4 10             	add    $0x10,%esp
  8071d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8071d5:	eb 13                	jmp    8071ea <ip_frag+0xe7>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8071d7:	83 ec 0c             	sub    $0xc,%esp
  8071da:	ff 75 dc             	pushl  -0x24(%ebp)
  8071dd:	e8 01 d6 ff ff       	call   8047e3 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8071e2:	83 c4 10             	add    $0x10,%esp
  8071e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8071ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8071ed:	5b                   	pop    %ebx
  8071ee:	5e                   	pop    %esi
  8071ef:	5f                   	pop    %edi
  8071f0:	5d                   	pop    %ebp
  8071f1:	c3                   	ret    
    return ERR_MEM;
  8071f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8071f7:	eb f1                	jmp    8071ea <ip_frag+0xe7>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8071f9:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  8071fd:	52                   	push   %edx
  8071fe:	50                   	push   %eax
  8071ff:	ff 75 d0             	pushl  -0x30(%ebp)
  807202:	ff 75 08             	pushl  0x8(%ebp)
  807205:	e8 55 dd ff ff       	call   804f5f <pbuf_copy_partial>
  80720a:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  80720e:	0f b7 f6             	movzwl %si,%esi
  807211:	89 34 24             	mov    %esi,(%esp)
  807214:	e8 ac 04 00 00       	call   8076c5 <htons>
  807219:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80721d:	8d 77 14             	lea    0x14(%edi),%esi
  807220:	0f b7 f6             	movzwl %si,%esi
  807223:	89 34 24             	mov    %esi,(%esp)
  807226:	e8 9a 04 00 00       	call   8076c5 <htons>
  80722b:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  80722f:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  807235:	83 c4 08             	add    $0x8,%esp
  807238:	6a 14                	push   $0x14
  80723a:	53                   	push   %ebx
  80723b:	e8 57 03 00 00       	call   807597 <inet_chksum>
  807240:	66 89 43 0a          	mov    %ax,0xa(%ebx)
      pbuf_realloc(rambuf, left + IP_HLEN);
  807244:	83 c4 08             	add    $0x8,%esp
  807247:	56                   	push   %esi
  807248:	ff 75 dc             	pushl  -0x24(%ebp)
  80724b:	e8 cb d8 ff ff       	call   804b1b <pbuf_realloc>
  807250:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  807253:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  807257:	83 ec 04             	sub    $0x4,%esp
  80725a:	6a 00                	push   $0x0
  80725c:	6a 00                	push   $0x0
  80725e:	6a 02                	push   $0x2
  807260:	e8 44 d6 ff ff       	call   8048a9 <pbuf_alloc>
  807265:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  807267:	83 c4 10             	add    $0x10,%esp
  80726a:	85 c0                	test   %eax,%eax
  80726c:	0f 84 50 ff ff ff    	je     8071c2 <ip_frag+0xbf>
      pbuf_chain(header, rambuf);
  807272:	83 ec 08             	sub    $0x8,%esp
  807275:	ff 75 dc             	pushl  -0x24(%ebp)
  807278:	50                   	push   %eax
  807279:	e8 46 da ff ff       	call   804cc4 <pbuf_chain>
      netif->output(netif, header, dest);
  80727e:	83 c4 0c             	add    $0xc,%esp
  807281:	ff 75 10             	pushl  0x10(%ebp)
  807284:	56                   	push   %esi
  807285:	ff 75 0c             	pushl  0xc(%ebp)
  807288:	8b 45 0c             	mov    0xc(%ebp),%eax
  80728b:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  80728e:	89 34 24             	mov    %esi,(%esp)
  807291:	e8 4d d5 ff ff       	call   8047e3 <pbuf_free>
    left -= cop;
  807296:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
    ofo += nfb;
  80729a:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  80729e:	66 01 55 e6          	add    %dx,-0x1a(%ebp)
  8072a2:	83 c4 10             	add    $0x10,%esp
  while (left) {
  8072a5:	66 85 ff             	test   %di,%di
  8072a8:	0f 84 29 ff ff ff    	je     8071d7 <ip_frag+0xd4>
    last = (left <= mtu - IP_HLEN);
  8072ae:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  8072b1:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
  8072b5:	66 81 e6 ff 1f       	and    $0x1fff,%si
  8072ba:	66 0b 75 e0          	or     -0x20(%ebp),%si
    if (!last)
  8072be:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8072c1:	0f 8f 32 ff ff ff    	jg     8071f9 <ip_frag+0xf6>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8072c7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8072cb:	50                   	push   %eax
  8072cc:	ff 75 cc             	pushl  -0x34(%ebp)
  8072cf:	ff 75 d0             	pushl  -0x30(%ebp)
  8072d2:	ff 75 08             	pushl  0x8(%ebp)
  8072d5:	e8 85 dc ff ff       	call   804f5f <pbuf_copy_partial>
  8072da:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      tmp = tmp | IP_MF;
  8072de:	66 81 ce 00 20       	or     $0x2000,%si
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8072e3:	0f b7 f6             	movzwl %si,%esi
  8072e6:	89 34 24             	mov    %esi,(%esp)
  8072e9:	e8 d7 03 00 00       	call   8076c5 <htons>
  8072ee:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8072f2:	83 c4 04             	add    $0x4,%esp
  8072f5:	ff 75 c8             	pushl  -0x38(%ebp)
  8072f8:	e8 c8 03 00 00       	call   8076c5 <htons>
  8072fd:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  807301:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  807307:	83 c4 08             	add    $0x8,%esp
  80730a:	6a 14                	push   $0x14
  80730c:	53                   	push   %ebx
  80730d:	e8 85 02 00 00       	call   807597 <inet_chksum>
  807312:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  807316:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  807319:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80731d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  807321:	e9 31 ff ff ff       	jmp    807257 <ip_frag+0x154>

00807326 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  807326:	55                   	push   %ebp
  807327:	89 e5                	mov    %esp,%ebp
  807329:	57                   	push   %edi
  80732a:	56                   	push   %esi
  80732b:	53                   	push   %ebx
  80732c:	83 ec 1c             	sub    $0x1c,%esp
  80732f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  807332:	89 d7                	mov    %edx,%edi
  807334:	66 d1 ef             	shr    %di
  807337:	0f b7 d7             	movzwl %di,%edx
  80733a:	8d 34 50             	lea    (%eax,%edx,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  80733d:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807342:	39 f0                	cmp    %esi,%eax
  807344:	74 18                	je     80735e <lwip_standard_chksum+0x38>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  807346:	0f b6 10             	movzbl (%eax),%edx
  807349:	89 d1                	mov    %edx,%ecx
  80734b:	c1 e1 08             	shl    $0x8,%ecx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  80734e:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  807352:	09 ca                	or     %ecx,%edx
  807354:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  807357:	0f b7 d2             	movzwl %dx,%edx
  80735a:	01 d3                	add    %edx,%ebx
  80735c:	eb e4                	jmp    807342 <lwip_standard_chksum+0x1c>
    len -= 2;
  }
  if (len > 0) {
  80735e:	01 ff                	add    %edi,%edi
  807360:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  807364:	74 0b                	je     807371 <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  807366:	0f b6 00             	movzbl (%eax),%eax
  807369:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  80736c:	0f b7 c0             	movzwl %ax,%eax
  80736f:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807371:	89 d8                	mov    %ebx,%eax
  807373:	c1 e8 10             	shr    $0x10,%eax
  807376:	0f b7 db             	movzwl %bx,%ebx
  807379:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  80737b:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  807381:	74 0a                	je     80738d <lwip_standard_chksum+0x67>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807383:	89 d8                	mov    %ebx,%eax
  807385:	c1 e8 10             	shr    $0x10,%eax
  807388:	0f b7 db             	movzwl %bx,%ebx
  80738b:	01 c3                	add    %eax,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80738d:	83 ec 0c             	sub    $0xc,%esp
  807390:	0f b7 db             	movzwl %bx,%ebx
  807393:	53                   	push   %ebx
  807394:	e8 2c 03 00 00       	call   8076c5 <htons>
}
  807399:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80739c:	5b                   	pop    %ebx
  80739d:	5e                   	pop    %esi
  80739e:	5f                   	pop    %edi
  80739f:	5d                   	pop    %ebp
  8073a0:	c3                   	ret    

008073a1 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8073a1:	55                   	push   %ebp
  8073a2:	89 e5                	mov    %esp,%ebp
  8073a4:	57                   	push   %edi
  8073a5:	56                   	push   %esi
  8073a6:	53                   	push   %ebx
  8073a7:	83 ec 1c             	sub    $0x1c,%esp
  8073aa:	8b 75 08             	mov    0x8(%ebp),%esi
  8073ad:	8b 45 14             	mov    0x14(%ebp),%eax
  8073b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8073b3:	8b 45 18             	mov    0x18(%ebp),%eax
  8073b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8073b9:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  8073be:	bb 00 00 00 00       	mov    $0x0,%ebx
  8073c3:	89 f8                	mov    %edi,%eax
  8073c5:	89 df                	mov    %ebx,%edi
  8073c7:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8073c9:	eb 02                	jmp    8073cd <inet_chksum_pseudo+0x2c>
  8073cb:	8b 36                	mov    (%esi),%esi
  8073cd:	85 f6                	test   %esi,%esi
  8073cf:	74 3d                	je     80740e <inet_chksum_pseudo+0x6d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8073d1:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8073d5:	8b 46 04             	mov    0x4(%esi),%eax
  8073d8:	e8 49 ff ff ff       	call   807326 <lwip_standard_chksum>
  8073dd:	0f b7 c0             	movzwl %ax,%eax
  8073e0:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8073e2:	89 c7                	mov    %eax,%edi
  8073e4:	c1 ef 10             	shr    $0x10,%edi
  8073e7:	0f b7 c0             	movzwl %ax,%eax
  8073ea:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  8073ec:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8073f0:	74 d9                	je     8073cb <inet_chksum_pseudo+0x2a>
      swapped = 1 - swapped;
  8073f2:	b8 01 00 00 00       	mov    $0x1,%eax
  8073f7:	29 d8                	sub    %ebx,%eax
  8073f9:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  8073fb:	89 fa                	mov    %edi,%edx
  8073fd:	c1 e2 08             	shl    $0x8,%edx
  807400:	0f b7 d2             	movzwl %dx,%edx
  807403:	89 f8                	mov    %edi,%eax
  807405:	0f b6 c4             	movzbl %ah,%eax
  807408:	09 c2                	or     %eax,%edx
  80740a:	89 d7                	mov    %edx,%edi
  80740c:	eb bd                	jmp    8073cb <inet_chksum_pseudo+0x2a>
  80740e:	89 d8                	mov    %ebx,%eax
  807410:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807412:	84 c0                	test   %al,%al
  807414:	74 0d                	je     807423 <inet_chksum_pseudo+0x82>
    acc = SWAP_BYTES_IN_WORD(acc);
  807416:	89 f8                	mov    %edi,%eax
  807418:	c1 e0 08             	shl    $0x8,%eax
  80741b:	0f b7 c0             	movzwl %ax,%eax
  80741e:	0f b6 df             	movzbl %bh,%ebx
  807421:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  807423:	8b 45 0c             	mov    0xc(%ebp),%eax
  807426:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807428:	8b 55 10             	mov    0x10(%ebp),%edx
  80742b:	8b 12                	mov    (%edx),%edx
  80742d:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807430:	c1 ea 10             	shr    $0x10,%edx
  807433:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  807435:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807438:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80743a:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80743d:	01 d0                	add    %edx,%eax
  80743f:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  807441:	83 ec 0c             	sub    $0xc,%esp
  807444:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807448:	50                   	push   %eax
  807449:	e8 77 02 00 00       	call   8076c5 <htons>
  80744e:	0f b7 c0             	movzwl %ax,%eax
  807451:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  807453:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807457:	89 04 24             	mov    %eax,(%esp)
  80745a:	e8 66 02 00 00       	call   8076c5 <htons>
  80745f:	0f b7 c0             	movzwl %ax,%eax
  807462:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807464:	89 d8                	mov    %ebx,%eax
  807466:	c1 e8 10             	shr    $0x10,%eax
  807469:	0f b7 db             	movzwl %bx,%ebx
  80746c:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  80746e:	89 d8                	mov    %ebx,%eax
  807470:	c1 e8 10             	shr    $0x10,%eax
  807473:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807475:	f7 d0                	not    %eax
}
  807477:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80747a:	5b                   	pop    %ebx
  80747b:	5e                   	pop    %esi
  80747c:	5f                   	pop    %edi
  80747d:	5d                   	pop    %ebp
  80747e:	c3                   	ret    

0080747f <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80747f:	55                   	push   %ebp
  807480:	89 e5                	mov    %esp,%ebp
  807482:	57                   	push   %edi
  807483:	56                   	push   %esi
  807484:	53                   	push   %ebx
  807485:	83 ec 1c             	sub    $0x1c,%esp
  807488:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80748b:	8b 45 14             	mov    0x14(%ebp),%eax
  80748e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807491:	8b 45 18             	mov    0x18(%ebp),%eax
  807494:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807497:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  80749b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  80749f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8074a6:	eb 19                	jmp    8074c1 <inet_chksum_pseudo_partial+0x42>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8074a8:	83 ec 04             	sub    $0x4,%esp
  8074ab:	68 35 20 81 00       	push   $0x812035
  8074b0:	68 60 01 00 00       	push   $0x160
  8074b5:	68 40 20 81 00       	push   $0x812040
  8074ba:	e8 b1 70 00 00       	call   80e570 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8074bf:	8b 1b                	mov    (%ebx),%ebx
  8074c1:	85 db                	test   %ebx,%ebx
  8074c3:	74 5c                	je     807521 <inet_chksum_pseudo_partial+0xa2>
  8074c5:	66 85 f6             	test   %si,%si
  8074c8:	74 57                	je     807521 <inet_chksum_pseudo_partial+0xa2>
    chklen = q->len;
  8074ca:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8074ce:	66 39 fe             	cmp    %di,%si
  8074d1:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  8074d4:	0f b7 d7             	movzwl %di,%edx
  8074d7:	8b 43 04             	mov    0x4(%ebx),%eax
  8074da:	e8 47 fe ff ff       	call   807326 <lwip_standard_chksum>
  8074df:	0f b7 c0             	movzwl %ax,%eax
  8074e2:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8074e5:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8074e7:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  8074ec:	77 ba                	ja     8074a8 <inet_chksum_pseudo_partial+0x29>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8074ee:	89 c2                	mov    %eax,%edx
  8074f0:	c1 ea 10             	shr    $0x10,%edx
  8074f3:	0f b7 c0             	movzwl %ax,%eax
  8074f6:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  8074f9:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  8074fc:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807500:	74 bd                	je     8074bf <inet_chksum_pseudo_partial+0x40>
      swapped = 1 - swapped;
  807502:	b8 01 00 00 00       	mov    $0x1,%eax
  807507:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80750a:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80750d:	89 fa                	mov    %edi,%edx
  80750f:	c1 e2 08             	shl    $0x8,%edx
  807512:	0f b7 d2             	movzwl %dx,%edx
  807515:	89 f8                	mov    %edi,%eax
  807517:	0f b6 c4             	movzbl %ah,%eax
  80751a:	09 c2                	or     %eax,%edx
  80751c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80751f:	eb 9e                	jmp    8074bf <inet_chksum_pseudo_partial+0x40>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807521:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  807525:	74 13                	je     80753a <inet_chksum_pseudo_partial+0xbb>
    acc = SWAP_BYTES_IN_WORD(acc);
  807527:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80752a:	89 c8                	mov    %ecx,%eax
  80752c:	c1 e0 08             	shl    $0x8,%eax
  80752f:	0f b7 c0             	movzwl %ax,%eax
  807532:	0f b6 d5             	movzbl %ch,%edx
  807535:	09 d0                	or     %edx,%eax
  807537:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  80753a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80753d:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80753f:	8b 45 10             	mov    0x10(%ebp),%eax
  807542:	8b 00                	mov    (%eax),%eax
  807544:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807547:	c1 e8 10             	shr    $0x10,%eax
  80754a:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  80754c:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80754f:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  807551:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807554:	01 c3                	add    %eax,%ebx
  807556:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  807559:	83 ec 0c             	sub    $0xc,%esp
  80755c:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807560:	50                   	push   %eax
  807561:	e8 5f 01 00 00       	call   8076c5 <htons>
  807566:	0f b7 f0             	movzwl %ax,%esi
  807569:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  80756b:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  80756f:	89 04 24             	mov    %eax,(%esp)
  807572:	e8 4e 01 00 00       	call   8076c5 <htons>
  807577:	0f b7 d8             	movzwl %ax,%ebx
  80757a:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80757c:	89 d8                	mov    %ebx,%eax
  80757e:	c1 e8 10             	shr    $0x10,%eax
  807581:	0f b7 db             	movzwl %bx,%ebx
  807584:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  807586:	89 d8                	mov    %ebx,%eax
  807588:	c1 e8 10             	shr    $0x10,%eax
  80758b:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80758d:	f7 d0                	not    %eax
}
  80758f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807592:	5b                   	pop    %ebx
  807593:	5e                   	pop    %esi
  807594:	5f                   	pop    %edi
  807595:	5d                   	pop    %ebp
  807596:	c3                   	ret    

00807597 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807597:	55                   	push   %ebp
  807598:	89 e5                	mov    %esp,%ebp
  80759a:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80759d:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  8075a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8075a4:	e8 7d fd ff ff       	call   807326 <lwip_standard_chksum>
  8075a9:	f7 d0                	not    %eax
}
  8075ab:	c9                   	leave  
  8075ac:	c3                   	ret    

008075ad <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8075ad:	55                   	push   %ebp
  8075ae:	89 e5                	mov    %esp,%ebp
  8075b0:	57                   	push   %edi
  8075b1:	56                   	push   %esi
  8075b2:	53                   	push   %ebx
  8075b3:	83 ec 0c             	sub    $0xc,%esp
  8075b6:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8075b9:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  8075be:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  8075c3:	eb 02                	jmp    8075c7 <inet_chksum_pbuf+0x1a>
  8075c5:	8b 36                	mov    (%esi),%esi
  8075c7:	85 f6                	test   %esi,%esi
  8075c9:	74 3b                	je     807606 <inet_chksum_pbuf+0x59>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8075cb:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8075cf:	8b 46 04             	mov    0x4(%esi),%eax
  8075d2:	e8 4f fd ff ff       	call   807326 <lwip_standard_chksum>
  8075d7:	0f b7 c0             	movzwl %ax,%eax
  8075da:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  8075dc:	89 d8                	mov    %ebx,%eax
  8075de:	c1 e8 10             	shr    $0x10,%eax
  8075e1:	0f b7 db             	movzwl %bx,%ebx
  8075e4:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8075e6:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8075ea:	74 d9                	je     8075c5 <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
  8075ec:	b8 01 00 00 00       	mov    $0x1,%eax
  8075f1:	89 f9                	mov    %edi,%ecx
  8075f3:	29 c8                	sub    %ecx,%eax
  8075f5:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  8075f7:	89 da                	mov    %ebx,%edx
  8075f9:	c1 e2 08             	shl    $0x8,%edx
  8075fc:	0f b7 d2             	movzwl %dx,%edx
  8075ff:	0f b6 df             	movzbl %bh,%ebx
  807602:	09 d3                	or     %edx,%ebx
  807604:	eb bf                	jmp    8075c5 <inet_chksum_pbuf+0x18>
    }
  }

  if (swapped) {
  807606:	89 f8                	mov    %edi,%eax
  807608:	84 c0                	test   %al,%al
  80760a:	74 0d                	je     807619 <inet_chksum_pbuf+0x6c>
    acc = SWAP_BYTES_IN_WORD(acc);
  80760c:	89 da                	mov    %ebx,%edx
  80760e:	c1 e2 08             	shl    $0x8,%edx
  807611:	0f b7 d2             	movzwl %dx,%edx
  807614:	0f b6 df             	movzbl %bh,%ebx
  807617:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  807619:	89 d8                	mov    %ebx,%eax
  80761b:	f7 d0                	not    %eax
}
  80761d:	83 c4 0c             	add    $0xc,%esp
  807620:	5b                   	pop    %ebx
  807621:	5e                   	pop    %esi
  807622:	5f                   	pop    %edi
  807623:	5d                   	pop    %ebp
  807624:	c3                   	ret    

00807625 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  807625:	55                   	push   %ebp
  807626:	89 e5                	mov    %esp,%ebp
  807628:	57                   	push   %edi
  807629:	56                   	push   %esi
  80762a:	53                   	push   %ebx
  80762b:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80762e:	8b 45 08             	mov    0x8(%ebp),%eax
  807631:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807634:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  ap = (u8_t *)&s_addr;
  807638:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  80763b:	bf e4 49 b3 00       	mov    $0xb349e4,%edi
  807640:	eb 1a                	jmp    80765c <inet_ntoa+0x37>
  807642:	0f b6 db             	movzbl %bl,%ebx
  807645:	01 fb                	add    %edi,%ebx
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807647:	8d 7b 01             	lea    0x1(%ebx),%edi
  80764a:	c6 03 2e             	movb   $0x2e,(%ebx)
  80764d:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  807650:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  807654:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  807658:	3c 04                	cmp    $0x4,%al
  80765a:	74 59                	je     8076b5 <inet_ntoa+0x90>
  rp = str;
  80765c:	ba 00 00 00 00       	mov    $0x0,%edx
      rem = *ap % (u8_t)10;
  807661:	0f b6 0e             	movzbl (%esi),%ecx
      *ap /= (u8_t)10;
  807664:	0f b6 d9             	movzbl %cl,%ebx
  807667:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  80766a:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  80766d:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807670:	66 c1 e8 0b          	shr    $0xb,%ax
  807674:	88 06                	mov    %al,(%esi)
      inv[i++] = '0' + rem;
  807676:	8d 5a 01             	lea    0x1(%edx),%ebx
  807679:	0f b6 d2             	movzbl %dl,%edx
  80767c:	89 55 e0             	mov    %edx,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  80767f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807682:	01 c0                	add    %eax,%eax
  807684:	89 ca                	mov    %ecx,%edx
  807686:	29 c2                	sub    %eax,%edx
  807688:	89 d0                	mov    %edx,%eax
      inv[i++] = '0' + rem;
  80768a:	83 c0 30             	add    $0x30,%eax
  80768d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807690:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  807694:	89 da                	mov    %ebx,%edx
    } while(*ap);
  807696:	80 f9 09             	cmp    $0x9,%cl
  807699:	77 c6                	ja     807661 <inet_ntoa+0x3c>
  80769b:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  80769d:	89 d8                	mov    %ebx,%eax
    while(i--)
  80769f:	83 e8 01             	sub    $0x1,%eax
  8076a2:	3c ff                	cmp    $0xff,%al
  8076a4:	74 9c                	je     807642 <inet_ntoa+0x1d>
      *rp++ = inv[i];
  8076a6:	0f b6 c8             	movzbl %al,%ecx
  8076a9:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  8076ae:	88 0a                	mov    %cl,(%edx)
  8076b0:	83 c2 01             	add    $0x1,%edx
  8076b3:	eb ea                	jmp    80769f <inet_ntoa+0x7a>
    ap++;
  }
  *--rp = 0;
  8076b5:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  8076b8:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  8076bd:	83 c4 18             	add    $0x18,%esp
  8076c0:	5b                   	pop    %ebx
  8076c1:	5e                   	pop    %esi
  8076c2:	5f                   	pop    %edi
  8076c3:	5d                   	pop    %ebp
  8076c4:	c3                   	ret    

008076c5 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  8076c5:	55                   	push   %ebp
  8076c6:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8076c8:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8076cc:	66 c1 c0 08          	rol    $0x8,%ax
}
  8076d0:	5d                   	pop    %ebp
  8076d1:	c3                   	ret    

008076d2 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  8076d2:	55                   	push   %ebp
  8076d3:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8076d5:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8076d9:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  8076dd:	5d                   	pop    %ebp
  8076de:	c3                   	ret    

008076df <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8076df:	55                   	push   %ebp
  8076e0:	89 e5                	mov    %esp,%ebp
  8076e2:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8076e5:	89 d0                	mov    %edx,%eax
  8076e7:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  8076ea:	89 d1                	mov    %edx,%ecx
  8076ec:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  8076ef:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  8076f1:	89 d1                	mov    %edx,%ecx
  8076f3:	c1 e1 08             	shl    $0x8,%ecx
  8076f6:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  8076fc:	09 c8                	or     %ecx,%eax
  8076fe:	c1 ea 08             	shr    $0x8,%edx
  807701:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  807707:	09 d0                	or     %edx,%eax
}
  807709:	5d                   	pop    %ebp
  80770a:	c3                   	ret    

0080770b <inet_aton>:
{
  80770b:	55                   	push   %ebp
  80770c:	89 e5                	mov    %esp,%ebp
  80770e:	57                   	push   %edi
  80770f:	56                   	push   %esi
  807710:	53                   	push   %ebx
  807711:	83 ec 2c             	sub    $0x2c,%esp
  807714:	8b 45 08             	mov    0x8(%ebp),%eax
  c = *cp;
  807717:	0f be 10             	movsbl (%eax),%edx
  u32_t *pp = parts;
  80771a:	8d 75 d8             	lea    -0x28(%ebp),%esi
  80771d:	89 75 cc             	mov    %esi,-0x34(%ebp)
  807720:	e9 a7 00 00 00       	jmp    8077cc <inet_aton+0xc1>
      c = *++cp;
  807725:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807729:	89 d1                	mov    %edx,%ecx
  80772b:	83 e1 df             	and    $0xffffffdf,%ecx
  80772e:	80 f9 58             	cmp    $0x58,%cl
  807731:	74 10                	je     807743 <inet_aton+0x38>
      c = *++cp;
  807733:	83 c0 01             	add    $0x1,%eax
  807736:	0f be d2             	movsbl %dl,%edx
        base = 8;
  807739:	be 08 00 00 00       	mov    $0x8,%esi
  80773e:	e9 a3 00 00 00       	jmp    8077e6 <inet_aton+0xdb>
        c = *++cp;
  807743:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807747:	8d 40 02             	lea    0x2(%eax),%eax
        base = 16;
  80774a:	be 10 00 00 00       	mov    $0x10,%esi
  80774f:	e9 92 00 00 00       	jmp    8077e6 <inet_aton+0xdb>
      } else if (base == 16 && isxdigit(c)) {
  807754:	83 fe 10             	cmp    $0x10,%esi
  807757:	75 4d                	jne    8077a6 <inet_aton+0x9b>
  807759:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  80775c:	88 4d d3             	mov    %cl,-0x2d(%ebp)
  80775f:	89 d1                	mov    %edx,%ecx
  807761:	83 e1 df             	and    $0xffffffdf,%ecx
  807764:	83 e9 41             	sub    $0x41,%ecx
  807767:	80 f9 05             	cmp    $0x5,%cl
  80776a:	77 3a                	ja     8077a6 <inet_aton+0x9b>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80776c:	c1 e3 04             	shl    $0x4,%ebx
  80776f:	83 c2 0a             	add    $0xa,%edx
  807772:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  807776:	19 c9                	sbb    %ecx,%ecx
  807778:	83 e1 20             	and    $0x20,%ecx
  80777b:	83 c1 41             	add    $0x41,%ecx
  80777e:	29 ca                	sub    %ecx,%edx
  807780:	09 d3                	or     %edx,%ebx
        c = *++cp;
  807782:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  807785:	0f be 57 01          	movsbl 0x1(%edi),%edx
  807789:	83 c0 01             	add    $0x1,%eax
  80778c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (isdigit(c)) {
  80778f:	89 d7                	mov    %edx,%edi
  807791:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807794:	80 f9 09             	cmp    $0x9,%cl
  807797:	77 bb                	ja     807754 <inet_aton+0x49>
        val = (val * base) + (int)(c - '0');
  807799:	0f af de             	imul   %esi,%ebx
  80779c:	8d 5c 1a d0          	lea    -0x30(%edx,%ebx,1),%ebx
        c = *++cp;
  8077a0:	0f be 50 01          	movsbl 0x1(%eax),%edx
  8077a4:	eb e3                	jmp    807789 <inet_aton+0x7e>
    if (c == '.') {
  8077a6:	83 fa 2e             	cmp    $0x2e,%edx
  8077a9:	75 42                	jne    8077ed <inet_aton+0xe2>
      if (pp >= parts + 3)
  8077ab:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8077ae:	8b 75 cc             	mov    -0x34(%ebp),%esi
  8077b1:	39 c6                	cmp    %eax,%esi
  8077b3:	0f 84 0e 01 00 00    	je     8078c7 <inet_aton+0x1bc>
      *pp++ = val;
  8077b9:	83 c6 04             	add    $0x4,%esi
  8077bc:	89 75 cc             	mov    %esi,-0x34(%ebp)
  8077bf:	89 5e fc             	mov    %ebx,-0x4(%esi)
      c = *++cp;
  8077c2:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  8077c5:	8d 46 01             	lea    0x1(%esi),%eax
  8077c8:	0f be 56 01          	movsbl 0x1(%esi),%edx
    if (!isdigit(c))
  8077cc:	8d 4a d0             	lea    -0x30(%edx),%ecx
  8077cf:	80 f9 09             	cmp    $0x9,%cl
  8077d2:	0f 87 e8 00 00 00    	ja     8078c0 <inet_aton+0x1b5>
    base = 10;
  8077d8:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  8077dd:	83 fa 30             	cmp    $0x30,%edx
  8077e0:	0f 84 3f ff ff ff    	je     807725 <inet_aton+0x1a>
    base = 10;
  8077e6:	bb 00 00 00 00       	mov    $0x0,%ebx
  8077eb:	eb 9f                	jmp    80778c <inet_aton+0x81>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8077ed:	85 d2                	test   %edx,%edx
  8077ef:	74 26                	je     807817 <inet_aton+0x10c>
    return (0);
  8077f1:	b8 00 00 00 00       	mov    $0x0,%eax
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8077f6:	89 f9                	mov    %edi,%ecx
  8077f8:	80 f9 1f             	cmp    $0x1f,%cl
  8077fb:	0f 86 cb 00 00 00    	jbe    8078cc <inet_aton+0x1c1>
  807801:	84 d2                	test   %dl,%dl
  807803:	0f 88 c3 00 00 00    	js     8078cc <inet_aton+0x1c1>
  807809:	83 fa 20             	cmp    $0x20,%edx
  80780c:	74 09                	je     807817 <inet_aton+0x10c>
  80780e:	83 fa 0c             	cmp    $0xc,%edx
  807811:	0f 85 b5 00 00 00    	jne    8078cc <inet_aton+0x1c1>
  n = pp - parts + 1;
  807817:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80781a:	8b 75 cc             	mov    -0x34(%ebp),%esi
  80781d:	29 c6                	sub    %eax,%esi
  80781f:	89 f0                	mov    %esi,%eax
  807821:	c1 f8 02             	sar    $0x2,%eax
  807824:	83 c0 01             	add    $0x1,%eax
  switch (n) {
  807827:	83 f8 02             	cmp    $0x2,%eax
  80782a:	74 5e                	je     80788a <inet_aton+0x17f>
  80782c:	7e 35                	jle    807863 <inet_aton+0x158>
  80782e:	83 f8 03             	cmp    $0x3,%eax
  807831:	74 6e                	je     8078a1 <inet_aton+0x196>
  807833:	83 f8 04             	cmp    $0x4,%eax
  807836:	75 2f                	jne    807867 <inet_aton+0x15c>
      return (0);
  807838:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xff)
  80783d:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  807843:	0f 87 83 00 00 00    	ja     8078cc <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807849:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80784c:	c1 e0 18             	shl    $0x18,%eax
  80784f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807852:	c1 e2 10             	shl    $0x10,%edx
  807855:	09 d0                	or     %edx,%eax
  807857:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80785a:	c1 e2 08             	shl    $0x8,%edx
  80785d:	09 d0                	or     %edx,%eax
  80785f:	09 c3                	or     %eax,%ebx
    break;
  807861:	eb 04                	jmp    807867 <inet_aton+0x15c>
  switch (n) {
  807863:	85 c0                	test   %eax,%eax
  807865:	74 65                	je     8078cc <inet_aton+0x1c1>
  return (1);
  807867:	b8 01 00 00 00       	mov    $0x1,%eax
  if (addr)
  80786c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807870:	74 5a                	je     8078cc <inet_aton+0x1c1>
    addr->s_addr = htonl(val);
  807872:	83 ec 0c             	sub    $0xc,%esp
  807875:	53                   	push   %ebx
  807876:	e8 64 fe ff ff       	call   8076df <htonl>
  80787b:	83 c4 10             	add    $0x10,%esp
  80787e:	8b 75 0c             	mov    0xc(%ebp),%esi
  807881:	89 06                	mov    %eax,(%esi)
  return (1);
  807883:	b8 01 00 00 00       	mov    $0x1,%eax
  807888:	eb 42                	jmp    8078cc <inet_aton+0x1c1>
      return (0);
  80788a:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffffffUL)
  80788f:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  807895:	77 35                	ja     8078cc <inet_aton+0x1c1>
    val |= parts[0] << 24;
  807897:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80789a:	c1 e0 18             	shl    $0x18,%eax
  80789d:	09 c3                	or     %eax,%ebx
    break;
  80789f:	eb c6                	jmp    807867 <inet_aton+0x15c>
      return (0);
  8078a1:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffff)
  8078a6:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8078ac:	77 1e                	ja     8078cc <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16);
  8078ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8078b1:	c1 e0 18             	shl    $0x18,%eax
  8078b4:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8078b7:	c1 e2 10             	shl    $0x10,%edx
  8078ba:	09 d0                	or     %edx,%eax
  8078bc:	09 c3                	or     %eax,%ebx
    break;
  8078be:	eb a7                	jmp    807867 <inet_aton+0x15c>
      return (0);
  8078c0:	b8 00 00 00 00       	mov    $0x0,%eax
  8078c5:	eb 05                	jmp    8078cc <inet_aton+0x1c1>
        return (0);
  8078c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8078cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8078cf:	5b                   	pop    %ebx
  8078d0:	5e                   	pop    %esi
  8078d1:	5f                   	pop    %edi
  8078d2:	5d                   	pop    %ebp
  8078d3:	c3                   	ret    

008078d4 <inet_addr>:
{
  8078d4:	55                   	push   %ebp
  8078d5:	89 e5                	mov    %esp,%ebp
  8078d7:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  8078da:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8078dd:	50                   	push   %eax
  8078de:	ff 75 08             	pushl  0x8(%ebp)
  8078e1:	e8 25 fe ff ff       	call   80770b <inet_aton>
  8078e6:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  8078e9:	85 c0                	test   %eax,%eax
  8078eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8078f0:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  8078f4:	c9                   	leave  
  8078f5:	c3                   	ret    

008078f6 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  8078f6:	55                   	push   %ebp
  8078f7:	89 e5                	mov    %esp,%ebp
  8078f9:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  8078fc:	ff 75 08             	pushl  0x8(%ebp)
  8078ff:	e8 db fd ff ff       	call   8076df <htonl>
  807904:	83 c4 10             	add    $0x10,%esp
}
  807907:	c9                   	leave  
  807908:	c3                   	ret    

00807909 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807909:	55                   	push   %ebp
  80790a:	89 e5                	mov    %esp,%ebp
  80790c:	57                   	push   %edi
  80790d:	56                   	push   %esi
  80790e:	53                   	push   %ebx
  80790f:	83 ec 3c             	sub    $0x3c,%esp
  807912:	8b 7d 08             	mov    0x8(%ebp),%edi
  807915:	8b 75 10             	mov    0x10(%ebp),%esi
  807918:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  80791b:	8b 55 14             	mov    0x14(%ebp),%edx
  80791e:	89 55 bc             	mov    %edx,-0x44(%ebp)
  807921:	8b 5d 18             	mov    0x18(%ebp),%ebx
  807924:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  807927:	8b 45 20             	mov    0x20(%ebp),%eax
  80792a:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  80792e:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807931:	89 da                	mov    %ebx,%edx
  807933:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807936:	66 85 f6             	test   %si,%si
  807939:	74 04                	je     80793f <tcp_enqueue+0x36>
  80793b:	84 c0                	test   %al,%al
  80793d:	75 54                	jne    807993 <tcp_enqueue+0x8a>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80793f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807943:	74 06                	je     80794b <tcp_enqueue+0x42>
  807945:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807949:	75 5f                	jne    8079aa <tcp_enqueue+0xa1>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80794b:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  80794f:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  807953:	72 6c                	jb     8079c1 <tcp_enqueue+0xb8>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807955:	8b 4f 68             	mov    0x68(%edi),%ecx
  807958:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80795b:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  80795f:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807963:	66 83 f9 1f          	cmp    $0x1f,%cx
  807967:	77 66                	ja     8079cf <tcp_enqueue+0xc6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807969:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  80796e:	74 6d                	je     8079dd <tcp_enqueue+0xd4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807970:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807974:	75 7b                	jne    8079f1 <tcp_enqueue+0xe8>
  807976:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80797a:	75 75                	jne    8079f1 <tcp_enqueue+0xe8>
  80797c:	83 ec 04             	sub    $0x4,%esp
  80797f:	68 ec 20 81 00       	push   $0x8120ec
  807984:	68 ae 00 00 00       	push   $0xae
  807989:	68 06 22 81 00       	push   $0x812206
  80798e:	e8 dd 6b 00 00       	call   80e570 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807993:	83 ec 04             	sub    $0x4,%esp
  807996:	68 64 20 81 00       	push   $0x812064
  80799b:	68 90 00 00 00       	push   $0x90
  8079a0:	68 06 22 81 00       	push   $0x812206
  8079a5:	e8 c6 6b 00 00       	call   80e570 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  8079aa:	83 ec 04             	sub    $0x4,%esp
  8079ad:	68 a4 20 81 00       	push   $0x8120a4
  8079b2:	68 92 00 00 00       	push   $0x92
  8079b7:	68 06 22 81 00       	push   $0x812206
  8079bc:	e8 af 6b 00 00       	call   80e570 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  8079c1:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079ca:	e9 a4 03 00 00       	jmp    807d73 <tcp_enqueue+0x46a>
    pcb->flags |= TF_NAGLEMEMERR;
  8079cf:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079d8:	e9 96 03 00 00       	jmp    807d73 <tcp_enqueue+0x46a>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8079dd:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8079e1:	0f 85 05 02 00 00    	jne    807bec <tcp_enqueue+0x2e3>
  8079e7:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8079eb:	0f 85 fb 01 00 00    	jne    807bec <tcp_enqueue+0x2e3>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8079f1:	c0 e8 02             	shr    $0x2,%al
  8079f4:	c1 e0 0c             	shl    $0xc,%eax
  8079f7:	66 05 00 50          	add    $0x5000,%ax
  8079fb:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  8079ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  807a02:	89 45 d0             	mov    %eax,-0x30(%ebp)
  807a05:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807a09:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807a0d:	be 00 00 00 00       	mov    $0x0,%esi
  while (queue == NULL || left > 0) {
  807a12:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807a16:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807a1d:	83 e2 01             	and    $0x1,%edx
  807a20:	88 55 c9             	mov    %dl,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807a23:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807a27:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807a2a:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807a2e:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807a32:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807a37:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
    seg = memp_malloc(MEMP_TCP_SEG);
  807a3b:	83 ec 0c             	sub    $0xc,%esp
  807a3e:	6a 04                	push   $0x4
  807a40:	e8 f8 c9 ff ff       	call   80443d <memp_malloc>
  807a45:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807a47:	83 c4 10             	add    $0x10,%esp
  807a4a:	85 c0                	test   %eax,%eax
  807a4c:	0f 84 e6 02 00 00    	je     807d38 <tcp_enqueue+0x42f>
    seg->next = NULL;
  807a52:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807a58:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807a5f:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807a63:	0f 85 b1 01 00 00    	jne    807c1a <tcp_enqueue+0x311>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807a69:	85 f6                	test   %esi,%esi
  807a6b:	0f 84 92 01 00 00    	je     807c03 <tcp_enqueue+0x2fa>
      useg->next = seg;
  807a71:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807a73:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807a77:	0f 84 bc 01 00 00    	je     807c39 <tcp_enqueue+0x330>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807a7d:	83 ec 04             	sub    $0x4,%esp
  807a80:	6a 00                	push   $0x0
  807a82:	ff 75 cc             	pushl  -0x34(%ebp)
  807a85:	6a 00                	push   $0x0
  807a87:	e8 1d ce ff ff       	call   8048a9 <pbuf_alloc>
  807a8c:	89 43 04             	mov    %eax,0x4(%ebx)
  807a8f:	83 c4 10             	add    $0x10,%esp
  807a92:	85 c0                	test   %eax,%eax
  807a94:	0f 84 9e 02 00 00    	je     807d38 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807a9a:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807a9e:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807aa2:	0f 82 7a 01 00 00    	jb     807c22 <tcp_enqueue+0x319>
      queuelen += pbuf_clen(seg->p);
  807aa8:	83 ec 0c             	sub    $0xc,%esp
  807aab:	50                   	push   %eax
  807aac:	e8 7c d1 ff ff       	call   804c2d <pbuf_clen>
  807ab1:	0f b6 c0             	movzbl %al,%eax
  807ab4:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807ab8:	8b 43 04             	mov    0x4(%ebx),%eax
  807abb:	8b 40 04             	mov    0x4(%eax),%eax
  807abe:	89 43 08             	mov    %eax,0x8(%ebx)
  807ac1:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807ac4:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807ac9:	0f 87 69 02 00 00    	ja     807d38 <tcp_enqueue+0x42f>
    seg->len = seglen;
  807acf:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807ad3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807ad7:	83 ec 08             	sub    $0x8,%esp
  807ada:	6a 14                	push   $0x14
  807adc:	ff 73 04             	pushl  0x4(%ebx)
  807adf:	e8 32 cc ff ff       	call   804716 <pbuf_header>
  807ae4:	83 c4 10             	add    $0x10,%esp
  807ae7:	84 c0                	test   %al,%al
  807ae9:	0f 85 49 02 00 00    	jne    807d38 <tcp_enqueue+0x42f>
    seg->tcphdr = seg->p->payload;
  807aef:	8b 43 04             	mov    0x4(%ebx),%eax
  807af2:	8b 70 04             	mov    0x4(%eax),%esi
  807af5:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807af8:	83 ec 0c             	sub    $0xc,%esp
  807afb:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807aff:	50                   	push   %eax
  807b00:	e8 c0 fb ff ff       	call   8076c5 <htons>
  807b05:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807b08:	8b 73 10             	mov    0x10(%ebx),%esi
  807b0b:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807b0f:	89 04 24             	mov    %eax,(%esp)
  807b12:	e8 ae fb ff ff       	call   8076c5 <htons>
  807b17:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807b1b:	8b 73 10             	mov    0x10(%ebx),%esi
  807b1e:	83 c4 04             	add    $0x4,%esp
  807b21:	ff 75 d8             	pushl  -0x28(%ebp)
  807b24:	e8 b6 fb ff ff       	call   8076df <htonl>
  807b29:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807b2c:	8b 43 10             	mov    0x10(%ebx),%eax
  807b2f:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807b35:	8b 43 10             	mov    0x10(%ebx),%eax
  807b38:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807b3c:	89 04 24             	mov    %eax,(%esp)
  807b3f:	e8 8e fb ff ff       	call   8076d2 <ntohs>
  807b44:	8b 73 10             	mov    0x10(%ebx),%esi
  807b47:	83 e0 c0             	and    $0xffffffc0,%eax
  807b4a:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807b4e:	09 d0                	or     %edx,%eax
  807b50:	0f b7 c0             	movzwl %ax,%eax
  807b53:	89 04 24             	mov    %eax,(%esp)
  807b56:	e8 6a fb ff ff       	call   8076c5 <htons>
  807b5b:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807b5f:	83 c4 10             	add    $0x10,%esp
  807b62:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807b66:	0f 84 0f 02 00 00    	je     807d7b <tcp_enqueue+0x472>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807b6c:	83 ec 0c             	sub    $0xc,%esp
  807b6f:	8b 43 10             	mov    0x10(%ebx),%eax
  807b72:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807b76:	50                   	push   %eax
  807b77:	e8 56 fb ff ff       	call   8076d2 <ntohs>
  807b7c:	8b 73 10             	mov    0x10(%ebx),%esi
  807b7f:	83 e0 3f             	and    $0x3f,%eax
  807b82:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807b86:	0f b7 c0             	movzwl %ax,%eax
  807b89:	89 04 24             	mov    %eax,(%esp)
  807b8c:	e8 34 fb ff ff       	call   8076c5 <htons>
  807b91:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807b95:	83 c4 0c             	add    $0xc,%esp
  807b98:	ff 75 cc             	pushl  -0x34(%ebp)
  807b9b:	ff 75 1c             	pushl  0x1c(%ebp)
  807b9e:	ff 73 08             	pushl  0x8(%ebx)
  807ba1:	e8 71 72 00 00       	call   80ee17 <memcpy>
  807ba6:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807ba9:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807bad:	0f b7 c1             	movzwl %cx,%eax
  807bb0:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807bb3:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807bb6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807bba:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807bbe:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    seg = memp_malloc(MEMP_TCP_SEG);
  807bc2:	89 de                	mov    %ebx,%esi
  while (queue == NULL || left > 0) {
  807bc4:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807bc8:	0f 85 5c fe ff ff    	jne    807a2a <tcp_enqueue+0x121>
  807bce:	84 c0                	test   %al,%al
  807bd0:	0f 85 54 fe ff ff    	jne    807a2a <tcp_enqueue+0x121>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807bd6:	8b 47 74             	mov    0x74(%edi),%eax
  807bd9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807bdc:	85 c0                	test   %eax,%eax
  807bde:	0f 84 c1 03 00 00    	je     807fa5 <tcp_enqueue+0x69c>
  807be4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807be7:	e9 be 01 00 00       	jmp    807daa <tcp_enqueue+0x4a1>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807bec:	83 ec 04             	sub    $0x4,%esp
  807bef:	68 28 21 81 00       	push   $0x812128
  807bf4:	68 b1 00 00 00       	push   $0xb1
  807bf9:	68 06 22 81 00       	push   $0x812206
  807bfe:	e8 6d 69 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807c03:	83 ec 04             	sub    $0x4,%esp
  807c06:	68 1e 22 81 00       	push   $0x81221e
  807c0b:	68 ce 00 00 00       	push   $0xce
  807c10:	68 06 22 81 00       	push   $0x812206
  807c15:	e8 56 69 00 00       	call   80e570 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807c1a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807c1d:	e9 51 fe ff ff       	jmp    807a73 <tcp_enqueue+0x16a>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807c22:	83 ec 04             	sub    $0x4,%esp
  807c25:	68 5c 21 81 00       	push   $0x81215c
  807c2a:	68 df 00 00 00       	push   $0xdf
  807c2f:	68 06 22 81 00       	push   $0x812206
  807c34:	e8 37 69 00 00       	call   80e570 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807c39:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807c3d:	74 7f                	je     807cbe <tcp_enqueue+0x3b5>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807c3f:	83 ec 04             	sub    $0x4,%esp
  807c42:	6a 00                	push   $0x0
  807c44:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807c48:	0f b7 c6             	movzwl %si,%eax
  807c4b:	50                   	push   %eax
  807c4c:	6a 00                	push   $0x0
  807c4e:	e8 56 cc ff ff       	call   8048a9 <pbuf_alloc>
  807c53:	89 43 04             	mov    %eax,0x4(%ebx)
  807c56:	83 c4 10             	add    $0x10,%esp
  807c59:	85 c0                	test   %eax,%eax
  807c5b:	0f 84 d7 00 00 00    	je     807d38 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807c61:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807c65:	72 40                	jb     807ca7 <tcp_enqueue+0x39e>
      queuelen += pbuf_clen(seg->p);
  807c67:	83 ec 0c             	sub    $0xc,%esp
  807c6a:	50                   	push   %eax
  807c6b:	e8 bd cf ff ff       	call   804c2d <pbuf_clen>
  807c70:	0f b6 c0             	movzbl %al,%eax
  807c73:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807c77:	83 c4 10             	add    $0x10,%esp
  807c7a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807c7e:	74 19                	je     807c99 <tcp_enqueue+0x390>
        MEMCPY(seg->p->payload, ptr, seglen);
  807c80:	83 ec 04             	sub    $0x4,%esp
  807c83:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807c87:	50                   	push   %eax
  807c88:	ff 75 d0             	pushl  -0x30(%ebp)
  807c8b:	8b 43 04             	mov    0x4(%ebx),%eax
  807c8e:	ff 70 04             	pushl  0x4(%eax)
  807c91:	e8 81 71 00 00       	call   80ee17 <memcpy>
  807c96:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  807c99:	8b 43 04             	mov    0x4(%ebx),%eax
  807c9c:	8b 40 04             	mov    0x4(%eax),%eax
  807c9f:	89 43 08             	mov    %eax,0x8(%ebx)
  807ca2:	e9 1d fe ff ff       	jmp    807ac4 <tcp_enqueue+0x1bb>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807ca7:	83 ec 04             	sub    $0x4,%esp
  807caa:	68 84 21 81 00       	push   $0x812184
  807caf:	68 ea 00 00 00       	push   $0xea
  807cb4:	68 06 22 81 00       	push   $0x812206
  807cb9:	e8 b2 68 00 00       	call   80e570 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807cbe:	83 ec 04             	sub    $0x4,%esp
  807cc1:	6a 01                	push   $0x1
  807cc3:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807cc7:	50                   	push   %eax
  807cc8:	6a 00                	push   $0x0
  807cca:	e8 da cb ff ff       	call   8048a9 <pbuf_alloc>
  807ccf:	89 c6                	mov    %eax,%esi
  807cd1:	83 c4 10             	add    $0x10,%esp
  807cd4:	85 c0                	test   %eax,%eax
  807cd6:	74 60                	je     807d38 <tcp_enqueue+0x42f>
      ++queuelen;
  807cd8:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807cdc:	83 c0 01             	add    $0x1,%eax
  807cdf:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  807ce3:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807ce6:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807ce9:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807cec:	83 ec 04             	sub    $0x4,%esp
  807cef:	6a 00                	push   $0x0
  807cf1:	6a 00                	push   $0x0
  807cf3:	6a 00                	push   $0x0
  807cf5:	e8 af cb ff ff       	call   8048a9 <pbuf_alloc>
  807cfa:	89 43 04             	mov    %eax,0x4(%ebx)
  807cfd:	83 c4 10             	add    $0x10,%esp
  807d00:	85 c0                	test   %eax,%eax
  807d02:	74 28                	je     807d2c <tcp_enqueue+0x423>
      queuelen += pbuf_clen(seg->p);
  807d04:	83 ec 0c             	sub    $0xc,%esp
  807d07:	50                   	push   %eax
  807d08:	e8 20 cf ff ff       	call   804c2d <pbuf_clen>
  807d0d:	0f b6 c0             	movzbl %al,%eax
  807d10:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807d14:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807d18:	83 c4 08             	add    $0x8,%esp
  807d1b:	56                   	push   %esi
  807d1c:	ff 73 04             	pushl  0x4(%ebx)
  807d1f:	e8 32 cf ff ff       	call   804c56 <pbuf_cat>
  807d24:	83 c4 10             	add    $0x10,%esp
  807d27:	e9 98 fd ff ff       	jmp    807ac4 <tcp_enqueue+0x1bb>
        pbuf_free(p);
  807d2c:	83 ec 0c             	sub    $0xc,%esp
  807d2f:	56                   	push   %esi
  807d30:	e8 ae ca ff ff       	call   8047e3 <pbuf_free>
        goto memerr;
  807d35:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807d38:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807d3c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807d3f:	85 c0                	test   %eax,%eax
  807d41:	74 0c                	je     807d4f <tcp_enqueue+0x446>
    tcp_segs_free(queue);
  807d43:	83 ec 0c             	sub    $0xc,%esp
  807d46:	50                   	push   %eax
  807d47:	e8 f5 d9 ff ff       	call   805741 <tcp_segs_free>
  807d4c:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807d4f:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807d54:	0f 84 37 02 00 00    	je     807f91 <tcp_enqueue+0x688>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807d5a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807d5e:	0f 85 37 02 00 00    	jne    807f9b <tcp_enqueue+0x692>
  807d64:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807d68:	0f 84 02 02 00 00    	je     807f70 <tcp_enqueue+0x667>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807d6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807d73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807d76:	5b                   	pop    %ebx
  807d77:	5e                   	pop    %esi
  807d78:	5f                   	pop    %edi
  807d79:	5d                   	pop    %ebp
  807d7a:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807d7b:	83 ec 0c             	sub    $0xc,%esp
  807d7e:	8b 43 10             	mov    0x10(%ebx),%eax
  807d81:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d85:	50                   	push   %eax
  807d86:	e8 47 f9 ff ff       	call   8076d2 <ntohs>
  807d8b:	8b 73 10             	mov    0x10(%ebx),%esi
  807d8e:	83 e0 3f             	and    $0x3f,%eax
  807d91:	80 cc 50             	or     $0x50,%ah
  807d94:	89 04 24             	mov    %eax,(%esp)
  807d97:	e8 29 f9 ff ff       	call   8076c5 <htons>
  807d9c:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807da0:	83 c4 10             	add    $0x10,%esp
  807da3:	e9 01 fe ff ff       	jmp    807ba9 <tcp_enqueue+0x2a0>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807da8:	89 f0                	mov    %esi,%eax
  807daa:	8b 30                	mov    (%eax),%esi
  807dac:	85 f6                	test   %esi,%esi
  807dae:	75 f8                	jne    807da8 <tcp_enqueue+0x49f>
  807db0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    TCP_TCPLEN(useg) != 0 &&
  807db3:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807db7:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807dbb:	83 ec 0c             	sub    $0xc,%esp
  807dbe:	8b 40 10             	mov    0x10(%eax),%eax
  807dc1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807dc5:	50                   	push   %eax
  807dc6:	e8 07 f9 ff ff       	call   8076d2 <ntohs>
  807dcb:	83 c4 10             	add    $0x10,%esp
  807dce:	a8 01                	test   $0x1,%al
  807dd0:	0f 84 96 00 00 00    	je     807e6c <tcp_enqueue+0x563>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807dd6:	83 ec 0c             	sub    $0xc,%esp
  807dd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ddc:	8b 40 10             	mov    0x10(%eax),%eax
  807ddf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807de3:	50                   	push   %eax
  807de4:	e8 e9 f8 ff ff       	call   8076d2 <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807de9:	83 c4 10             	add    $0x10,%esp
  807dec:	a8 03                	test   $0x3,%al
  807dee:	0f 85 a0 00 00 00    	jne    807e94 <tcp_enqueue+0x58b>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807df4:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807df8:	0f 85 96 00 00 00    	jne    807e94 <tcp_enqueue+0x58b>
    useg->len + queue->len <= pcb->mss) {
  807dfe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807e01:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e05:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e08:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807e0c:	01 d0                	add    %edx,%eax
  807e0e:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807e12:	39 d0                	cmp    %edx,%eax
  807e14:	7f 7e                	jg     807e94 <tcp_enqueue+0x58b>
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807e16:	83 ec 08             	sub    $0x8,%esp
  807e19:	6a ec                	push   $0xffffffec
  807e1b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807e1e:	ff 70 04             	pushl  0x4(%eax)
  807e21:	e8 f0 c8 ff ff       	call   804716 <pbuf_header>
  807e26:	83 c4 10             	add    $0x10,%esp
  807e29:	84 c0                	test   %al,%al
  807e2b:	0f 85 0b 01 00 00    	jne    807f3c <tcp_enqueue+0x633>
    pbuf_cat(useg->p, queue->p);
  807e31:	83 ec 08             	sub    $0x8,%esp
  807e34:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e37:	ff 72 04             	pushl  0x4(%edx)
  807e3a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807e3d:	ff 71 04             	pushl  0x4(%ecx)
  807e40:	e8 11 ce ff ff       	call   804c56 <pbuf_cat>
    useg->len += queue->len;
  807e45:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e48:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807e4c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807e4f:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807e53:	8b 02                	mov    (%edx),%eax
  807e55:	89 01                	mov    %eax,(%ecx)
    if (seg == queue) {
  807e57:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807e5a:	39 da                	cmp    %ebx,%edx
  807e5c:	0f 44 de             	cmove  %esi,%ebx
    memp_free(MEMP_TCP_SEG, queue);
  807e5f:	52                   	push   %edx
  807e60:	6a 04                	push   $0x4
  807e62:	e8 2c c6 ff ff       	call   804493 <memp_free>
  807e67:	83 c4 10             	add    $0x10,%esp
  807e6a:	eb 49                	jmp    807eb5 <tcp_enqueue+0x5ac>
    TCP_TCPLEN(useg) != 0 &&
  807e6c:	83 ec 0c             	sub    $0xc,%esp
  807e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807e72:	8b 40 10             	mov    0x10(%eax),%eax
  807e75:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e79:	50                   	push   %eax
  807e7a:	e8 53 f8 ff ff       	call   8076d2 <ntohs>
  807e7f:	66 d1 e8             	shr    %ax
  807e82:	83 e0 01             	and    $0x1,%eax
  807e85:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  807e89:	83 c4 10             	add    $0x10,%esp
  807e8c:	01 d0                	add    %edx,%eax
  807e8e:	0f 85 42 ff ff ff    	jne    807dd6 <tcp_enqueue+0x4cd>
      useg->next = queue;
  807e94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807e97:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e9a:	89 10                	mov    %edx,(%eax)
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807e9c:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807ea0:	83 e2 03             	and    $0x3,%edx
    ++len;
  807ea3:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807ea7:	83 c0 01             	add    $0x1,%eax
  807eaa:	84 d2                	test   %dl,%dl
  807eac:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807eb1:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  807eb5:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807eb9:	74 04                	je     807ebf <tcp_enqueue+0x5b6>
    pcb->flags |= TF_FIN;
  807ebb:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  807ebf:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807ec3:	0f b7 c2             	movzwl %dx,%eax
  807ec6:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  807ec9:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  807ecd:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807ed1:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  807ed5:	66 85 c0             	test   %ax,%ax
  807ed8:	74 06                	je     807ee0 <tcp_enqueue+0x5d7>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807eda:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807ede:	74 73                	je     807f53 <tcp_enqueue+0x64a>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807ee0:	85 db                	test   %ebx,%ebx
  807ee2:	0f 84 9f 00 00 00    	je     807f87 <tcp_enqueue+0x67e>
  807ee8:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807eed:	0f 84 94 00 00 00    	je     807f87 <tcp_enqueue+0x67e>
  807ef3:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  807ef6:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807efb:	85 d2                	test   %edx,%edx
  807efd:	0f 84 70 fe ff ff    	je     807d73 <tcp_enqueue+0x46a>
  807f03:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807f07:	0f 85 66 fe ff ff    	jne    807d73 <tcp_enqueue+0x46a>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807f0d:	83 ec 0c             	sub    $0xc,%esp
  807f10:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807f14:	50                   	push   %eax
  807f15:	e8 b8 f7 ff ff       	call   8076d2 <ntohs>
  807f1a:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807f1d:	83 c8 08             	or     $0x8,%eax
  807f20:	0f b7 c0             	movzwl %ax,%eax
  807f23:	89 04 24             	mov    %eax,(%esp)
  807f26:	e8 9a f7 ff ff       	call   8076c5 <htons>
  807f2b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807f2f:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  807f32:	b8 00 00 00 00       	mov    $0x0,%eax
  807f37:	e9 37 fe ff ff       	jmp    807d73 <tcp_enqueue+0x46a>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807f3c:	83 ec 04             	sub    $0x4,%esp
  807f3f:	68 2b 22 81 00       	push   $0x81222b
  807f44:	68 52 01 00 00       	push   $0x152
  807f49:	68 06 22 81 00       	push   $0x812206
  807f4e:	e8 1d 66 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807f53:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807f57:	75 87                	jne    807ee0 <tcp_enqueue+0x5d7>
  807f59:	83 ec 04             	sub    $0x4,%esp
  807f5c:	68 b8 21 81 00       	push   $0x8121b8
  807f61:	68 7a 01 00 00       	push   $0x17a
  807f66:	68 06 22 81 00       	push   $0x812206
  807f6b:	e8 00 66 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807f70:	83 ec 04             	sub    $0x4,%esp
  807f73:	68 b8 21 81 00       	push   $0x8121b8
  807f78:	68 8d 01 00 00       	push   $0x18d
  807f7d:	68 06 22 81 00       	push   $0x812206
  807f82:	e8 e9 65 00 00       	call   80e570 <_panic>
  return ERR_OK;
  807f87:	b8 00 00 00 00       	mov    $0x0,%eax
  807f8c:	e9 e2 fd ff ff       	jmp    807d73 <tcp_enqueue+0x46a>
  return ERR_MEM;
  807f91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f96:	e9 d8 fd ff ff       	jmp    807d73 <tcp_enqueue+0x46a>
  807f9b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807fa0:	e9 ce fd ff ff       	jmp    807d73 <tcp_enqueue+0x46a>
      pcb->unsent = queue;
  807fa5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807fa8:	89 47 74             	mov    %eax,0x74(%edi)
  807fab:	e9 ec fe ff ff       	jmp    807e9c <tcp_enqueue+0x593>

00807fb0 <tcp_send_ctrl>:
{
  807fb0:	55                   	push   %ebp
  807fb1:	89 e5                	mov    %esp,%ebp
  807fb3:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  807fb6:	6a 00                	push   $0x0
  807fb8:	6a 00                	push   $0x0
  807fba:	6a 01                	push   $0x1
  807fbc:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  807fc0:	50                   	push   %eax
  807fc1:	6a 00                	push   $0x0
  807fc3:	6a 00                	push   $0x0
  807fc5:	ff 75 08             	pushl  0x8(%ebp)
  807fc8:	e8 3c f9 ff ff       	call   807909 <tcp_enqueue>
}
  807fcd:	c9                   	leave  
  807fce:	c3                   	ret    

00807fcf <tcp_write>:
{
  807fcf:	55                   	push   %ebp
  807fd0:	89 e5                	mov    %esp,%ebp
  807fd2:	56                   	push   %esi
  807fd3:	53                   	push   %ebx
  807fd4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807fd7:	8b 55 10             	mov    0x10(%ebp),%edx
  807fda:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  807fdd:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  807fe0:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  807fe3:	83 fb 02             	cmp    $0x2,%ebx
  807fe6:	76 05                	jbe    807fed <tcp_write+0x1e>
  807fe8:	83 f8 07             	cmp    $0x7,%eax
  807feb:	75 32                	jne    80801f <tcp_write+0x50>
    return ERR_OK;
  807fed:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  807ff2:	66 85 d2             	test   %dx,%dx
  807ff5:	75 07                	jne    807ffe <tcp_write+0x2f>
}
  807ff7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  807ffa:	5b                   	pop    %ebx
  807ffb:	5e                   	pop    %esi
  807ffc:	5d                   	pop    %ebp
  807ffd:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  807ffe:	83 ec 04             	sub    $0x4,%esp
  808001:	6a 00                	push   $0x0
  808003:	6a 00                	push   $0x0
  808005:	89 f0                	mov    %esi,%eax
  808007:	0f b6 f0             	movzbl %al,%esi
  80800a:	56                   	push   %esi
  80800b:	6a 00                	push   $0x0
  80800d:	0f b7 d2             	movzwl %dx,%edx
  808010:	52                   	push   %edx
  808011:	ff 75 0c             	pushl  0xc(%ebp)
  808014:	51                   	push   %ecx
  808015:	e8 ef f8 ff ff       	call   807909 <tcp_enqueue>
  80801a:	83 c4 20             	add    $0x20,%esp
  80801d:	eb d8                	jmp    807ff7 <tcp_write+0x28>
    return ERR_CONN;
  80801f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  808024:	eb d1                	jmp    807ff7 <tcp_write+0x28>

00808026 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  808026:	55                   	push   %ebp
  808027:	89 e5                	mov    %esp,%ebp
  808029:	57                   	push   %edi
  80802a:	56                   	push   %esi
  80802b:	53                   	push   %ebx
  80802c:	83 ec 1c             	sub    $0x1c,%esp
  80802f:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  808032:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  808038:	0f 84 60 04 00 00    	je     80849e <tcp_output+0x478>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80803e:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  808042:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  808046:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  80804b:	0f b7 c0             	movzwl %ax,%eax
  80804e:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  808051:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  808054:	8b 47 78             	mov    0x78(%edi),%eax
  808057:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80805a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  80805d:	85 c0                	test   %eax,%eax
  80805f:	75 04                	jne    808065 <tcp_output+0x3f>
  808061:	eb 0b                	jmp    80806e <tcp_output+0x48>
    for (; useg->next != NULL; useg = useg->next);
  808063:	89 c2                	mov    %eax,%edx
  808065:	8b 02                	mov    (%edx),%eax
  808067:	85 c0                	test   %eax,%eax
  808069:	75 f8                	jne    808063 <tcp_output+0x3d>
  80806b:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80806e:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  808072:	0f 84 e6 03 00 00    	je     80845e <tcp_output+0x438>
  808078:	85 db                	test   %ebx,%ebx
  80807a:	74 23                	je     80809f <tcp_output+0x79>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80807c:	83 ec 0c             	sub    $0xc,%esp
  80807f:	8b 43 10             	mov    0x10(%ebx),%eax
  808082:	ff 70 04             	pushl  0x4(%eax)
  808085:	e8 6c f8 ff ff       	call   8078f6 <ntohl>
  80808a:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80808e:	2b 57 48             	sub    0x48(%edi),%edx
  808091:	01 c2                	add    %eax,%edx
     (seg == NULL ||
  808093:	83 c4 10             	add    $0x10,%esp
  808096:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  808099:	0f 86 bf 03 00 00    	jbe    80845e <tcp_output+0x438>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80809f:	83 ec 04             	sub    $0x4,%esp
  8080a2:	6a 00                	push   $0x0
  8080a4:	6a 14                	push   $0x14
  8080a6:	6a 01                	push   $0x1
  8080a8:	e8 fc c7 ff ff       	call   8048a9 <pbuf_alloc>
  8080ad:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8080af:	83 c4 10             	add    $0x10,%esp
  8080b2:	85 c0                	test   %eax,%eax
  8080b4:	0f 84 eb 03 00 00    	je     8084a5 <tcp_output+0x47f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8080ba:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  8080be:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  8080c1:	83 ec 0c             	sub    $0xc,%esp
  8080c4:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8080c8:	50                   	push   %eax
  8080c9:	e8 f7 f5 ff ff       	call   8076c5 <htons>
  8080ce:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8080d1:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8080d5:	89 04 24             	mov    %eax,(%esp)
  8080d8:	e8 e8 f5 ff ff       	call   8076c5 <htons>
  8080dd:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8080e1:	83 c4 04             	add    $0x4,%esp
  8080e4:	ff 77 54             	pushl  0x54(%edi)
  8080e7:	e8 f3 f5 ff ff       	call   8076df <htonl>
  8080ec:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8080ef:	83 c4 04             	add    $0x4,%esp
  8080f2:	ff 77 24             	pushl  0x24(%edi)
  8080f5:	e8 e5 f5 ff ff       	call   8076df <htonl>
  8080fa:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8080fd:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808101:	89 04 24             	mov    %eax,(%esp)
  808104:	e8 c9 f5 ff ff       	call   8076d2 <ntohs>
  808109:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80810e:	83 c8 10             	or     $0x10,%eax
  808111:	89 04 24             	mov    %eax,(%esp)
  808114:	e8 ac f5 ff ff       	call   8076c5 <htons>
  808119:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80811d:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808121:	89 04 24             	mov    %eax,(%esp)
  808124:	e8 9c f5 ff ff       	call   8076c5 <htons>
  808129:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80812d:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  808133:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808137:	89 04 24             	mov    %eax,(%esp)
  80813a:	e8 93 f5 ff ff       	call   8076d2 <ntohs>
  80813f:	83 e0 3f             	and    $0x3f,%eax
  808142:	80 cc 50             	or     $0x50,%ah
  808145:	89 04 24             	mov    %eax,(%esp)
  808148:	e8 78 f5 ff ff       	call   8076c5 <htons>
  80814d:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808151:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808157:	8d 47 04             	lea    0x4(%edi),%eax
  80815a:	89 c1                	mov    %eax,%ecx
  80815c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808160:	89 04 24             	mov    %eax,(%esp)
  808163:	6a 06                	push   $0x6
  808165:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808168:	51                   	push   %ecx
  808169:	57                   	push   %edi
  80816a:	56                   	push   %esi
  80816b:	e8 31 f2 ff ff       	call   8073a1 <inet_chksum_pseudo>
  808170:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808174:	83 c4 18             	add    $0x18,%esp
  808177:	6a 06                	push   $0x6
  808179:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80817d:	50                   	push   %eax
  80817e:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808182:	50                   	push   %eax
  808183:	ff 75 e4             	pushl  -0x1c(%ebp)
  808186:	57                   	push   %edi
  808187:	56                   	push   %esi
  808188:	e8 24 e8 ff ff       	call   8069b1 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80818d:	83 c4 14             	add    $0x14,%esp
  808190:	56                   	push   %esi
  808191:	e8 4d c6 ff ff       	call   8047e3 <pbuf_free>

    return ERR_OK;
  808196:	83 c4 10             	add    $0x10,%esp
  808199:	b8 00 00 00 00       	mov    $0x0,%eax
  80819e:	e9 1b 03 00 00       	jmp    8084be <tcp_output+0x498>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  8081a3:	83 ec 04             	sub    $0x4,%esp
  8081a6:	68 3f 22 81 00       	push   $0x81223f
  8081ab:	68 05 02 00 00       	push   $0x205
  8081b0:	68 06 22 81 00       	push   $0x812206
  8081b5:	e8 b6 63 00 00       	call   80e570 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8081ba:	83 ec 0c             	sub    $0xc,%esp
  8081bd:	8b 43 10             	mov    0x10(%ebx),%eax
  8081c0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8081c4:	50                   	push   %eax
  8081c5:	e8 08 f5 ff ff       	call   8076d2 <ntohs>
  8081ca:	8b 73 10             	mov    0x10(%ebx),%esi
  8081cd:	83 c8 10             	or     $0x10,%eax
  8081d0:	0f b7 c0             	movzwl %ax,%eax
  8081d3:	89 04 24             	mov    %eax,(%esp)
  8081d6:	e8 ea f4 ff ff       	call   8076c5 <htons>
  8081db:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8081df:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8081e3:	83 c4 10             	add    $0x10,%esp
  8081e6:	e9 06 01 00 00       	jmp    8082f1 <tcp_output+0x2cb>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  8081eb:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  8081f1:	e9 49 01 00 00       	jmp    80833f <tcp_output+0x319>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  8081f6:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8081fb:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8081fe:	83 ec 0c             	sub    $0xc,%esp
  808201:	8b 43 10             	mov    0x10(%ebx),%eax
  808204:	ff 70 04             	pushl  0x4(%eax)
  808207:	e8 ea f6 ff ff       	call   8078f6 <ntohl>
  80820c:	89 47 3c             	mov    %eax,0x3c(%edi)
  80820f:	83 c4 10             	add    $0x10,%esp
  808212:	e9 32 01 00 00       	jmp    808349 <tcp_output+0x323>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808217:	83 ec 0c             	sub    $0xc,%esp
  80821a:	8b 43 10             	mov    0x10(%ebx),%eax
  80821d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808221:	50                   	push   %eax
  808222:	e8 ab f4 ff ff       	call   8076d2 <ntohs>
  808227:	66 d1 e8             	shr    %ax
  80822a:	89 c2                	mov    %eax,%edx
  80822c:	83 e2 01             	and    $0x1,%edx
  80822f:	83 c4 10             	add    $0x10,%esp
  808232:	e9 a5 01 00 00       	jmp    8083dc <tcp_output+0x3b6>
      pcb->snd_max = pcb->snd_nxt;
  808237:	89 77 58             	mov    %esi,0x58(%edi)
  80823a:	e9 ae 01 00 00       	jmp    8083ed <tcp_output+0x3c7>
    if (TCP_TCPLEN(seg) > 0) {
  80823f:	83 ec 0c             	sub    $0xc,%esp
  808242:	8b 43 10             	mov    0x10(%ebx),%eax
  808245:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808249:	50                   	push   %eax
  80824a:	e8 83 f4 ff ff       	call   8076d2 <ntohs>
  80824f:	66 d1 e8             	shr    %ax
  808252:	83 e0 01             	and    $0x1,%eax
  808255:	0f b7 f6             	movzwl %si,%esi
  808258:	83 c4 10             	add    $0x10,%esp
  80825b:	01 f0                	add    %esi,%eax
  80825d:	0f 85 a9 01 00 00    	jne    80840c <tcp_output+0x3e6>
      tcp_seg_free(seg);
  808263:	83 ec 0c             	sub    $0xc,%esp
  808266:	53                   	push   %ebx
  808267:	e8 98 d4 ff ff       	call   805704 <tcp_seg_free>
  80826c:	83 c4 10             	add    $0x10,%esp
  80826f:	eb 06                	jmp    808277 <tcp_output+0x251>
        pcb->unacked = seg;
  808271:	89 5f 78             	mov    %ebx,0x78(%edi)
  808274:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  808277:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  80827a:	85 db                	test   %ebx,%ebx
  80827c:	0f 84 33 02 00 00    	je     8084b5 <tcp_output+0x48f>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808282:	83 ec 0c             	sub    $0xc,%esp
  808285:	8b 43 10             	mov    0x10(%ebx),%eax
  808288:	ff 70 04             	pushl  0x4(%eax)
  80828b:	e8 66 f6 ff ff       	call   8078f6 <ntohl>
  808290:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808294:	2b 57 48             	sub    0x48(%edi),%edx
  808297:	01 c2                	add    %eax,%edx
  while (seg != NULL &&
  808299:	83 c4 10             	add    $0x10,%esp
  80829c:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  80829f:	0f 87 07 02 00 00    	ja     8084ac <tcp_output+0x486>
    LWIP_ASSERT("RST not expected here!", 
  8082a5:	83 ec 0c             	sub    $0xc,%esp
  8082a8:	8b 43 10             	mov    0x10(%ebx),%eax
  8082ab:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082af:	50                   	push   %eax
  8082b0:	e8 1d f4 ff ff       	call   8076d2 <ntohs>
  8082b5:	83 c4 10             	add    $0x10,%esp
  8082b8:	a8 04                	test   $0x4,%al
  8082ba:	0f 85 e3 fe ff ff    	jne    8081a3 <tcp_output+0x17d>
    if((tcp_do_output_nagle(pcb) == 0) &&
  8082c0:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8082c4:	74 1c                	je     8082e2 <tcp_output+0x2bc>
  8082c6:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  8082ca:	a8 40                	test   $0x40,%al
  8082cc:	75 14                	jne    8082e2 <tcp_output+0x2bc>
  8082ce:	8b 57 74             	mov    0x74(%edi),%edx
  8082d1:	85 d2                	test   %edx,%edx
  8082d3:	74 05                	je     8082da <tcp_output+0x2b4>
  8082d5:	83 3a 00             	cmpl   $0x0,(%edx)
  8082d8:	75 08                	jne    8082e2 <tcp_output+0x2bc>
  8082da:	a8 a0                	test   $0xa0,%al
  8082dc:	0f 84 ca 01 00 00    	je     8084ac <tcp_output+0x486>
    pcb->unsent = seg->next;
  8082e2:	8b 03                	mov    (%ebx),%eax
  8082e4:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  8082e7:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8082eb:	0f 85 c9 fe ff ff    	jne    8081ba <tcp_output+0x194>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8082f1:	8b 73 10             	mov    0x10(%ebx),%esi
  8082f4:	83 ec 0c             	sub    $0xc,%esp
  8082f7:	ff 77 24             	pushl  0x24(%edi)
  8082fa:	e8 e0 f3 ff ff       	call   8076df <htonl>
  8082ff:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808302:	8b 73 10             	mov    0x10(%ebx),%esi
  808305:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808309:	89 04 24             	mov    %eax,(%esp)
  80830c:	e8 b4 f3 ff ff       	call   8076c5 <htons>
  808311:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  808315:	83 c4 10             	add    $0x10,%esp
  808318:	83 3f 00             	cmpl   $0x0,(%edi)
  80831b:	75 17                	jne    808334 <tcp_output+0x30e>
    netif = ip_route(&(pcb->remote_ip));
  80831d:	83 ec 0c             	sub    $0xc,%esp
  808320:	ff 75 e4             	pushl  -0x1c(%ebp)
  808323:	e8 79 e1 ff ff       	call   8064a1 <ip_route>
    if (netif == NULL) {
  808328:	83 c4 10             	add    $0x10,%esp
  80832b:	85 c0                	test   %eax,%eax
  80832d:	74 79                	je     8083a8 <tcp_output+0x382>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80832f:	8b 40 04             	mov    0x4(%eax),%eax
  808332:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  808334:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808339:	0f 84 ac fe ff ff    	je     8081eb <tcp_output+0x1c5>
  if (pcb->rttest == 0) {
  80833f:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  808343:	0f 84 ad fe ff ff    	je     8081f6 <tcp_output+0x1d0>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808349:	8b 53 04             	mov    0x4(%ebx),%edx
  80834c:	8b 43 10             	mov    0x10(%ebx),%eax
  80834f:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  808352:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  808356:	8b 53 04             	mov    0x4(%ebx),%edx
  808359:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  80835d:	8b 53 04             	mov    0x4(%ebx),%edx
  808360:	8b 43 10             	mov    0x10(%ebx),%eax
  808363:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  808366:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80836c:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80836f:	8b 73 10             	mov    0x10(%ebx),%esi
  808372:	83 ec 0c             	sub    $0xc,%esp
  808375:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808379:	52                   	push   %edx
  80837a:	6a 06                	push   $0x6
  80837c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80837f:	57                   	push   %edi
  808380:	50                   	push   %eax
  808381:	e8 1b f0 ff ff       	call   8073a1 <inet_chksum_pseudo>
  808386:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80838a:	83 c4 18             	add    $0x18,%esp
  80838d:	6a 06                	push   $0x6
  80838f:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808393:	50                   	push   %eax
  808394:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808398:	50                   	push   %eax
  808399:	ff 75 e4             	pushl  -0x1c(%ebp)
  80839c:	57                   	push   %edi
  80839d:	ff 73 04             	pushl  0x4(%ebx)
  8083a0:	e8 0c e6 ff ff       	call   8069b1 <ip_output>
  8083a5:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8083a8:	83 ec 0c             	sub    $0xc,%esp
  8083ab:	8b 43 10             	mov    0x10(%ebx),%eax
  8083ae:	ff 70 04             	pushl  0x4(%eax)
  8083b1:	e8 40 f5 ff ff       	call   8078f6 <ntohl>
  8083b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8083b9:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8083bd:	8b 43 10             	mov    0x10(%ebx),%eax
  8083c0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8083c4:	89 04 24             	mov    %eax,(%esp)
  8083c7:	e8 06 f3 ff ff       	call   8076d2 <ntohs>
  8083cc:	83 c4 10             	add    $0x10,%esp
  8083cf:	ba 01 00 00 00       	mov    $0x1,%edx
  8083d4:	a8 01                	test   $0x1,%al
  8083d6:	0f 84 3b fe ff ff    	je     808217 <tcp_output+0x1f1>
  8083dc:	01 d6                	add    %edx,%esi
  8083de:	03 75 e0             	add    -0x20(%ebp),%esi
  8083e1:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8083e4:	39 77 58             	cmp    %esi,0x58(%edi)
  8083e7:	0f 88 4a fe ff ff    	js     808237 <tcp_output+0x211>
    if (TCP_TCPLEN(seg) > 0) {
  8083ed:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8083f1:	83 ec 0c             	sub    $0xc,%esp
  8083f4:	8b 43 10             	mov    0x10(%ebx),%eax
  8083f7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8083fb:	50                   	push   %eax
  8083fc:	e8 d1 f2 ff ff       	call   8076d2 <ntohs>
  808401:	83 c4 10             	add    $0x10,%esp
  808404:	a8 01                	test   $0x1,%al
  808406:	0f 84 33 fe ff ff    	je     80823f <tcp_output+0x219>
      seg->next = NULL;
  80840c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  808412:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808416:	0f 84 55 fe ff ff    	je     808271 <tcp_output+0x24b>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80841c:	83 ec 0c             	sub    $0xc,%esp
  80841f:	8b 43 10             	mov    0x10(%ebx),%eax
  808422:	ff 70 04             	pushl  0x4(%eax)
  808425:	e8 cc f4 ff ff       	call   8078f6 <ntohl>
  80842a:	89 c6                	mov    %eax,%esi
  80842c:	83 c4 04             	add    $0x4,%esp
  80842f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808432:	8b 40 10             	mov    0x10(%eax),%eax
  808435:	ff 70 04             	pushl  0x4(%eax)
  808438:	e8 b9 f4 ff ff       	call   8078f6 <ntohl>
  80843d:	83 c4 10             	add    $0x10,%esp
  808440:	39 c6                	cmp    %eax,%esi
  808442:	78 0d                	js     808451 <tcp_output+0x42b>
          useg->next = seg;
  808444:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808447:	89 18                	mov    %ebx,(%eax)
  808449:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  80844c:	e9 26 fe ff ff       	jmp    808277 <tcp_output+0x251>
          seg->next = pcb->unacked;
  808451:	8b 47 78             	mov    0x78(%edi),%eax
  808454:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808456:	89 5f 78             	mov    %ebx,0x78(%edi)
  808459:	e9 19 fe ff ff       	jmp    808277 <tcp_output+0x251>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80845e:	8d 47 04             	lea    0x4(%edi),%eax
  808461:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808464:	e9 11 fe ff ff       	jmp    80827a <tcp_output+0x254>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808469:	83 ec 0c             	sub    $0xc,%esp
  80846c:	8b 43 10             	mov    0x10(%ebx),%eax
  80846f:	ff 70 04             	pushl  0x4(%eax)
  808472:	e8 7f f4 ff ff       	call   8078f6 <ntohl>
  808477:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80847b:	2b 57 48             	sub    0x48(%edi),%edx
  80847e:	01 c2                	add    %eax,%edx
  808480:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  if (seg != NULL && pcb->persist_backoff == 0 && 
  808484:	83 c4 10             	add    $0x10,%esp
  808487:	39 c2                	cmp    %eax,%edx
  808489:	76 2a                	jbe    8084b5 <tcp_output+0x48f>
    pcb->persist_cnt = 0;
  80848b:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808492:	00 00 00 
    pcb->persist_backoff = 1;
  808495:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  80849c:	eb 17                	jmp    8084b5 <tcp_output+0x48f>
    return ERR_OK;
  80849e:	b8 00 00 00 00       	mov    $0x0,%eax
  8084a3:	eb 19                	jmp    8084be <tcp_output+0x498>
      return ERR_BUF;
  8084a5:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8084aa:	eb 12                	jmp    8084be <tcp_output+0x498>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  8084ac:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  8084b3:	74 b4                	je     808469 <tcp_output+0x443>
  pcb->flags &= ~TF_NAGLEMEMERR;
  8084b5:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  8084b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8084be:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8084c1:	5b                   	pop    %ebx
  8084c2:	5e                   	pop    %esi
  8084c3:	5f                   	pop    %edi
  8084c4:	5d                   	pop    %ebp
  8084c5:	c3                   	ret    

008084c6 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  8084c6:	55                   	push   %ebp
  8084c7:	89 e5                	mov    %esp,%ebp
  8084c9:	57                   	push   %edi
  8084ca:	56                   	push   %esi
  8084cb:	53                   	push   %ebx
  8084cc:	83 ec 20             	sub    $0x20,%esp
  8084cf:	8b 7d 18             	mov    0x18(%ebp),%edi
  8084d2:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8084d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8084d8:	6a 00                	push   $0x0
  8084da:	6a 14                	push   $0x14
  8084dc:	6a 01                	push   $0x1
  8084de:	e8 c6 c3 ff ff       	call   8048a9 <pbuf_alloc>
  if (p == NULL) {
  8084e3:	83 c4 10             	add    $0x10,%esp
  8084e6:	85 c0                	test   %eax,%eax
  8084e8:	0f 84 e2 00 00 00    	je     8085d0 <tcp_rst+0x10a>
  8084ee:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8084f0:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8084f5:	0f 86 dd 00 00 00    	jbe    8085d8 <tcp_rst+0x112>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8084fb:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8084fe:	83 ec 0c             	sub    $0xc,%esp
  808501:	0f b7 ff             	movzwl %di,%edi
  808504:	57                   	push   %edi
  808505:	e8 bb f1 ff ff       	call   8076c5 <htons>
  80850a:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80850d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808511:	89 04 24             	mov    %eax,(%esp)
  808514:	e8 ac f1 ff ff       	call   8076c5 <htons>
  808519:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80851d:	83 c4 04             	add    $0x4,%esp
  808520:	ff 75 08             	pushl  0x8(%ebp)
  808523:	e8 b7 f1 ff ff       	call   8076df <htonl>
  808528:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80852b:	83 c4 04             	add    $0x4,%esp
  80852e:	ff 75 0c             	pushl  0xc(%ebp)
  808531:	e8 a9 f1 ff ff       	call   8076df <htonl>
  808536:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808539:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80853d:	89 04 24             	mov    %eax,(%esp)
  808540:	e8 8d f1 ff ff       	call   8076d2 <ntohs>
  808545:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80854a:	83 c8 14             	or     $0x14,%eax
  80854d:	89 04 24             	mov    %eax,(%esp)
  808550:	e8 70 f1 ff ff       	call   8076c5 <htons>
  808555:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808559:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808560:	e8 60 f1 ff ff       	call   8076c5 <htons>
  808565:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808569:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80856f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808573:	89 04 24             	mov    %eax,(%esp)
  808576:	e8 57 f1 ff ff       	call   8076d2 <ntohs>
  80857b:	83 e0 3f             	and    $0x3f,%eax
  80857e:	80 cc 50             	or     $0x50,%ah
  808581:	89 04 24             	mov    %eax,(%esp)
  808584:	e8 3c f1 ff ff       	call   8076c5 <htons>
  808589:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80858d:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808593:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808597:	89 04 24             	mov    %eax,(%esp)
  80859a:	6a 06                	push   $0x6
  80859c:	ff 75 14             	pushl  0x14(%ebp)
  80859f:	ff 75 10             	pushl  0x10(%ebp)
  8085a2:	56                   	push   %esi
  8085a3:	e8 f9 ed ff ff       	call   8073a1 <inet_chksum_pseudo>
  8085a8:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8085ac:	83 c4 18             	add    $0x18,%esp
  8085af:	6a 06                	push   $0x6
  8085b1:	6a 00                	push   $0x0
  8085b3:	68 ff 00 00 00       	push   $0xff
  8085b8:	ff 75 14             	pushl  0x14(%ebp)
  8085bb:	ff 75 10             	pushl  0x10(%ebp)
  8085be:	56                   	push   %esi
  8085bf:	e8 ed e3 ff ff       	call   8069b1 <ip_output>
  pbuf_free(p);
  8085c4:	83 c4 14             	add    $0x14,%esp
  8085c7:	56                   	push   %esi
  8085c8:	e8 16 c2 ff ff       	call   8047e3 <pbuf_free>
  8085cd:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  8085d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8085d3:	5b                   	pop    %ebx
  8085d4:	5e                   	pop    %esi
  8085d5:	5f                   	pop    %edi
  8085d6:	5d                   	pop    %ebp
  8085d7:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8085d8:	83 ec 04             	sub    $0x4,%esp
  8085db:	68 d8 21 81 00       	push   $0x8121d8
  8085e0:	68 be 02 00 00       	push   $0x2be
  8085e5:	68 06 22 81 00       	push   $0x812206
  8085ea:	e8 81 5f 00 00       	call   80e570 <_panic>

008085ef <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8085ef:	55                   	push   %ebp
  8085f0:	89 e5                	mov    %esp,%ebp
  8085f2:	53                   	push   %ebx
  8085f3:	83 ec 04             	sub    $0x4,%esp
  8085f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8085f9:	8b 53 78             	mov    0x78(%ebx),%edx
  8085fc:	85 d2                	test   %edx,%edx
  8085fe:	75 04                	jne    808604 <tcp_rexmit_rto+0x15>
  808600:	eb 41                	jmp    808643 <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  808602:	89 c2                	mov    %eax,%edx
  808604:	8b 02                	mov    (%edx),%eax
  808606:	85 c0                	test   %eax,%eax
  808608:	75 f8                	jne    808602 <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80860a:	8b 43 74             	mov    0x74(%ebx),%eax
  80860d:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80860f:	8b 43 78             	mov    0x78(%ebx),%eax
  808612:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  808615:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80861c:	83 ec 0c             	sub    $0xc,%esp
  80861f:	8b 40 10             	mov    0x10(%eax),%eax
  808622:	ff 70 04             	pushl  0x4(%eax)
  808625:	e8 cc f2 ff ff       	call   8078f6 <ntohl>
  80862a:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80862d:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  808631:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808638:	89 1c 24             	mov    %ebx,(%esp)
  80863b:	e8 e6 f9 ff ff       	call   808026 <tcp_output>
  808640:	83 c4 10             	add    $0x10,%esp
}
  808643:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808646:	c9                   	leave  
  808647:	c3                   	ret    

00808648 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808648:	55                   	push   %ebp
  808649:	89 e5                	mov    %esp,%ebp
  80864b:	53                   	push   %ebx
  80864c:	83 ec 04             	sub    $0x4,%esp
  80864f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808652:	8b 43 78             	mov    0x78(%ebx),%eax
  808655:	85 c0                	test   %eax,%eax
  808657:	74 37                	je     808690 <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808659:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80865b:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80865e:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808660:	8b 43 78             	mov    0x78(%ebx),%eax
  808663:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808666:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808669:	83 ec 0c             	sub    $0xc,%esp
  80866c:	8b 40 10             	mov    0x10(%eax),%eax
  80866f:	ff 70 04             	pushl  0x4(%eax)
  808672:	e8 7f f2 ff ff       	call   8078f6 <ntohl>
  808677:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80867a:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80867e:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808685:	89 1c 24             	mov    %ebx,(%esp)
  808688:	e8 99 f9 ff ff       	call   808026 <tcp_output>
  80868d:	83 c4 10             	add    $0x10,%esp
}
  808690:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808693:	c9                   	leave  
  808694:	c3                   	ret    

00808695 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808695:	55                   	push   %ebp
  808696:	89 e5                	mov    %esp,%ebp
  808698:	57                   	push   %edi
  808699:	56                   	push   %esi
  80869a:	53                   	push   %ebx
  80869b:	83 ec 20             	sub    $0x20,%esp
  80869e:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8086a1:	6a 00                	push   $0x0
  8086a3:	6a 14                	push   $0x14
  8086a5:	6a 01                	push   $0x1
  8086a7:	e8 fd c1 ff ff       	call   8048a9 <pbuf_alloc>
   
  if(p == NULL) {
  8086ac:	83 c4 10             	add    $0x10,%esp
  8086af:	85 c0                	test   %eax,%eax
  8086b1:	0f 84 e5 00 00 00    	je     80879c <tcp_keepalive+0x107>
  8086b7:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8086b9:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8086be:	0f 86 e0 00 00 00    	jbe    8087a4 <tcp_keepalive+0x10f>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8086c4:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8086c7:	83 ec 0c             	sub    $0xc,%esp
  8086ca:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8086ce:	50                   	push   %eax
  8086cf:	e8 f1 ef ff ff       	call   8076c5 <htons>
  8086d4:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8086d7:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8086db:	89 04 24             	mov    %eax,(%esp)
  8086de:	e8 e2 ef ff ff       	call   8076c5 <htons>
  8086e3:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8086e7:	8b 46 54             	mov    0x54(%esi),%eax
  8086ea:	83 e8 01             	sub    $0x1,%eax
  8086ed:	89 04 24             	mov    %eax,(%esp)
  8086f0:	e8 ea ef ff ff       	call   8076df <htonl>
  8086f5:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8086f8:	83 c4 04             	add    $0x4,%esp
  8086fb:	ff 76 24             	pushl  0x24(%esi)
  8086fe:	e8 dc ef ff ff       	call   8076df <htonl>
  808703:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808706:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80870a:	89 04 24             	mov    %eax,(%esp)
  80870d:	e8 c0 ef ff ff       	call   8076d2 <ntohs>
  808712:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808717:	89 04 24             	mov    %eax,(%esp)
  80871a:	e8 a6 ef ff ff       	call   8076c5 <htons>
  80871f:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808723:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808727:	89 04 24             	mov    %eax,(%esp)
  80872a:	e8 96 ef ff ff       	call   8076c5 <htons>
  80872f:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808733:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808739:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80873d:	89 04 24             	mov    %eax,(%esp)
  808740:	e8 8d ef ff ff       	call   8076d2 <ntohs>
  808745:	83 e0 3f             	and    $0x3f,%eax
  808748:	80 cc 50             	or     $0x50,%ah
  80874b:	89 04 24             	mov    %eax,(%esp)
  80874e:	e8 72 ef ff ff       	call   8076c5 <htons>
  808753:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808757:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80875d:	8d 46 04             	lea    0x4(%esi),%eax
  808760:	89 c2                	mov    %eax,%edx
  808762:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808766:	89 04 24             	mov    %eax,(%esp)
  808769:	6a 06                	push   $0x6
  80876b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80876e:	52                   	push   %edx
  80876f:	56                   	push   %esi
  808770:	57                   	push   %edi
  808771:	e8 2b ec ff ff       	call   8073a1 <inet_chksum_pseudo>
  808776:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80877a:	83 c4 18             	add    $0x18,%esp
  80877d:	6a 06                	push   $0x6
  80877f:	6a 00                	push   $0x0
  808781:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808785:	50                   	push   %eax
  808786:	ff 75 e4             	pushl  -0x1c(%ebp)
  808789:	56                   	push   %esi
  80878a:	57                   	push   %edi
  80878b:	e8 21 e2 ff ff       	call   8069b1 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808790:	83 c4 14             	add    $0x14,%esp
  808793:	57                   	push   %edi
  808794:	e8 4a c0 ff ff       	call   8047e3 <pbuf_free>
  808799:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80879c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80879f:	5b                   	pop    %ebx
  8087a0:	5e                   	pop    %esi
  8087a1:	5f                   	pop    %edi
  8087a2:	5d                   	pop    %ebp
  8087a3:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087a4:	83 ec 04             	sub    $0x4,%esp
  8087a7:	68 d8 21 81 00       	push   $0x8121d8
  8087ac:	68 3a 03 00 00       	push   $0x33a
  8087b1:	68 06 22 81 00       	push   $0x812206
  8087b6:	e8 b5 5d 00 00       	call   80e570 <_panic>

008087bb <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8087bb:	55                   	push   %ebp
  8087bc:	89 e5                	mov    %esp,%ebp
  8087be:	57                   	push   %edi
  8087bf:	56                   	push   %esi
  8087c0:	53                   	push   %ebx
  8087c1:	83 ec 1c             	sub    $0x1c,%esp
  8087c4:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8087c7:	8b 46 78             	mov    0x78(%esi),%eax
  8087ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  8087cd:	85 c0                	test   %eax,%eax
  8087cf:	0f 84 10 01 00 00    	je     8088e5 <tcp_zero_window_probe+0x12a>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8087d5:	83 ec 04             	sub    $0x4,%esp
  8087d8:	6a 00                	push   $0x0
  8087da:	6a 15                	push   $0x15
  8087dc:	6a 01                	push   $0x1
  8087de:	e8 c6 c0 ff ff       	call   8048a9 <pbuf_alloc>
  8087e3:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8087e5:	83 c4 10             	add    $0x10,%esp
  8087e8:	85 c0                	test   %eax,%eax
  8087ea:	0f 84 ed 00 00 00    	je     8088dd <tcp_zero_window_probe+0x122>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087f0:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087f5:	0f 86 f9 00 00 00    	jbe    8088f4 <tcp_zero_window_probe+0x139>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087fb:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8087fe:	83 ec 0c             	sub    $0xc,%esp
  808801:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808805:	50                   	push   %eax
  808806:	e8 ba ee ff ff       	call   8076c5 <htons>
  80880b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80880e:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808812:	89 04 24             	mov    %eax,(%esp)
  808815:	e8 ab ee ff ff       	call   8076c5 <htons>
  80881a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80881e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808821:	8b 40 10             	mov    0x10(%eax),%eax
  808824:	8b 40 04             	mov    0x4(%eax),%eax
  808827:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80882a:	83 c4 04             	add    $0x4,%esp
  80882d:	ff 76 24             	pushl  0x24(%esi)
  808830:	e8 aa ee ff ff       	call   8076df <htonl>
  808835:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808838:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80883c:	89 04 24             	mov    %eax,(%esp)
  80883f:	e8 8e ee ff ff       	call   8076d2 <ntohs>
  808844:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808849:	89 04 24             	mov    %eax,(%esp)
  80884c:	e8 74 ee ff ff       	call   8076c5 <htons>
  808851:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808855:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808859:	89 04 24             	mov    %eax,(%esp)
  80885c:	e8 64 ee ff ff       	call   8076c5 <htons>
  808861:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808865:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80886b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80886f:	89 04 24             	mov    %eax,(%esp)
  808872:	e8 5b ee ff ff       	call   8076d2 <ntohs>
  808877:	83 e0 3f             	and    $0x3f,%eax
  80887a:	80 cc 50             	or     $0x50,%ah
  80887d:	89 04 24             	mov    %eax,(%esp)
  808880:	e8 40 ee ff ff       	call   8076c5 <htons>
  808885:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808889:	8b 47 04             	mov    0x4(%edi),%eax
  80888c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80888f:	8b 51 08             	mov    0x8(%ecx),%edx
  808892:	0f b6 12             	movzbl (%edx),%edx
  808895:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808898:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80889e:	8d 46 04             	lea    0x4(%esi),%eax
  8088a1:	89 c1                	mov    %eax,%ecx
  8088a3:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8088a7:	89 04 24             	mov    %eax,(%esp)
  8088aa:	6a 06                	push   $0x6
  8088ac:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8088af:	51                   	push   %ecx
  8088b0:	56                   	push   %esi
  8088b1:	57                   	push   %edi
  8088b2:	e8 ea ea ff ff       	call   8073a1 <inet_chksum_pseudo>
  8088b7:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8088bb:	83 c4 18             	add    $0x18,%esp
  8088be:	6a 06                	push   $0x6
  8088c0:	6a 00                	push   $0x0
  8088c2:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8088c6:	50                   	push   %eax
  8088c7:	ff 75 e4             	pushl  -0x1c(%ebp)
  8088ca:	56                   	push   %esi
  8088cb:	57                   	push   %edi
  8088cc:	e8 e0 e0 ff ff       	call   8069b1 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8088d1:	83 c4 14             	add    $0x14,%esp
  8088d4:	57                   	push   %edi
  8088d5:	e8 09 bf ff ff       	call   8047e3 <pbuf_free>
  8088da:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8088dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8088e0:	5b                   	pop    %ebx
  8088e1:	5e                   	pop    %esi
  8088e2:	5f                   	pop    %edi
  8088e3:	5d                   	pop    %ebp
  8088e4:	c3                   	ret    
    seg = pcb->unsent;
  8088e5:	8b 46 74             	mov    0x74(%esi),%eax
  8088e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  8088eb:	85 c0                	test   %eax,%eax
  8088ed:	74 ee                	je     8088dd <tcp_zero_window_probe+0x122>
  8088ef:	e9 e1 fe ff ff       	jmp    8087d5 <tcp_zero_window_probe+0x1a>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8088f4:	83 ec 04             	sub    $0x4,%esp
  8088f7:	68 d8 21 81 00       	push   $0x8121d8
  8088fc:	68 8d 03 00 00       	push   $0x38d
  808901:	68 06 22 81 00       	push   $0x812206
  808906:	e8 65 5c 00 00       	call   80e570 <_panic>

0080890b <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80890b:	55                   	push   %ebp
  80890c:	89 e5                	mov    %esp,%ebp
  80890e:	57                   	push   %edi
  80890f:	56                   	push   %esi
  808910:	53                   	push   %ebx
  808911:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808914:	8b 45 08             	mov    0x8(%ebp),%eax
  808917:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80891a:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  80891e:	0f b7 07             	movzwl (%edi),%eax
  808921:	50                   	push   %eax
  808922:	e8 ab ed ff ff       	call   8076d2 <ntohs>
  808927:	66 c1 e8 08          	shr    $0x8,%ax
  80892b:	83 e0 0f             	and    $0xf,%eax
  80892e:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808935:	83 c4 10             	add    $0x10,%esp
  808938:	39 c3                	cmp    %eax,%ebx
  80893a:	7c 29                	jl     808965 <udp_input+0x5a>
  80893c:	83 ec 0c             	sub    $0xc,%esp
  80893f:	0f b7 07             	movzwl (%edi),%eax
  808942:	50                   	push   %eax
  808943:	e8 8a ed ff ff       	call   8076d2 <ntohs>
  808948:	83 c4 08             	add    $0x8,%esp
  80894b:	66 c1 e8 06          	shr    $0x6,%ax
  80894f:	83 e0 3c             	and    $0x3c,%eax
  808952:	f7 d8                	neg    %eax
  808954:	98                   	cwtl   
  808955:	50                   	push   %eax
  808956:	ff 75 08             	pushl  0x8(%ebp)
  808959:	e8 b8 bd ff ff       	call   804716 <pbuf_header>
  80895e:	83 c4 10             	add    $0x10,%esp
  808961:	84 c0                	test   %al,%al
  808963:	74 16                	je     80897b <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808965:	83 ec 0c             	sub    $0xc,%esp
  808968:	ff 75 08             	pushl  0x8(%ebp)
  80896b:	e8 73 be ff ff       	call   8047e3 <pbuf_free>
    goto end;
  808970:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808973:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808976:	5b                   	pop    %ebx
  808977:	5e                   	pop    %esi
  808978:	5f                   	pop    %edi
  808979:	5d                   	pop    %ebp
  80897a:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  80897b:	8b 45 08             	mov    0x8(%ebp),%eax
  80897e:	8b 70 04             	mov    0x4(%eax),%esi
  808981:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808984:	83 ec 0c             	sub    $0xc,%esp
  808987:	0f b7 06             	movzwl (%esi),%eax
  80898a:	50                   	push   %eax
  80898b:	e8 42 ed ff ff       	call   8076d2 <ntohs>
  808990:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808994:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808998:	89 04 24             	mov    %eax,(%esp)
  80899b:	e8 32 ed ff ff       	call   8076d2 <ntohs>
  8089a0:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  8089a2:	83 c4 10             	add    $0x10,%esp
  8089a5:	66 83 f8 44          	cmp    $0x44,%ax
  8089a9:	74 22                	je     8089cd <udp_input+0xc2>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8089ab:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
    uncon_pcb = NULL;
  8089b1:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  8089b6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8089bd:	8d 47 10             	lea    0x10(%edi),%eax
  8089c0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8089c3:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8089c6:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8089c8:	e9 e0 00 00 00       	jmp    808aad <udp_input+0x1a2>
    if (src == DHCP_SERVER_PORT) {
  8089cd:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  8089d2:	0f 84 8f 00 00 00    	je     808a67 <udp_input+0x15c>
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  8089d8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8089db:	8b 57 10             	mov    0x10(%edi),%edx
  8089de:	bb 00 00 00 00       	mov    $0x0,%ebx
  8089e3:	39 50 04             	cmp    %edx,0x4(%eax)
  8089e6:	0f 85 2c 02 00 00    	jne    808c18 <udp_input+0x30d>
      if (udphdr->chksum != 0) {
  8089ec:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8089ef:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  8089f4:	74 29                	je     808a1f <udp_input+0x114>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  8089f6:	83 ec 0c             	sub    $0xc,%esp
  8089f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8089fc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808a00:	50                   	push   %eax
  808a01:	6a 11                	push   $0x11
  808a03:	8d 47 10             	lea    0x10(%edi),%eax
  808a06:	50                   	push   %eax
  808a07:	8d 47 0c             	lea    0xc(%edi),%eax
  808a0a:	50                   	push   %eax
  808a0b:	ff 75 08             	pushl  0x8(%ebp)
  808a0e:	e8 8e e9 ff ff       	call   8073a1 <inet_chksum_pseudo>
  808a13:	83 c4 20             	add    $0x20,%esp
  808a16:	66 85 c0             	test   %ax,%ax
  808a19:	0f 85 13 01 00 00    	jne    808b32 <udp_input+0x227>
    if(pbuf_header(p, -UDP_HLEN)) {
  808a1f:	83 ec 08             	sub    $0x8,%esp
  808a22:	6a f8                	push   $0xfffffff8
  808a24:	ff 75 08             	pushl  0x8(%ebp)
  808a27:	e8 ea bc ff ff       	call   804716 <pbuf_header>
  808a2c:	83 c4 10             	add    $0x10,%esp
  808a2f:	84 c0                	test   %al,%al
  808a31:	0f 85 0e 01 00 00    	jne    808b45 <udp_input+0x23a>
    if (pcb != NULL) {
  808a37:	85 db                	test   %ebx,%ebx
  808a39:	0f 84 30 01 00 00    	je     808b6f <udp_input+0x264>
      if (pcb->recv != NULL) {
  808a3f:	8b 53 18             	mov    0x18(%ebx),%edx
  808a42:	85 d2                	test   %edx,%edx
  808a44:	0f 84 12 01 00 00    	je     808b5c <udp_input+0x251>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808a4a:	83 ec 0c             	sub    $0xc,%esp
  808a4d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808a51:	50                   	push   %eax
  808a52:	83 c7 0c             	add    $0xc,%edi
  808a55:	57                   	push   %edi
  808a56:	ff 75 08             	pushl  0x8(%ebp)
  808a59:	53                   	push   %ebx
  808a5a:	ff 73 1c             	pushl  0x1c(%ebx)
  808a5d:	ff d2                	call   *%edx
  808a5f:	83 c4 20             	add    $0x20,%esp
  808a62:	e9 0c ff ff ff       	jmp    808973 <udp_input+0x68>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808a67:	8b 45 0c             	mov    0xc(%ebp),%eax
  808a6a:	8b 40 20             	mov    0x20(%eax),%eax
  808a6d:	85 c0                	test   %eax,%eax
  808a6f:	0f 84 63 ff ff ff    	je     8089d8 <udp_input+0xcd>
  808a75:	8b 58 08             	mov    0x8(%eax),%ebx
  808a78:	85 db                	test   %ebx,%ebx
  808a7a:	0f 84 58 ff ff ff    	je     8089d8 <udp_input+0xcd>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808a80:	8b 43 04             	mov    0x4(%ebx),%eax
  808a83:	85 c0                	test   %eax,%eax
  808a85:	0f 84 61 ff ff ff    	je     8089ec <udp_input+0xe1>
  808a8b:	3b 47 0c             	cmp    0xc(%edi),%eax
  808a8e:	0f 85 44 ff ff ff    	jne    8089d8 <udp_input+0xcd>
  808a94:	e9 53 ff ff ff       	jmp    8089ec <udp_input+0xe1>
        if ((uncon_pcb == NULL) && 
  808a99:	85 ff                	test   %edi,%edi
  808a9b:	74 3f                	je     808adc <udp_input+0x1d1>
      if ((local_match != 0) &&
  808a9d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808aa1:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808aa5:	74 41                	je     808ae8 <udp_input+0x1dd>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808aa7:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808aaa:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808aad:	85 db                	test   %ebx,%ebx
  808aaf:	74 6d                	je     808b1e <udp_input+0x213>
      if ((pcb->local_port == dest) &&
  808ab1:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808ab5:	75 f0                	jne    808aa7 <udp_input+0x19c>
          (ip_addr_isany(&pcb->local_ip) ||
  808ab7:	8b 03                	mov    (%ebx),%eax
  808ab9:	85 c0                	test   %eax,%eax
  808abb:	74 dc                	je     808a99 <udp_input+0x18e>
  808abd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808ac0:	3b 41 10             	cmp    0x10(%ecx),%eax
  808ac3:	74 d4                	je     808a99 <udp_input+0x18e>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808ac5:	83 ec 08             	sub    $0x8,%esp
  808ac8:	ff 75 0c             	pushl  0xc(%ebp)
  808acb:	ff 75 d4             	pushl  -0x2c(%ebp)
  808ace:	e8 8e d9 ff ff       	call   806461 <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808ad3:	83 c4 10             	add    $0x10,%esp
  808ad6:	84 c0                	test   %al,%al
  808ad8:	74 cd                	je     808aa7 <udp_input+0x19c>
  808ada:	eb bd                	jmp    808a99 <udp_input+0x18e>
        if ((uncon_pcb == NULL) && 
  808adc:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  808ae0:	83 e0 04             	and    $0x4,%eax
  808ae3:	0f 44 fb             	cmove  %ebx,%edi
  808ae6:	eb b5                	jmp    808a9d <udp_input+0x192>
          (ip_addr_isany(&pcb->remote_ip) ||
  808ae8:	8b 43 04             	mov    0x4(%ebx),%eax
  808aeb:	85 c0                	test   %eax,%eax
  808aed:	74 08                	je     808af7 <udp_input+0x1ec>
  808aef:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808af2:	3b 42 0c             	cmp    0xc(%edx),%eax
  808af5:	75 b0                	jne    808aa7 <udp_input+0x19c>
  808af7:	8b 7d dc             	mov    -0x24(%ebp),%edi
        if (prev != NULL) {
  808afa:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808afd:	85 c9                	test   %ecx,%ecx
  808aff:	0f 84 e7 fe ff ff    	je     8089ec <udp_input+0xe1>
          prev->next = pcb->next;
  808b05:	8b 43 0c             	mov    0xc(%ebx),%eax
  808b08:	89 41 0c             	mov    %eax,0xc(%ecx)
          pcb->next = udp_pcbs;
  808b0b:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808b10:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808b13:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808b19:	e9 ce fe ff ff       	jmp    8089ec <udp_input+0xe1>
  808b1e:	89 f8                	mov    %edi,%eax
  808b20:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808b23:	85 c0                	test   %eax,%eax
  808b25:	0f 84 ad fe ff ff    	je     8089d8 <udp_input+0xcd>
  808b2b:	89 c3                	mov    %eax,%ebx
  808b2d:	e9 ba fe ff ff       	jmp    8089ec <udp_input+0xe1>
          pbuf_free(p);
  808b32:	83 ec 0c             	sub    $0xc,%esp
  808b35:	ff 75 08             	pushl  0x8(%ebp)
  808b38:	e8 a6 bc ff ff       	call   8047e3 <pbuf_free>
          goto end;
  808b3d:	83 c4 10             	add    $0x10,%esp
  808b40:	e9 2e fe ff ff       	jmp    808973 <udp_input+0x68>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808b45:	83 ec 04             	sub    $0x4,%esp
  808b48:	68 2b 22 81 00       	push   $0x81222b
  808b4d:	68 0a 01 00 00       	push   $0x10a
  808b52:	68 56 22 81 00       	push   $0x812256
  808b57:	e8 14 5a 00 00       	call   80e570 <_panic>
        pbuf_free(p);
  808b5c:	83 ec 0c             	sub    $0xc,%esp
  808b5f:	ff 75 08             	pushl  0x8(%ebp)
  808b62:	e8 7c bc ff ff       	call   8047e3 <pbuf_free>
        goto end;
  808b67:	83 c4 10             	add    $0x10,%esp
  808b6a:	e9 04 fe ff ff       	jmp    808973 <udp_input+0x68>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808b6f:	83 ec 08             	sub    $0x8,%esp
  808b72:	ff 75 0c             	pushl  0xc(%ebp)
  808b75:	8d 47 10             	lea    0x10(%edi),%eax
  808b78:	50                   	push   %eax
  808b79:	e8 e3 d8 ff ff       	call   806461 <ip_addr_isbroadcast>
  808b7e:	83 c4 10             	add    $0x10,%esp
  808b81:	84 c0                	test   %al,%al
  808b83:	75 25                	jne    808baa <udp_input+0x29f>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808b85:	8b 5f 10             	mov    0x10(%edi),%ebx
  808b88:	83 ec 0c             	sub    $0xc,%esp
  808b8b:	68 00 00 00 f0       	push   $0xf0000000
  808b90:	e8 61 ed ff ff       	call   8078f6 <ntohl>
  808b95:	21 c3                	and    %eax,%ebx
  808b97:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808b9e:	e8 53 ed ff ff       	call   8078f6 <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808ba3:	83 c4 10             	add    $0x10,%esp
  808ba6:	39 c3                	cmp    %eax,%ebx
  808ba8:	75 13                	jne    808bbd <udp_input+0x2b2>
      pbuf_free(p);
  808baa:	83 ec 0c             	sub    $0xc,%esp
  808bad:	ff 75 08             	pushl  0x8(%ebp)
  808bb0:	e8 2e bc ff ff       	call   8047e3 <pbuf_free>
  808bb5:	83 c4 10             	add    $0x10,%esp
  808bb8:	e9 b6 fd ff ff       	jmp    808973 <udp_input+0x68>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808bbd:	83 ec 0c             	sub    $0xc,%esp
  808bc0:	0f b7 07             	movzwl (%edi),%eax
  808bc3:	50                   	push   %eax
  808bc4:	e8 09 eb ff ff       	call   8076d2 <ntohs>
  808bc9:	83 c4 08             	add    $0x8,%esp
  808bcc:	66 c1 e8 08          	shr    $0x8,%ax
  808bd0:	83 e0 0f             	and    $0xf,%eax
  808bd3:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808bda:	98                   	cwtl   
  808bdb:	50                   	push   %eax
  808bdc:	ff 75 08             	pushl  0x8(%ebp)
  808bdf:	e8 32 bb ff ff       	call   804716 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808be4:	83 c4 10             	add    $0x10,%esp
  808be7:	8b 45 08             	mov    0x8(%ebp),%eax
  808bea:	3b 78 04             	cmp    0x4(%eax),%edi
  808bed:	75 12                	jne    808c01 <udp_input+0x2f6>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808bef:	83 ec 08             	sub    $0x8,%esp
  808bf2:	6a 03                	push   $0x3
  808bf4:	ff 75 08             	pushl  0x8(%ebp)
  808bf7:	e8 4e 57 00 00       	call   80e34a <icmp_dest_unreach>
  808bfc:	83 c4 10             	add    $0x10,%esp
  808bff:	eb a9                	jmp    808baa <udp_input+0x29f>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808c01:	83 ec 04             	sub    $0x4,%esp
  808c04:	68 6a 22 81 00       	push   $0x81226a
  808c09:	68 25 01 00 00       	push   $0x125
  808c0e:	68 56 22 81 00       	push   $0x812256
  808c13:	e8 58 59 00 00       	call   80e570 <_panic>
    pbuf_free(p);
  808c18:	83 ec 0c             	sub    $0xc,%esp
  808c1b:	ff 75 08             	pushl  0x8(%ebp)
  808c1e:	e8 c0 bb ff ff       	call   8047e3 <pbuf_free>
  808c23:	83 c4 10             	add    $0x10,%esp
}
  808c26:	e9 48 fd ff ff       	jmp    808973 <udp_input+0x68>

00808c2b <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808c2b:	55                   	push   %ebp
  808c2c:	89 e5                	mov    %esp,%ebp
  808c2e:	57                   	push   %edi
  808c2f:	56                   	push   %esi
  808c30:	53                   	push   %ebx
  808c31:	83 ec 0c             	sub    $0xc,%esp
  808c34:	8b 55 08             	mov    0x8(%ebp),%edx
  808c37:	8b 7d 10             	mov    0x10(%ebp),%edi
  808c3a:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c3c:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  rebind = 0;
  808c41:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808c46:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c4b:	eb 1a                	jmp    808c67 <udp_bind+0x3c>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808c4d:	83 ec 04             	sub    $0x4,%esp
  808c50:	68 7e 22 81 00       	push   $0x81227e
  808c55:	68 41 02 00 00       	push   $0x241
  808c5a:	68 56 22 81 00       	push   $0x812256
  808c5f:	e8 0c 59 00 00       	call   80e570 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c64:	8b 40 0c             	mov    0xc(%eax),%eax
  808c67:	85 c0                	test   %eax,%eax
  808c69:	74 0c                	je     808c77 <udp_bind+0x4c>
    if (pcb == ipcb) {
  808c6b:	39 d0                	cmp    %edx,%eax
  808c6d:	75 f5                	jne    808c64 <udp_bind+0x39>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808c6f:	84 db                	test   %bl,%bl
  808c71:	75 da                	jne    808c4d <udp_bind+0x22>
      rebind = 1;
  808c73:	89 f3                	mov    %esi,%ebx
  808c75:	eb ed                	jmp    808c64 <udp_bind+0x39>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808c77:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808c7b:	74 05                	je     808c82 <udp_bind+0x57>
  808c7d:	8b 45 0c             	mov    0xc(%ebp),%eax
  808c80:	8b 00                	mov    (%eax),%eax
  808c82:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808c84:	66 85 ff             	test   %di,%di
  808c87:	75 2e                	jne    808cb7 <udp_bind+0x8c>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808c89:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808c8f:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808c91:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c96:	eb 03                	jmp    808c9b <udp_bind+0x70>
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808c98:	8b 40 0c             	mov    0xc(%eax),%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c9b:	85 c0                	test   %eax,%eax
  808c9d:	74 14                	je     808cb3 <udp_bind+0x88>
  808c9f:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808ca4:	74 0d                	je     808cb3 <udp_bind+0x88>
      if (ipcb->local_port == port) {
  808ca6:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808caa:	75 ec                	jne    808c98 <udp_bind+0x6d>
        port++;
  808cac:	83 c1 01             	add    $0x1,%ecx
        ipcb = udp_pcbs;
  808caf:	89 f0                	mov    %esi,%eax
  808cb1:	eb e8                	jmp    808c9b <udp_bind+0x70>
    }
    if (ipcb != NULL) {
  808cb3:	85 c0                	test   %eax,%eax
  808cb5:	75 28                	jne    808cdf <udp_bind+0xb4>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808cb7:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808cbb:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808cc0:	84 db                	test   %bl,%bl
  808cc2:	75 13                	jne    808cd7 <udp_bind+0xac>
    pcb->next = udp_pcbs;
  808cc4:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808cc9:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808ccc:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
  return ERR_OK;
  808cd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808cd7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808cda:	5b                   	pop    %ebx
  808cdb:	5e                   	pop    %esi
  808cdc:	5f                   	pop    %edi
  808cdd:	5d                   	pop    %ebp
  808cde:	c3                   	ret    
      return ERR_USE;
  808cdf:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808ce4:	eb f1                	jmp    808cd7 <udp_bind+0xac>

00808ce6 <udp_sendto_if>:
{
  808ce6:	55                   	push   %ebp
  808ce7:	89 e5                	mov    %esp,%ebp
  808ce9:	57                   	push   %edi
  808cea:	56                   	push   %esi
  808ceb:	53                   	push   %ebx
  808cec:	83 ec 1c             	sub    $0x1c,%esp
  808cef:	8b 75 08             	mov    0x8(%ebp),%esi
  808cf2:	8b 45 14             	mov    0x14(%ebp),%eax
  808cf5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808cf8:	66 83 7e 12 00       	cmpw   $0x0,0x12(%esi)
  808cfd:	75 19                	jne    808d18 <udp_sendto_if+0x32>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808cff:	83 ec 04             	sub    $0x4,%esp
  808d02:	6a 00                	push   $0x0
  808d04:	56                   	push   %esi
  808d05:	56                   	push   %esi
  808d06:	e8 20 ff ff ff       	call   808c2b <udp_bind>
  808d0b:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  808d0d:	83 c4 10             	add    $0x10,%esp
  808d10:	84 c0                	test   %al,%al
  808d12:	0f 85 b7 00 00 00    	jne    808dcf <udp_sendto_if+0xe9>
  if (pbuf_header(p, UDP_HLEN)) {
  808d18:	83 ec 08             	sub    $0x8,%esp
  808d1b:	6a 08                	push   $0x8
  808d1d:	ff 75 0c             	pushl  0xc(%ebp)
  808d20:	e8 f1 b9 ff ff       	call   804716 <pbuf_header>
  808d25:	83 c4 10             	add    $0x10,%esp
    q = p;
  808d28:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  808d2b:	84 c0                	test   %al,%al
  808d2d:	0f 85 a6 00 00 00    	jne    808dd9 <udp_sendto_if+0xf3>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808d33:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  808d38:	0f 86 ca 00 00 00    	jbe    808e08 <udp_sendto_if+0x122>
  udphdr = q->payload;
  808d3e:	8b 7b 04             	mov    0x4(%ebx),%edi
  udphdr->src = htons(pcb->local_port);
  808d41:	83 ec 0c             	sub    $0xc,%esp
  808d44:	0f b7 46 12          	movzwl 0x12(%esi),%eax
  808d48:	50                   	push   %eax
  808d49:	e8 77 e9 ff ff       	call   8076c5 <htons>
  808d4e:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  808d51:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808d55:	89 04 24             	mov    %eax,(%esp)
  808d58:	e8 68 e9 ff ff       	call   8076c5 <htons>
  808d5d:	66 89 47 02          	mov    %ax,0x2(%edi)
  udphdr->chksum = 0x0000; 
  808d61:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)
  if (ip_addr_isany(&pcb->local_ip)) {
  808d67:	8b 06                	mov    (%esi),%eax
  808d69:	83 c4 10             	add    $0x10,%esp
  808d6c:	85 c0                	test   %eax,%eax
  808d6e:	0f 85 ab 00 00 00    	jne    808e1f <udp_sendto_if+0x139>
    src_ip = &(netif->ip_addr);
  808d74:	8b 45 18             	mov    0x18(%ebp),%eax
  808d77:	83 c0 04             	add    $0x4,%eax
  808d7a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  808d7d:	83 ec 0c             	sub    $0xc,%esp
  808d80:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808d84:	50                   	push   %eax
  808d85:	e8 3b e9 ff ff       	call   8076c5 <htons>
  808d8a:	66 89 47 04          	mov    %ax,0x4(%edi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808d8e:	83 c4 10             	add    $0x10,%esp
  808d91:	f6 46 10 01          	testb  $0x1,0x10(%esi)
  808d95:	0f 84 ac 00 00 00    	je     808e47 <udp_sendto_if+0x161>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808d9b:	83 ec 04             	sub    $0x4,%esp
  808d9e:	ff 75 18             	pushl  0x18(%ebp)
  808da1:	6a 11                	push   $0x11
  808da3:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808da7:	50                   	push   %eax
  808da8:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808dac:	50                   	push   %eax
  808dad:	ff 75 10             	pushl  0x10(%ebp)
  808db0:	ff 75 e4             	pushl  -0x1c(%ebp)
  808db3:	53                   	push   %ebx
  808db4:	e8 6b da ff ff       	call   806824 <ip_output_if>
  808db9:	89 c7                	mov    %eax,%edi
  if (q != p) {
  808dbb:	83 c4 20             	add    $0x20,%esp
  808dbe:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808dc1:	74 0c                	je     808dcf <udp_sendto_if+0xe9>
    pbuf_free(q);
  808dc3:	83 ec 0c             	sub    $0xc,%esp
  808dc6:	53                   	push   %ebx
  808dc7:	e8 17 ba ff ff       	call   8047e3 <pbuf_free>
  808dcc:	83 c4 10             	add    $0x10,%esp
}
  808dcf:	89 f8                	mov    %edi,%eax
  808dd1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808dd4:	5b                   	pop    %ebx
  808dd5:	5e                   	pop    %esi
  808dd6:	5f                   	pop    %edi
  808dd7:	5d                   	pop    %ebp
  808dd8:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808dd9:	83 ec 04             	sub    $0x4,%esp
  808ddc:	6a 00                	push   $0x0
  808dde:	6a 08                	push   $0x8
  808de0:	6a 01                	push   $0x1
  808de2:	e8 c2 ba ff ff       	call   8048a9 <pbuf_alloc>
  808de7:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  808de9:	83 c4 10             	add    $0x10,%esp
  808dec:	85 c0                	test   %eax,%eax
  808dee:	0f 84 80 00 00 00    	je     808e74 <udp_sendto_if+0x18e>
    pbuf_chain(q, p);
  808df4:	83 ec 08             	sub    $0x8,%esp
  808df7:	ff 75 0c             	pushl  0xc(%ebp)
  808dfa:	50                   	push   %eax
  808dfb:	e8 c4 be ff ff       	call   804cc4 <pbuf_chain>
  808e00:	83 c4 10             	add    $0x10,%esp
  808e03:	e9 2b ff ff ff       	jmp    808d33 <udp_sendto_if+0x4d>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808e08:	83 ec 04             	sub    $0x4,%esp
  808e0b:	68 8c 22 81 00       	push   $0x81228c
  808e10:	68 b2 01 00 00       	push   $0x1b2
  808e15:	68 56 22 81 00       	push   $0x812256
  808e1a:	e8 51 57 00 00       	call   80e570 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808e1f:	8b 4d 18             	mov    0x18(%ebp),%ecx
  808e22:	3b 41 04             	cmp    0x4(%ecx),%eax
  808e25:	75 08                	jne    808e2f <udp_sendto_if+0x149>
  if (ip_addr_isany(&pcb->local_ip)) {
  808e27:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  808e2a:	e9 4e ff ff ff       	jmp    808d7d <udp_sendto_if+0x97>
      return ERR_VAL;
  808e2f:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
      if (q != p) {
  808e34:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808e37:	74 96                	je     808dcf <udp_sendto_if+0xe9>
        pbuf_free(q);
  808e39:	83 ec 0c             	sub    $0xc,%esp
  808e3c:	53                   	push   %ebx
  808e3d:	e8 a1 b9 ff ff       	call   8047e3 <pbuf_free>
  808e42:	83 c4 10             	add    $0x10,%esp
  808e45:	eb 88                	jmp    808dcf <udp_sendto_if+0xe9>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808e47:	83 ec 0c             	sub    $0xc,%esp
  808e4a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808e4e:	50                   	push   %eax
  808e4f:	6a 11                	push   $0x11
  808e51:	ff 75 10             	pushl  0x10(%ebp)
  808e54:	ff 75 e4             	pushl  -0x1c(%ebp)
  808e57:	53                   	push   %ebx
  808e58:	e8 44 e5 ff ff       	call   8073a1 <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808e5d:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808e60:	66 85 c0             	test   %ax,%ax
  808e63:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808e68:	0f 44 c2             	cmove  %edx,%eax
  808e6b:	66 89 47 06          	mov    %ax,0x6(%edi)
  808e6f:	e9 27 ff ff ff       	jmp    808d9b <udp_sendto_if+0xb5>
      return ERR_MEM;
  808e74:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  808e79:	e9 51 ff ff ff       	jmp    808dcf <udp_sendto_if+0xe9>

00808e7e <udp_sendto>:
{
  808e7e:	55                   	push   %ebp
  808e7f:	89 e5                	mov    %esp,%ebp
  808e81:	56                   	push   %esi
  808e82:	53                   	push   %ebx
  808e83:	8b 75 10             	mov    0x10(%ebp),%esi
  808e86:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  808e89:	83 ec 0c             	sub    $0xc,%esp
  808e8c:	56                   	push   %esi
  808e8d:	e8 0f d6 ff ff       	call   8064a1 <ip_route>
  if (netif == NULL) {
  808e92:	83 c4 10             	add    $0x10,%esp
  808e95:	85 c0                	test   %eax,%eax
  808e97:	74 1e                	je     808eb7 <udp_sendto+0x39>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808e99:	83 ec 0c             	sub    $0xc,%esp
  808e9c:	50                   	push   %eax
  808e9d:	0f b7 db             	movzwl %bx,%ebx
  808ea0:	53                   	push   %ebx
  808ea1:	56                   	push   %esi
  808ea2:	ff 75 0c             	pushl  0xc(%ebp)
  808ea5:	ff 75 08             	pushl  0x8(%ebp)
  808ea8:	e8 39 fe ff ff       	call   808ce6 <udp_sendto_if>
  808ead:	83 c4 20             	add    $0x20,%esp
}
  808eb0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808eb3:	5b                   	pop    %ebx
  808eb4:	5e                   	pop    %esi
  808eb5:	5d                   	pop    %ebp
  808eb6:	c3                   	ret    
    return ERR_RTE;
  808eb7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  808ebc:	eb f2                	jmp    808eb0 <udp_sendto+0x32>

00808ebe <udp_send>:
{
  808ebe:	55                   	push   %ebp
  808ebf:	89 e5                	mov    %esp,%ebp
  808ec1:	83 ec 08             	sub    $0x8,%esp
  808ec4:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808ec7:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808ecb:	52                   	push   %edx
  808ecc:	8d 50 04             	lea    0x4(%eax),%edx
  808ecf:	52                   	push   %edx
  808ed0:	ff 75 0c             	pushl  0xc(%ebp)
  808ed3:	50                   	push   %eax
  808ed4:	e8 a5 ff ff ff       	call   808e7e <udp_sendto>
}
  808ed9:	c9                   	leave  
  808eda:	c3                   	ret    

00808edb <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808edb:	55                   	push   %ebp
  808edc:	89 e5                	mov    %esp,%ebp
  808ede:	57                   	push   %edi
  808edf:	56                   	push   %esi
  808ee0:	53                   	push   %ebx
  808ee1:	83 ec 0c             	sub    $0xc,%esp
  808ee4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808ee7:	8b 75 0c             	mov    0xc(%ebp),%esi
  808eea:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808eed:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808ef2:	74 2b                	je     808f1f <udp_connect+0x44>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808ef4:	b8 00 00 00 00       	mov    $0x0,%eax
  808ef9:	85 f6                	test   %esi,%esi
  808efb:	74 02                	je     808eff <udp_connect+0x24>
  808efd:	8b 06                	mov    (%esi),%eax
  808eff:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808f02:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808f06:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f0a:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  808f10:	89 d0                	mov    %edx,%eax
  808f12:	85 c0                	test   %eax,%eax
  808f14:	74 1e                	je     808f34 <udp_connect+0x59>
    if (pcb == ipcb) {
  808f16:	39 d8                	cmp    %ebx,%eax
  808f18:	74 2b                	je     808f45 <udp_connect+0x6a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f1a:	8b 40 0c             	mov    0xc(%eax),%eax
  808f1d:	eb f3                	jmp    808f12 <udp_connect+0x37>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808f1f:	83 ec 04             	sub    $0x4,%esp
  808f22:	6a 00                	push   $0x0
  808f24:	53                   	push   %ebx
  808f25:	53                   	push   %ebx
  808f26:	e8 00 fd ff ff       	call   808c2b <udp_bind>
    if (err != ERR_OK)
  808f2b:	83 c4 10             	add    $0x10,%esp
  808f2e:	84 c0                	test   %al,%al
  808f30:	74 c2                	je     808ef4 <udp_connect+0x19>
  808f32:	eb 09                	jmp    808f3d <udp_connect+0x62>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808f34:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808f37:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
}
  808f3d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808f40:	5b                   	pop    %ebx
  808f41:	5e                   	pop    %esi
  808f42:	5f                   	pop    %edi
  808f43:	5d                   	pop    %ebp
  808f44:	c3                   	ret    
      return ERR_OK;
  808f45:	b8 00 00 00 00       	mov    $0x0,%eax
  808f4a:	eb f1                	jmp    808f3d <udp_connect+0x62>

00808f4c <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808f4c:	55                   	push   %ebp
  808f4d:	89 e5                	mov    %esp,%ebp
  808f4f:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808f52:	8b 15 c8 1e 81 00    	mov    0x811ec8,%edx
  808f58:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808f5b:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808f61:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  808f65:	5d                   	pop    %ebp
  808f66:	c3                   	ret    

00808f67 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  808f67:	55                   	push   %ebp
  808f68:	89 e5                	mov    %esp,%ebp
  808f6a:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  808f6d:	8b 55 0c             	mov    0xc(%ebp),%edx
  808f70:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  808f73:	8b 55 10             	mov    0x10(%ebp),%edx
  808f76:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  808f79:	5d                   	pop    %ebp
  808f7a:	c3                   	ret    

00808f7b <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  808f7b:	55                   	push   %ebp
  808f7c:	89 e5                	mov    %esp,%ebp
  808f7e:	83 ec 08             	sub    $0x8,%esp
  808f81:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  808f84:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808f89:	39 c8                	cmp    %ecx,%eax
  808f8b:	75 1b                	jne    808fa8 <udp_remove+0x2d>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  808f8d:	8b 41 0c             	mov    0xc(%ecx),%eax
  808f90:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  808f95:	83 ec 08             	sub    $0x8,%esp
  808f98:	51                   	push   %ecx
  808f99:	6a 01                	push   $0x1
  808f9b:	e8 f3 b4 ff ff       	call   804493 <memp_free>
}
  808fa0:	83 c4 10             	add    $0x10,%esp
  808fa3:	c9                   	leave  
  808fa4:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  808fa5:	8b 40 0c             	mov    0xc(%eax),%eax
  808fa8:	85 c0                	test   %eax,%eax
  808faa:	74 e9                	je     808f95 <udp_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  808fac:	8b 50 0c             	mov    0xc(%eax),%edx
  808faf:	39 ca                	cmp    %ecx,%edx
  808fb1:	75 f2                	jne    808fa5 <udp_remove+0x2a>
  808fb3:	85 d2                	test   %edx,%edx
  808fb5:	74 ee                	je     808fa5 <udp_remove+0x2a>
        pcb2->next = pcb->next;
  808fb7:	8b 51 0c             	mov    0xc(%ecx),%edx
  808fba:	89 50 0c             	mov    %edx,0xc(%eax)
  808fbd:	eb e6                	jmp    808fa5 <udp_remove+0x2a>

00808fbf <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  808fbf:	55                   	push   %ebp
  808fc0:	89 e5                	mov    %esp,%ebp
  808fc2:	53                   	push   %ebx
  808fc3:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  808fc6:	6a 01                	push   $0x1
  808fc8:	e8 70 b4 ff ff       	call   80443d <memp_malloc>
  808fcd:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  808fcf:	83 c4 10             	add    $0x10,%esp
  808fd2:	85 c0                	test   %eax,%eax
  808fd4:	74 14                	je     808fea <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  808fd6:	83 ec 04             	sub    $0x4,%esp
  808fd9:	6a 20                	push   $0x20
  808fdb:	6a 00                	push   $0x0
  808fdd:	50                   	push   %eax
  808fde:	e8 8a 5d 00 00       	call   80ed6d <memset>
    pcb->ttl = UDP_TTL;
  808fe3:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  808fe7:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808fea:	89 d8                	mov    %ebx,%eax
  808fec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808fef:	c9                   	leave  
  808ff0:	c3                   	ret    

00808ff1 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  808ff1:	55                   	push   %ebp
  808ff2:	89 e5                	mov    %esp,%ebp
  808ff4:	56                   	push   %esi
  808ff5:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  808ff6:	85 c0                	test   %eax,%eax
  808ff8:	74 35                	je     80902f <free_etharp_q+0x3e>
  808ffa:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  808ffc:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  809000:	74 44                	je     809046 <free_etharp_q+0x55>
  while (q) {
    r = q;
    q = q->next;
  809002:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809004:	8b 43 04             	mov    0x4(%ebx),%eax
  809007:	85 c0                	test   %eax,%eax
  809009:	74 52                	je     80905d <free_etharp_q+0x6c>
    pbuf_free(r->p);
  80900b:	83 ec 0c             	sub    $0xc,%esp
  80900e:	50                   	push   %eax
  80900f:	e8 cf b7 ff ff       	call   8047e3 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  809014:	83 c4 08             	add    $0x8,%esp
  809017:	53                   	push   %ebx
  809018:	6a 0a                	push   $0xa
  80901a:	e8 74 b4 ff ff       	call   804493 <memp_free>
    q = q->next;
  80901f:	89 f3                	mov    %esi,%ebx
  while (q) {
  809021:	83 c4 10             	add    $0x10,%esp
  809024:	85 f6                	test   %esi,%esi
  809026:	75 da                	jne    809002 <free_etharp_q+0x11>
  }
}
  809028:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80902b:	5b                   	pop    %ebx
  80902c:	5e                   	pop    %esi
  80902d:	5d                   	pop    %ebp
  80902e:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  80902f:	83 ec 04             	sub    $0x4,%esp
  809032:	68 cc 19 81 00       	push   $0x8119cc
  809037:	68 93 00 00 00       	push   $0x93
  80903c:	68 ba 22 81 00       	push   $0x8122ba
  809041:	e8 2a 55 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  809046:	83 ec 04             	sub    $0x4,%esp
  809049:	68 d2 22 81 00       	push   $0x8122d2
  80904e:	68 94 00 00 00       	push   $0x94
  809053:	68 ba 22 81 00       	push   $0x8122ba
  809058:	e8 13 55 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80905d:	83 ec 04             	sub    $0x4,%esp
  809060:	68 df 22 81 00       	push   $0x8122df
  809065:	68 98 00 00 00       	push   $0x98
  80906a:	68 ba 22 81 00       	push   $0x8122ba
  80906f:	e8 fc 54 00 00       	call   80e570 <_panic>

00809074 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809074:	55                   	push   %ebp
  809075:	89 e5                	mov    %esp,%ebp
  809077:	57                   	push   %edi
  809078:	56                   	push   %esi
  809079:	53                   	push   %ebx
  80907a:	83 ec 1c             	sub    $0x1c,%esp
  80907d:	89 55 dc             	mov    %edx,-0x24(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809080:	85 c0                	test   %eax,%eax
  809082:	0f 84 e9 00 00 00    	je     809171 <find_entry+0xfd>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809088:	0f b6 15 00 4a b3 00 	movzbl 0xb34a00,%edx
  80908f:	0f b6 ca             	movzbl %dl,%ecx
  809092:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  809095:	83 bb 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ebx)
  80909c:	0f 84 9f 00 00 00    	je     809141 <find_entry+0xcd>
  8090a2:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8090a6:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  8090aa:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8090ae:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8090b2:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  8090b6:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8090ba:	ba 00 00 00 00       	mov    $0x0,%edx
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8090bf:	0f b6 ca             	movzbl %dl,%ecx
  8090c2:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8090c5:	83 b9 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%ecx)
  8090cc:	0f 85 c1 00 00 00    	jne    809193 <find_entry+0x11f>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8090d2:	89 d1                	mov    %edx,%ecx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8090d4:	83 c2 01             	add    $0x1,%edx
  8090d7:	80 fa 09             	cmp    $0x9,%dl
  8090da:	0f 86 02 01 00 00    	jbe    8091e2 <find_entry+0x16e>
  8090e0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8090e3:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8090e5:	80 f9 0a             	cmp    $0xa,%cl
  8090e8:	0f 84 69 01 00 00    	je     809257 <find_entry+0x1e3>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8090ee:	f6 c2 02             	test   $0x2,%dl
  8090f1:	0f 85 ff 01 00 00    	jne    8092f6 <find_entry+0x282>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8090f7:	89 ce                	mov    %ecx,%esi
  if (empty < ARP_TABLE_SIZE) {
  8090f9:	80 f9 09             	cmp    $0x9,%cl
  8090fc:	0f 8f 67 01 00 00    	jg     809269 <find_entry+0x1f5>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809102:	89 f0                	mov    %esi,%eax
  809104:	3c 09                	cmp    $0x9,%al
  809106:	0f 87 c9 01 00 00    	ja     8092d5 <find_entry+0x261>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  80910c:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80910f:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809112:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  809119:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80911c:	85 db                	test   %ebx,%ebx
  80911e:	74 08                	je     809128 <find_entry+0xb4>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809120:	8b 0b                	mov    (%ebx),%ecx
  809122:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  809128:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80912b:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809132:	89 f0                	mov    %esi,%eax
  809134:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809139:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80913c:	5b                   	pop    %ebx
  80913d:	5e                   	pop    %esi
  80913e:	5f                   	pop    %edi
  80913f:	5d                   	pop    %ebp
  809140:	c3                   	ret    
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809141:	8b bb 24 4a b3 00    	mov    0xb34a24(%ebx),%edi
  809147:	39 38                	cmp    %edi,(%eax)
  809149:	74 22                	je     80916d <find_entry+0xf9>
  80914b:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80914f:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809153:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809157:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80915b:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  80915f:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809163:	ba 00 00 00 00       	mov    $0x0,%edx
  809168:	e9 52 ff ff ff       	jmp    8090bf <find_entry+0x4b>
        return etharp_cached_entry;
  80916d:	89 d0                	mov    %edx,%eax
  80916f:	eb c8                	jmp    809139 <find_entry+0xc5>
  809171:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809175:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809179:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80917d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809181:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809185:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809189:	ba 00 00 00 00       	mov    $0x0,%edx
  80918e:	e9 2c ff ff ff       	jmp    8090bf <find_entry+0x4b>
  809193:	b9 0a 00 00 00       	mov    $0xa,%ecx
  809198:	eb 48                	jmp    8091e2 <find_entry+0x16e>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80919a:	85 c0                	test   %eax,%eax
  80919c:	74 0d                	je     8091ab <find_entry+0x137>
  80919e:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8091a1:	8b be 24 4a b3 00    	mov    0xb34a24(%esi),%edi
  8091a7:	39 38                	cmp    %edi,(%eax)
  8091a9:	74 79                	je     809224 <find_entry+0x1b0>
      } else if (arp_table[i].q != NULL) {
  8091ab:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8091ae:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  8091b5:	74 7a                	je     809231 <find_entry+0x1bd>
        if (arp_table[i].ctime >= age_queue) {
  8091b7:	0f b6 9e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ebx
  8091be:	89 cf                	mov    %ecx,%edi
  8091c0:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  8091c3:	72 06                	jb     8091cb <find_entry+0x157>
          old_queue = i;
  8091c5:	88 55 e3             	mov    %dl,-0x1d(%ebp)
          age_queue = arp_table[i].ctime;
  8091c8:	88 5d e7             	mov    %bl,-0x19(%ebp)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8091cb:	83 c2 01             	add    $0x1,%edx
  8091ce:	80 fa 09             	cmp    $0x9,%dl
  8091d1:	0f 87 09 ff ff ff    	ja     8090e0 <find_entry+0x6c>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8091d7:	80 f9 0a             	cmp    $0xa,%cl
  8091da:	0f 84 df fe ff ff    	je     8090bf <find_entry+0x4b>
  8091e0:	89 f9                	mov    %edi,%ecx
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8091e2:	0f b6 da             	movzbl %dl,%ebx
  8091e5:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8091e8:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  8091ee:	83 fe 01             	cmp    $0x1,%esi
  8091f1:	74 a7                	je     80919a <find_entry+0x126>
  8091f3:	89 cf                	mov    %ecx,%edi
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8091f5:	83 fe 02             	cmp    $0x2,%esi
  8091f8:	75 d1                	jne    8091cb <find_entry+0x157>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8091fa:	85 c0                	test   %eax,%eax
  8091fc:	74 0d                	je     80920b <find_entry+0x197>
  8091fe:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809201:	8b be 24 4a b3 00    	mov    0xb34a24(%esi),%edi
  809207:	39 38                	cmp    %edi,(%eax)
  809209:	74 3f                	je     80924a <find_entry+0x1d6>
      } else if (arp_table[i].ctime >= age_stable) {
  80920b:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  80920e:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  809215:	89 cf                	mov    %ecx,%edi
  809217:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  80921a:	72 af                	jb     8091cb <find_entry+0x157>
        old_stable = i;
  80921c:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  80921f:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  809222:	eb a7                	jmp    8091cb <find_entry+0x157>
        etharp_cached_entry = i;
  809224:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
        return i;
  80922a:	89 d0                	mov    %edx,%eax
  80922c:	e9 08 ff ff ff       	jmp    809139 <find_entry+0xc5>
        if (arp_table[i].ctime >= age_pending) {
  809231:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809234:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  80923b:	89 cf                	mov    %ecx,%edi
  80923d:	3a 5d e4             	cmp    -0x1c(%ebp),%bl
  809240:	72 89                	jb     8091cb <find_entry+0x157>
          old_pending = i;
  809242:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  809245:	88 5d e4             	mov    %bl,-0x1c(%ebp)
  809248:	eb 81                	jmp    8091cb <find_entry+0x157>
        etharp_cached_entry = i;
  80924a:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
        return i;
  809250:	89 d0                	mov    %edx,%eax
  809252:	e9 e2 fe ff ff       	jmp    809139 <find_entry+0xc5>
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809257:	f6 c2 01             	test   $0x1,%dl
  80925a:	0f 84 8c 00 00 00    	je     8092ec <find_entry+0x278>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809260:	f6 c2 02             	test   $0x2,%dl
  809263:	0f 85 a1 00 00 00    	jne    80930a <find_entry+0x296>
  else if (old_stable < ARP_TABLE_SIZE) {
  809269:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  80926d:	3c 09                	cmp    $0x9,%al
  80926f:	7f 2c                	jg     80929d <find_entry+0x229>
    i = old_stable;
  809271:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809273:	0f b6 c0             	movzbl %al,%eax
  809276:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809279:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  809280:	0f 84 7c fe ff ff    	je     809102 <find_entry+0x8e>
  809286:	83 ec 04             	sub    $0x4,%esp
  809289:	68 ec 22 81 00       	push   $0x8122ec
  80928e:	68 75 01 00 00       	push   $0x175
  809293:	68 ba 22 81 00       	push   $0x8122ba
  809298:	e8 d3 52 00 00       	call   80e570 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  80929d:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    i = old_pending;
  8092a1:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  8092a3:	3c 09                	cmp    $0x9,%al
  8092a5:	0f 8e 57 fe ff ff    	jle    809102 <find_entry+0x8e>
  } else if (old_queue < ARP_TABLE_SIZE) {
  8092ab:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  8092af:	3c 09                	cmp    $0x9,%al
  8092b1:	7f 4d                	jg     809300 <find_entry+0x28c>
    i = old_queue;
  8092b3:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  8092b5:	0f b6 f8             	movzbl %al,%edi
  8092b8:	6b ff 1c             	imul   $0x1c,%edi,%edi
  8092bb:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  8092c1:	e8 2b fd ff ff       	call   808ff1 <free_etharp_q>
    arp_table[i].q = NULL;
  8092c6:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  8092cd:	00 00 00 
  8092d0:	e9 2d fe ff ff       	jmp    809102 <find_entry+0x8e>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8092d5:	83 ec 04             	sub    $0x4,%esp
  8092d8:	68 03 23 81 00       	push   $0x812303
  8092dd:	68 8b 01 00 00       	push   $0x18b
  8092e2:	68 ba 22 81 00       	push   $0x8122ba
  8092e7:	e8 84 52 00 00       	call   80e570 <_panic>
    return (s8_t)ERR_MEM;
  8092ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8092f1:	e9 43 fe ff ff       	jmp    809139 <find_entry+0xc5>
  8092f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8092fb:	e9 39 fe ff ff       	jmp    809139 <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  809300:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809305:	e9 2f fe ff ff       	jmp    809139 <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  80930a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80930f:	e9 25 fe ff ff       	jmp    809139 <find_entry+0xc5>

00809314 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809314:	55                   	push   %ebp
  809315:	89 e5                	mov    %esp,%ebp
  809317:	57                   	push   %edi
  809318:	56                   	push   %esi
  809319:	53                   	push   %ebx
  80931a:	83 ec 1c             	sub    $0x1c,%esp
  80931d:	89 d7                	mov    %edx,%edi
  80931f:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  809322:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809325:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809329:	75 45                	jne    809370 <etharp_send_ip+0x5c>
  80932b:	89 c6                	mov    %eax,%esi
  80932d:	b8 05 00 00 00       	mov    $0x5,%eax
  809332:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  809335:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  809339:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80933c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80933f:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809343:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  809347:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  80934a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80934d:	75 e6                	jne    809335 <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80934f:	83 ec 0c             	sub    $0xc,%esp
  809352:	68 00 08 00 00       	push   $0x800
  809357:	e8 69 e3 ff ff       	call   8076c5 <htons>
  80935c:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809360:	83 c4 08             	add    $0x8,%esp
  809363:	57                   	push   %edi
  809364:	56                   	push   %esi
  809365:	ff 56 18             	call   *0x18(%esi)
}
  809368:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80936b:	5b                   	pop    %ebx
  80936c:	5e                   	pop    %esi
  80936d:	5f                   	pop    %edi
  80936e:	5d                   	pop    %ebp
  80936f:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809370:	83 ec 04             	sub    $0x4,%esp
  809373:	68 30 23 81 00       	push   $0x812330
  809378:	68 b3 01 00 00       	push   $0x1b3
  80937d:	68 ba 22 81 00       	push   $0x8122ba
  809382:	e8 e9 51 00 00       	call   80e570 <_panic>

00809387 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809387:	55                   	push   %ebp
  809388:	89 e5                	mov    %esp,%ebp
  80938a:	57                   	push   %edi
  80938b:	56                   	push   %esi
  80938c:	53                   	push   %ebx
  80938d:	83 ec 1c             	sub    $0x1c,%esp
  809390:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809393:	89 cb                	mov    %ecx,%ebx
  809395:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809398:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80939b:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80939f:	0f 85 e9 00 00 00    	jne    80948e <update_arp_entry+0x107>
  8093a5:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  8093a7:	85 d2                	test   %edx,%edx
  8093a9:	0f 84 f6 00 00 00    	je     8094a5 <update_arp_entry+0x11e>
  8093af:	83 3a 00             	cmpl   $0x0,(%edx)
  8093b2:	0f 84 f4 00 00 00    	je     8094ac <update_arp_entry+0x125>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8093b8:	83 ec 08             	sub    $0x8,%esp
  8093bb:	ff 75 e4             	pushl  -0x1c(%ebp)
  8093be:	52                   	push   %edx
  8093bf:	e8 9d d0 ff ff       	call   806461 <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  8093c4:	83 c4 10             	add    $0x10,%esp
  8093c7:	84 c0                	test   %al,%al
  8093c9:	0f 85 ea 00 00 00    	jne    8094b9 <update_arp_entry+0x132>
      ip_addr_ismulticast(ipaddr)) {
  8093cf:	8b 3e                	mov    (%esi),%edi
  8093d1:	83 ec 0c             	sub    $0xc,%esp
  8093d4:	68 00 00 00 f0       	push   $0xf0000000
  8093d9:	e8 18 e5 ff ff       	call   8078f6 <ntohl>
  8093de:	21 c7                	and    %eax,%edi
  8093e0:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8093e7:	e8 0a e5 ff ff       	call   8078f6 <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8093ec:	83 c4 10             	add    $0x10,%esp
  8093ef:	39 c7                	cmp    %eax,%edi
  8093f1:	0f 84 c9 00 00 00    	je     8094c0 <update_arp_entry+0x139>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8093f7:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  8093fb:	89 f0                	mov    %esi,%eax
  8093fd:	e8 72 fc ff ff       	call   809074 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809402:	84 c0                	test   %al,%al
  809404:	0f 88 a7 00 00 00    	js     8094b1 <update_arp_entry+0x12a>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80940a:	0f be c0             	movsbl %al,%eax
  80940d:	6b f0 1c             	imul   $0x1c,%eax,%esi
  809410:	c7 86 30 4a b3 00 02 	movl   $0x2,0xb34a30(%esi)
  809417:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80941a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80941d:	89 8e 38 4a b3 00    	mov    %ecx,0xb34a38(%esi)
  809423:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809428:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  80942d:	88 8c 16 2d 4a b3 00 	mov    %cl,0xb34a2d(%esi,%edx,1)
  809434:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  809437:	83 fa fa             	cmp    $0xfffffffa,%edx
  80943a:	75 ec                	jne    809428 <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80943c:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80943f:	c6 82 34 4a b3 00 00 	movb   $0x0,0xb34a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809446:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809448:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80944b:	83 c0 25             	add    $0x25,%eax
  80944e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  809451:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  809457:	85 c0                	test   %eax,%eax
  809459:	74 56                	je     8094b1 <update_arp_entry+0x12a>
    arp_table[i].q = q->next;
  80945b:	8b 10                	mov    (%eax),%edx
  80945d:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    p = q->p;
  809463:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  809466:	83 ec 08             	sub    $0x8,%esp
  809469:	50                   	push   %eax
  80946a:	6a 0a                	push   $0xa
  80946c:	e8 22 b0 ff ff       	call   804493 <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809471:	89 1c 24             	mov    %ebx,(%esp)
  809474:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809477:	89 fa                	mov    %edi,%edx
  809479:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80947c:	e8 93 fe ff ff       	call   809314 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809481:	89 3c 24             	mov    %edi,(%esp)
  809484:	e8 5a b3 ff ff       	call   8047e3 <pbuf_free>
  809489:	83 c4 10             	add    $0x10,%esp
  80948c:	eb c3                	jmp    809451 <update_arp_entry+0xca>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80948e:	83 ec 04             	sub    $0x4,%esp
  809491:	68 74 23 81 00       	push   $0x812374
  809496:	68 d9 01 00 00       	push   $0x1d9
  80949b:	68 ba 22 81 00       	push   $0x8122ba
  8094a0:	e8 cb 50 00 00       	call   80e570 <_panic>
    return ERR_ARG;
  8094a5:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8094aa:	eb 05                	jmp    8094b1 <update_arp_entry+0x12a>
  8094ac:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  }
#endif
  return ERR_OK;
}
  8094b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8094b4:	5b                   	pop    %ebx
  8094b5:	5e                   	pop    %esi
  8094b6:	5f                   	pop    %edi
  8094b7:	5d                   	pop    %ebp
  8094b8:	c3                   	ret    
    return ERR_ARG;
  8094b9:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8094be:	eb f1                	jmp    8094b1 <update_arp_entry+0x12a>
  8094c0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8094c5:	eb ea                	jmp    8094b1 <update_arp_entry+0x12a>

008094c7 <etharp_tmr>:
{
  8094c7:	55                   	push   %ebp
  8094c8:	89 e5                	mov    %esp,%ebp
  8094ca:	57                   	push   %edi
  8094cb:	56                   	push   %esi
  8094cc:	53                   	push   %ebx
  8094cd:	83 ec 0c             	sub    $0xc,%esp
  8094d0:	bb 20 4a b3 00       	mov    $0xb34a20,%ebx
  8094d5:	bf 38 4b b3 00       	mov    $0xb34b38,%edi
  8094da:	eb 1f                	jmp    8094fb <etharp_tmr+0x34>
      if (arp_table[i].q != NULL) {
  8094dc:	8b 06                	mov    (%esi),%eax
  8094de:	85 c0                	test   %eax,%eax
  8094e0:	74 0b                	je     8094ed <etharp_tmr+0x26>
        free_etharp_q(arp_table[i].q);
  8094e2:	e8 0a fb ff ff       	call   808ff1 <free_etharp_q>
        arp_table[i].q = NULL;
  8094e7:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8094ed:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8094f4:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8094f7:	39 fb                	cmp    %edi,%ebx
  8094f9:	74 23                	je     80951e <etharp_tmr+0x57>
  8094fb:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  8094fd:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  809501:	83 c0 01             	add    $0x1,%eax
  809504:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809507:	8b 53 10             	mov    0x10(%ebx),%edx
  80950a:	3c ef                	cmp    $0xef,%al
  80950c:	76 05                	jbe    809513 <etharp_tmr+0x4c>
  80950e:	83 fa 02             	cmp    $0x2,%edx
  809511:	74 c9                	je     8094dc <etharp_tmr+0x15>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809513:	3c 01                	cmp    $0x1,%al
  809515:	76 dd                	jbe    8094f4 <etharp_tmr+0x2d>
  809517:	83 fa 01             	cmp    $0x1,%edx
  80951a:	75 d8                	jne    8094f4 <etharp_tmr+0x2d>
  80951c:	eb be                	jmp    8094dc <etharp_tmr+0x15>
}
  80951e:	83 c4 0c             	add    $0xc,%esp
  809521:	5b                   	pop    %ebx
  809522:	5e                   	pop    %esi
  809523:	5f                   	pop    %edi
  809524:	5d                   	pop    %ebp
  809525:	c3                   	ret    

00809526 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809526:	55                   	push   %ebp
  809527:	89 e5                	mov    %esp,%ebp
  809529:	53                   	push   %ebx
  80952a:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80952d:	ba 02 00 00 00       	mov    $0x2,%edx
  809532:	8b 45 0c             	mov    0xc(%ebp),%eax
  809535:	e8 3a fb ff ff       	call   809074 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80953a:	84 c0                	test   %al,%al
  80953c:	78 31                	js     80956f <etharp_find_addr+0x49>
  80953e:	0f be d0             	movsbl %al,%edx
  809541:	6b d2 1c             	imul   $0x1c,%edx,%edx
  809544:	83 ba 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%edx)
  80954b:	75 29                	jne    809576 <etharp_find_addr+0x50>
  80954d:	0f be d0             	movsbl %al,%edx
  809550:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  809553:	8d 9a 28 4a b3 00    	lea    0xb34a28(%edx),%ebx
  809559:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80955c:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80955e:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  809564:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809567:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  809569:	83 c4 04             	add    $0x4,%esp
  80956c:	5b                   	pop    %ebx
  80956d:	5d                   	pop    %ebp
  80956e:	c3                   	ret    
  return -1;
  80956f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809574:	eb f3                	jmp    809569 <etharp_find_addr+0x43>
  809576:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80957b:	eb ec                	jmp    809569 <etharp_find_addr+0x43>

0080957d <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80957d:	55                   	push   %ebp
  80957e:	89 e5                	mov    %esp,%ebp
  809580:	83 ec 08             	sub    $0x8,%esp
  809583:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809586:	85 c0                	test   %eax,%eax
  809588:	74 13                	je     80959d <etharp_ip_input+0x20>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80958a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80958d:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809590:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  809593:	33 48 04             	xor    0x4(%eax),%ecx
  809596:	85 48 08             	test   %ecx,0x8(%eax)
  809599:	74 19                	je     8095b4 <etharp_ip_input+0x37>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  80959b:	c9                   	leave  
  80959c:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80959d:	83 ec 04             	sub    $0x4,%esp
  8095a0:	68 42 16 81 00       	push   $0x811642
  8095a5:	68 48 02 00 00       	push   $0x248
  8095aa:	68 ba 22 81 00       	push   $0x8122ba
  8095af:	e8 bc 4f 00 00       	call   80e570 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8095b4:	8d 4a 06             	lea    0x6(%edx),%ecx
  8095b7:	83 c2 1c             	add    $0x1c,%edx
  8095ba:	83 ec 0c             	sub    $0xc,%esp
  8095bd:	6a 00                	push   $0x0
  8095bf:	e8 c3 fd ff ff       	call   809387 <update_arp_entry>
  8095c4:	83 c4 10             	add    $0x10,%esp
  8095c7:	eb d2                	jmp    80959b <etharp_ip_input+0x1e>

008095c9 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8095c9:	55                   	push   %ebp
  8095ca:	89 e5                	mov    %esp,%ebp
  8095cc:	57                   	push   %edi
  8095cd:	56                   	push   %esi
  8095ce:	53                   	push   %ebx
  8095cf:	83 ec 1c             	sub    $0x1c,%esp
  8095d2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8095d5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8095d9:	74 4d                	je     809628 <etharp_arp_input+0x5f>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8095db:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8095e0:	76 5d                	jbe    80963f <etharp_arp_input+0x76>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  8095e2:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8095e5:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8095e9:	83 ec 0c             	sub    $0xc,%esp
  8095ec:	6a 01                	push   $0x1
  8095ee:	e8 d2 e0 ff ff       	call   8076c5 <htons>
  8095f3:	83 c4 10             	add    $0x10,%esp
  8095f6:	66 39 c7             	cmp    %ax,%di
  8095f9:	75 19                	jne    809614 <etharp_arp_input+0x4b>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8095fb:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  8095ff:	83 ec 0c             	sub    $0xc,%esp
  809602:	68 04 06 00 00       	push   $0x604
  809607:	e8 b9 e0 ff ff       	call   8076c5 <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80960c:	83 c4 10             	add    $0x10,%esp
  80960f:	66 39 c7             	cmp    %ax,%di
  809612:	74 39                	je     80964d <etharp_arp_input+0x84>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809614:	83 ec 0c             	sub    $0xc,%esp
  809617:	53                   	push   %ebx
  809618:	e8 c6 b1 ff ff       	call   8047e3 <pbuf_free>
    return;
  80961d:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  809620:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809623:	5b                   	pop    %ebx
  809624:	5e                   	pop    %esi
  809625:	5f                   	pop    %edi
  809626:	5d                   	pop    %ebp
  809627:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809628:	83 ec 04             	sub    $0x4,%esp
  80962b:	68 42 16 81 00       	push   $0x811642
  809630:	68 75 02 00 00       	push   $0x275
  809635:	68 ba 22 81 00       	push   $0x8122ba
  80963a:	e8 31 4f 00 00       	call   80e570 <_panic>
    pbuf_free(p);
  80963f:	83 ec 0c             	sub    $0xc,%esp
  809642:	53                   	push   %ebx
  809643:	e8 9b b1 ff ff       	call   8047e3 <pbuf_free>
    return;
  809648:	83 c4 10             	add    $0x10,%esp
  80964b:	eb d3                	jmp    809620 <etharp_arp_input+0x57>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80964d:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809651:	83 ec 0c             	sub    $0xc,%esp
  809654:	68 00 08 00 00       	push   $0x800
  809659:	e8 67 e0 ff ff       	call   8076c5 <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80965e:	83 c4 10             	add    $0x10,%esp
  809661:	66 39 c7             	cmp    %ax,%di
  809664:	75 ae                	jne    809614 <etharp_arp_input+0x4b>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809666:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80966a:	83 ec 0c             	sub    $0xc,%esp
  80966d:	68 06 08 00 00       	push   $0x806
  809672:	e8 4e e0 ff ff       	call   8076c5 <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809677:	83 c4 10             	add    $0x10,%esp
  80967a:	66 39 c7             	cmp    %ax,%di
  80967d:	75 95                	jne    809614 <etharp_arp_input+0x4b>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80967f:	83 ec 04             	sub    $0x4,%esp
  809682:	6a 04                	push   $0x4
  809684:	8d 46 1c             	lea    0x1c(%esi),%eax
  809687:	50                   	push   %eax
  809688:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80968b:	50                   	push   %eax
  80968c:	e8 86 57 00 00       	call   80ee17 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809691:	83 c4 0c             	add    $0xc,%esp
  809694:	6a 04                	push   $0x4
  809696:	8d 46 26             	lea    0x26(%esi),%eax
  809699:	50                   	push   %eax
  80969a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80969d:	50                   	push   %eax
  80969e:	e8 74 57 00 00       	call   80ee17 <memcpy>
  if (netif->ip_addr.addr == 0) {
  8096a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8096a6:	8b 40 04             	mov    0x4(%eax),%eax
  8096a9:	83 c4 10             	add    $0x10,%esp
  8096ac:	85 c0                	test   %eax,%eax
  8096ae:	74 05                	je     8096b5 <etharp_arp_input+0xec>
  if (for_us) {
  8096b0:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  8096b3:	74 39                	je     8096ee <etharp_arp_input+0x125>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  8096b5:	8d 4e 16             	lea    0x16(%esi),%ecx
  8096b8:	83 ec 0c             	sub    $0xc,%esp
  8096bb:	6a 00                	push   $0x0
  8096bd:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8096c0:	8b 45 08             	mov    0x8(%ebp),%eax
  8096c3:	e8 bf fc ff ff       	call   809387 <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8096c8:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8096cc:	89 04 24             	mov    %eax,(%esp)
  8096cf:	e8 f1 df ff ff       	call   8076c5 <htons>
  8096d4:	83 c4 10             	add    $0x10,%esp
  8096d7:	66 83 f8 02          	cmp    $0x2,%ax
  8096db:	74 3f                	je     80971c <etharp_arp_input+0x153>
  pbuf_free(p);
  8096dd:	83 ec 0c             	sub    $0xc,%esp
  8096e0:	53                   	push   %ebx
  8096e1:	e8 fd b0 ff ff       	call   8047e3 <pbuf_free>
  8096e6:	83 c4 10             	add    $0x10,%esp
  8096e9:	e9 32 ff ff ff       	jmp    809620 <etharp_arp_input+0x57>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8096ee:	8d 4e 16             	lea    0x16(%esi),%ecx
  8096f1:	83 ec 0c             	sub    $0xc,%esp
  8096f4:	6a 01                	push   $0x1
  8096f6:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8096f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8096fc:	e8 86 fc ff ff       	call   809387 <update_arp_entry>
  switch (htons(hdr->opcode)) {
  809701:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809705:	89 04 24             	mov    %eax,(%esp)
  809708:	e8 b8 df ff ff       	call   8076c5 <htons>
  80970d:	83 c4 10             	add    $0x10,%esp
  809710:	66 83 f8 01          	cmp    $0x1,%ax
  809714:	74 1a                	je     809730 <etharp_arp_input+0x167>
  809716:	66 83 f8 02          	cmp    $0x2,%ax
  80971a:	75 c1                	jne    8096dd <etharp_arp_input+0x114>
    dhcp_arp_reply(netif, &sipaddr);
  80971c:	83 ec 08             	sub    $0x8,%esp
  80971f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809722:	50                   	push   %eax
  809723:	ff 75 08             	pushl  0x8(%ebp)
  809726:	e8 62 a1 ff ff       	call   80388d <dhcp_arp_reply>
    break;
  80972b:	83 c4 10             	add    $0x10,%esp
  80972e:	eb ad                	jmp    8096dd <etharp_arp_input+0x114>
      hdr->opcode = htons(ARP_REPLY);
  809730:	83 ec 0c             	sub    $0xc,%esp
  809733:	6a 02                	push   $0x2
  809735:	e8 8b df ff ff       	call   8076c5 <htons>
  80973a:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  80973e:	8b 46 1c             	mov    0x1c(%esi),%eax
  809741:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809744:	8b 45 08             	mov    0x8(%ebp),%eax
  809747:	8b 40 04             	mov    0x4(%eax),%eax
  80974a:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80974d:	83 c4 10             	add    $0x10,%esp
  809750:	8b 45 08             	mov    0x8(%ebp),%eax
  809753:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809757:	75 0b                	jne    809764 <etharp_arp_input+0x19b>
  809759:	8d 46 05             	lea    0x5(%esi),%eax
  80975c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80975f:	83 c2 05             	add    $0x5,%edx
  809762:	eb 19                	jmp    80977d <etharp_arp_input+0x1b4>
  809764:	83 ec 04             	sub    $0x4,%esp
  809767:	68 30 23 81 00       	push   $0x812330
  80976c:	68 c7 02 00 00       	push   $0x2c7
  809771:	68 ba 22 81 00       	push   $0x8122ba
  809776:	e8 f5 4d 00 00       	call   80e570 <_panic>
  80977b:	89 c8                	mov    %ecx,%eax
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80977d:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  809781:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809784:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809786:	0f b6 0a             	movzbl (%edx),%ecx
  809789:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80978c:	88 48 06             	mov    %cl,0x6(%eax)
  80978f:	8d 48 ff             	lea    -0x1(%eax),%ecx
  809792:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  809795:	39 f0                	cmp    %esi,%eax
  809797:	75 e2                	jne    80977b <etharp_arp_input+0x1b2>
      netif->linkoutput(netif, p);
  809799:	83 ec 08             	sub    $0x8,%esp
  80979c:	53                   	push   %ebx
  80979d:	ff 75 08             	pushl  0x8(%ebp)
  8097a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8097a3:	ff 50 18             	call   *0x18(%eax)
  8097a6:	83 c4 10             	add    $0x10,%esp
  8097a9:	e9 2f ff ff ff       	jmp    8096dd <etharp_arp_input+0x114>

008097ae <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8097ae:	55                   	push   %ebp
  8097af:	89 e5                	mov    %esp,%ebp
  8097b1:	57                   	push   %edi
  8097b2:	56                   	push   %esi
  8097b3:	53                   	push   %ebx
  8097b4:	83 ec 10             	sub    $0x10,%esp
  8097b7:	8b 75 08             	mov    0x8(%ebp),%esi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  8097ba:	6a 00                	push   $0x0
  8097bc:	6a 2a                	push   $0x2a
  8097be:	6a 02                	push   $0x2
  8097c0:	e8 e4 b0 ff ff       	call   8048a9 <pbuf_alloc>
  if (p == NULL) {
  8097c5:	83 c4 10             	add    $0x10,%esp
  8097c8:	85 c0                	test   %eax,%eax
  8097ca:	0f 84 f8 00 00 00    	je     8098c8 <etharp_request+0x11a>
  8097d0:	89 c7                	mov    %eax,%edi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8097d2:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  8097d7:	0f 86 bd 00 00 00    	jbe    80989a <etharp_request+0xec>
  hdr = p->payload;
  8097dd:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  8097e0:	83 ec 0c             	sub    $0xc,%esp
  8097e3:	6a 01                	push   $0x1
  8097e5:	e8 db de ff ff       	call   8076c5 <htons>
  8097ea:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8097ee:	83 c4 10             	add    $0x10,%esp
  8097f1:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  8097f5:	0f 85 b6 00 00 00    	jne    8098b1 <etharp_request+0x103>
  8097fb:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  809800:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  809805:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809809:	0f b6 90 1c 24 81 00 	movzbl 0x81241c(%eax),%edx
  809810:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809814:	0f b6 90 24 24 81 00 	movzbl 0x812424(%eax),%edx
  80981b:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80981e:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  809823:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  809827:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  80982a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80982d:	75 d1                	jne    809800 <etharp_request+0x52>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80982f:	8b 46 04             	mov    0x4(%esi),%eax
  809832:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809835:	8b 45 0c             	mov    0xc(%ebp),%eax
  809838:	8b 00                	mov    (%eax),%eax
  80983a:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80983d:	83 ec 0c             	sub    $0xc,%esp
  809840:	6a 01                	push   $0x1
  809842:	e8 7e de ff ff       	call   8076c5 <htons>
  809847:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80984b:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809852:	e8 6e de ff ff       	call   8076c5 <htons>
  809857:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80985b:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809862:	e8 5e de ff ff       	call   8076c5 <htons>
  809867:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80986b:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809872:	e8 4e de ff ff       	call   8076c5 <htons>
  809877:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  80987b:	83 c4 08             	add    $0x8,%esp
  80987e:	57                   	push   %edi
  80987f:	56                   	push   %esi
  809880:	ff 56 18             	call   *0x18(%esi)
  809883:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  809885:	89 3c 24             	mov    %edi,(%esp)
  809888:	e8 56 af ff ff       	call   8047e3 <pbuf_free>
  80988d:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809890:	89 d8                	mov    %ebx,%eax
  809892:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809895:	5b                   	pop    %ebx
  809896:	5e                   	pop    %esi
  809897:	5f                   	pop    %edi
  809898:	5d                   	pop    %ebp
  809899:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80989a:	83 ec 04             	sub    $0x4,%esp
  80989d:	68 9c 23 81 00       	push   $0x81239c
  8098a2:	68 1c 04 00 00       	push   $0x41c
  8098a7:	68 ba 22 81 00       	push   $0x8122ba
  8098ac:	e8 bf 4c 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8098b1:	83 ec 04             	sub    $0x4,%esp
  8098b4:	68 30 23 81 00       	push   $0x812330
  8098b9:	68 23 04 00 00       	push   $0x423
  8098be:	68 ba 22 81 00       	push   $0x8122ba
  8098c3:	e8 a8 4c 00 00       	call   80e570 <_panic>
    return ERR_MEM;
  8098c8:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  8098cd:	eb c1                	jmp    809890 <etharp_request+0xe2>

008098cf <etharp_query>:
{
  8098cf:	55                   	push   %ebp
  8098d0:	89 e5                	mov    %esp,%ebp
  8098d2:	57                   	push   %edi
  8098d3:	56                   	push   %esi
  8098d4:	53                   	push   %ebx
  8098d5:	83 ec 14             	sub    $0x14,%esp
  8098d8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8098db:	ff 75 08             	pushl  0x8(%ebp)
  8098de:	53                   	push   %ebx
  8098df:	e8 7d cb ff ff       	call   806461 <ip_addr_isbroadcast>
  8098e4:	83 c4 10             	add    $0x10,%esp
  8098e7:	84 c0                	test   %al,%al
  8098e9:	0f 85 a2 01 00 00    	jne    809a91 <etharp_query+0x1c2>
      ip_addr_ismulticast(ipaddr) ||
  8098ef:	8b 33                	mov    (%ebx),%esi
  8098f1:	83 ec 0c             	sub    $0xc,%esp
  8098f4:	68 00 00 00 f0       	push   $0xf0000000
  8098f9:	e8 f8 df ff ff       	call   8078f6 <ntohl>
  8098fe:	21 c6                	and    %eax,%esi
  809900:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809907:	e8 ea df ff ff       	call   8078f6 <ntohl>
  80990c:	83 c4 10             	add    $0x10,%esp
  80990f:	39 c6                	cmp    %eax,%esi
  809911:	0f 84 84 01 00 00    	je     809a9b <etharp_query+0x1cc>
      ip_addr_isany(ipaddr)) {
  809917:	83 3b 00             	cmpl   $0x0,(%ebx)
  80991a:	0f 84 85 01 00 00    	je     809aa5 <etharp_query+0x1d6>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809920:	ba 01 00 00 00       	mov    $0x1,%edx
  809925:	89 d8                	mov    %ebx,%eax
  809927:	e8 48 f7 ff ff       	call   809074 <find_entry>
  80992c:	89 c6                	mov    %eax,%esi
  if (i < 0) {
  80992e:	84 c0                	test   %al,%al
  809930:	0f 88 79 01 00 00    	js     809aaf <etharp_query+0x1e0>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809936:	0f be f8             	movsbl %al,%edi
  809939:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80993c:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809942:	85 c0                	test   %eax,%eax
  809944:	75 26                	jne    80996c <etharp_query+0x9d>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809946:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809949:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  809950:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809953:	83 ec 08             	sub    $0x8,%esp
  809956:	53                   	push   %ebx
  809957:	ff 75 08             	pushl  0x8(%ebp)
  80995a:	e8 4f fe ff ff       	call   8097ae <etharp_request>
  80995f:	89 c3                	mov    %eax,%ebx
  if (q != NULL) {
  809961:	83 c4 10             	add    $0x10,%esp
  809964:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809968:	74 2d                	je     809997 <etharp_query+0xc8>
  80996a:	eb 18                	jmp    809984 <etharp_query+0xb5>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80996c:	8d 50 ff             	lea    -0x1(%eax),%edx
  80996f:	83 fa 01             	cmp    $0x1,%edx
  809972:	77 2d                	ja     8099a1 <etharp_query+0xd2>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809974:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809978:	74 d9                	je     809953 <etharp_query+0x84>
  80997a:	83 f8 01             	cmp    $0x1,%eax
  80997d:	74 d4                	je     809953 <etharp_query+0x84>
  err_t result = ERR_MEM;
  80997f:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809984:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809987:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  80998d:	83 f8 02             	cmp    $0x2,%eax
  809990:	74 26                	je     8099b8 <etharp_query+0xe9>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809992:	83 f8 01             	cmp    $0x1,%eax
  809995:	74 4a                	je     8099e1 <etharp_query+0x112>
}
  809997:	89 d8                	mov    %ebx,%eax
  809999:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80999c:	5b                   	pop    %ebx
  80999d:	5e                   	pop    %esi
  80999e:	5f                   	pop    %edi
  80999f:	5d                   	pop    %ebp
  8099a0:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  8099a1:	83 ec 04             	sub    $0x4,%esp
  8099a4:	68 d0 23 81 00       	push   $0x8123d0
  8099a9:	68 92 03 00 00       	push   $0x392
  8099ae:	68 ba 22 81 00       	push   $0x8122ba
  8099b3:	e8 b8 4b 00 00       	call   80e570 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  8099b8:	8b 45 08             	mov    0x8(%ebp),%eax
  8099bb:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  8099be:	83 ec 0c             	sub    $0xc,%esp
  8099c1:	89 f0                	mov    %esi,%eax
  8099c3:	0f be c0             	movsbl %al,%eax
  8099c6:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8099c9:	05 28 4a b3 00       	add    $0xb34a28,%eax
  8099ce:	50                   	push   %eax
  8099cf:	8b 55 10             	mov    0x10(%ebp),%edx
  8099d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8099d5:	e8 3a f9 ff ff       	call   809314 <etharp_send_ip>
  8099da:	89 c3                	mov    %eax,%ebx
  8099dc:	83 c4 10             	add    $0x10,%esp
  8099df:	eb b6                	jmp    809997 <etharp_query+0xc8>
      p = q;
  8099e1:	8b 45 10             	mov    0x10(%ebp),%eax
  8099e4:	eb 27                	jmp    809a0d <etharp_query+0x13e>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  8099e6:	83 ec 04             	sub    $0x4,%esp
  8099e9:	68 16 23 81 00       	push   $0x812316
  8099ee:	68 b1 03 00 00       	push   $0x3b1
  8099f3:	68 ba 22 81 00       	push   $0x8122ba
  8099f8:	e8 73 4b 00 00       	call   80e570 <_panic>
        if(p->type != PBUF_ROM) {
  8099fd:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809a01:	75 23                	jne    809a26 <etharp_query+0x157>
        p = p->next;
  809a03:	8b 00                	mov    (%eax),%eax
      while (p) {
  809a05:	85 c0                	test   %eax,%eax
  809a07:	0f 84 a9 00 00 00    	je     809ab6 <etharp_query+0x1e7>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809a0d:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809a11:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809a15:	75 e6                	jne    8099fd <etharp_query+0x12e>
  809a17:	83 38 00             	cmpl   $0x0,(%eax)
  809a1a:	75 ca                	jne    8099e6 <etharp_query+0x117>
        if(p->type != PBUF_ROM) {
  809a1c:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809a20:	0f 84 90 00 00 00    	je     809ab6 <etharp_query+0x1e7>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809a26:	83 ec 04             	sub    $0x4,%esp
  809a29:	6a 00                	push   $0x0
  809a2b:	0f b7 d2             	movzwl %dx,%edx
  809a2e:	52                   	push   %edx
  809a2f:	6a 03                	push   $0x3
  809a31:	e8 73 ae ff ff       	call   8048a9 <pbuf_alloc>
  809a36:	89 c6                	mov    %eax,%esi
        if(p != NULL) {
  809a38:	83 c4 10             	add    $0x10,%esp
  809a3b:	85 c0                	test   %eax,%eax
  809a3d:	0f 84 54 ff ff ff    	je     809997 <etharp_query+0xc8>
          if (pbuf_copy(p, q) != ERR_OK) {
  809a43:	83 ec 08             	sub    $0x8,%esp
  809a46:	ff 75 10             	pushl  0x10(%ebp)
  809a49:	56                   	push   %esi
  809a4a:	e8 3c b3 ff ff       	call   804d8b <pbuf_copy>
  809a4f:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809a52:	89 75 10             	mov    %esi,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809a55:	84 c0                	test   %al,%al
  809a57:	74 6b                	je     809ac4 <etharp_query+0x1f5>
            pbuf_free(p);
  809a59:	83 ec 0c             	sub    $0xc,%esp
  809a5c:	56                   	push   %esi
  809a5d:	e8 81 ad ff ff       	call   8047e3 <pbuf_free>
  809a62:	83 c4 10             	add    $0x10,%esp
  809a65:	e9 2d ff ff ff       	jmp    809997 <etharp_query+0xc8>
              r = r->next;
  809a6a:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809a6c:	8b 11                	mov    (%ecx),%edx
  809a6e:	85 d2                	test   %edx,%edx
  809a70:	75 f8                	jne    809a6a <etharp_query+0x19b>
            r->next = new_entry;
  809a72:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809a74:	bb 00 00 00 00       	mov    $0x0,%ebx
  809a79:	e9 19 ff ff ff       	jmp    809997 <etharp_query+0xc8>
          pbuf_free(p);
  809a7e:	83 ec 0c             	sub    $0xc,%esp
  809a81:	ff 75 10             	pushl  0x10(%ebp)
  809a84:	e8 5a ad ff ff       	call   8047e3 <pbuf_free>
  809a89:	83 c4 10             	add    $0x10,%esp
  809a8c:	e9 06 ff ff ff       	jmp    809997 <etharp_query+0xc8>
    return ERR_ARG;
  809a91:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809a96:	e9 fc fe ff ff       	jmp    809997 <etharp_query+0xc8>
  809a9b:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809aa0:	e9 f2 fe ff ff       	jmp    809997 <etharp_query+0xc8>
  809aa5:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809aaa:	e9 e8 fe ff ff       	jmp    809997 <etharp_query+0xc8>
    return (err_t)i;
  809aaf:	89 c3                	mov    %eax,%ebx
  809ab1:	e9 e1 fe ff ff       	jmp    809997 <etharp_query+0xc8>
        pbuf_ref(p);
  809ab6:	83 ec 0c             	sub    $0xc,%esp
  809ab9:	ff 75 10             	pushl  0x10(%ebp)
  809abc:	e8 84 b1 ff ff       	call   804c45 <pbuf_ref>
  809ac1:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809ac4:	83 ec 0c             	sub    $0xc,%esp
  809ac7:	6a 0a                	push   $0xa
  809ac9:	e8 6f a9 ff ff       	call   80443d <memp_malloc>
        if (new_entry != NULL) {
  809ace:	83 c4 10             	add    $0x10,%esp
  809ad1:	85 c0                	test   %eax,%eax
  809ad3:	74 a9                	je     809a7e <etharp_query+0x1af>
          new_entry->next = 0;
  809ad5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809adb:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809ade:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809ae1:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809ae4:	8b 8a 20 4a b3 00    	mov    0xb34a20(%edx),%ecx
  809aea:	85 c9                	test   %ecx,%ecx
  809aec:	0f 85 7a ff ff ff    	jne    809a6c <etharp_query+0x19d>
            arp_table[i].q = new_entry;
  809af2:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809af5:	89 87 20 4a b3 00    	mov    %eax,0xb34a20(%edi)
          result = ERR_OK;
  809afb:	bb 00 00 00 00       	mov    $0x0,%ebx
  809b00:	e9 92 fe ff ff       	jmp    809997 <etharp_query+0xc8>

00809b05 <etharp_output>:
{
  809b05:	55                   	push   %ebp
  809b06:	89 e5                	mov    %esp,%ebp
  809b08:	57                   	push   %edi
  809b09:	56                   	push   %esi
  809b0a:	53                   	push   %ebx
  809b0b:	83 ec 24             	sub    $0x24,%esp
  809b0e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809b11:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809b14:	6a 0e                	push   $0xe
  809b16:	ff 75 0c             	pushl  0xc(%ebp)
  809b19:	e8 f8 ab ff ff       	call   804716 <pbuf_header>
  809b1e:	83 c4 10             	add    $0x10,%esp
  809b21:	84 c0                	test   %al,%al
  809b23:	0f 85 c0 00 00 00    	jne    809be9 <etharp_output+0xe4>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809b29:	83 ec 08             	sub    $0x8,%esp
  809b2c:	53                   	push   %ebx
  809b2d:	56                   	push   %esi
  809b2e:	e8 2e c9 ff ff       	call   806461 <ip_addr_isbroadcast>
  809b33:	83 c4 10             	add    $0x10,%esp
  809b36:	84 c0                	test   %al,%al
  809b38:	0f 85 8a 00 00 00    	jne    809bc8 <etharp_output+0xc3>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809b3e:	8b 3e                	mov    (%esi),%edi
  809b40:	83 ec 0c             	sub    $0xc,%esp
  809b43:	68 00 00 00 f0       	push   $0xf0000000
  809b48:	e8 a9 dd ff ff       	call   8078f6 <ntohl>
  809b4d:	21 c7                	and    %eax,%edi
  809b4f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809b56:	e8 9b dd ff ff       	call   8078f6 <ntohl>
  809b5b:	83 c4 10             	add    $0x10,%esp
  809b5e:	39 c7                	cmp    %eax,%edi
  809b60:	74 25                	je     809b87 <etharp_output+0x82>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809b62:	8b 06                	mov    (%esi),%eax
  809b64:	33 43 04             	xor    0x4(%ebx),%eax
  809b67:	85 43 08             	test   %eax,0x8(%ebx)
  809b6a:	74 09                	je     809b75 <etharp_output+0x70>
      if (netif->gw.addr != 0) {
  809b6c:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809b70:	74 7e                	je     809bf0 <etharp_output+0xeb>
        ipaddr = &(netif->gw);
  809b72:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809b75:	83 ec 04             	sub    $0x4,%esp
  809b78:	ff 75 0c             	pushl  0xc(%ebp)
  809b7b:	56                   	push   %esi
  809b7c:	53                   	push   %ebx
  809b7d:	e8 4d fd ff ff       	call   8098cf <etharp_query>
  809b82:	83 c4 10             	add    $0x10,%esp
  809b85:	eb 5a                	jmp    809be1 <etharp_output+0xdc>
    mcastaddr.addr[0] = 0x01;
  809b87:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809b8b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809b8f:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809b93:	83 ec 0c             	sub    $0xc,%esp
  809b96:	ff 36                	pushl  (%esi)
  809b98:	e8 59 dd ff ff       	call   8078f6 <ntohl>
  809b9d:	c1 e8 10             	shr    $0x10,%eax
  809ba0:	83 e0 7f             	and    $0x7f,%eax
  809ba3:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809ba6:	83 c4 04             	add    $0x4,%esp
  809ba9:	ff 36                	pushl  (%esi)
  809bab:	e8 46 dd ff ff       	call   8078f6 <ntohl>
  809bb0:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809bb3:	83 c4 04             	add    $0x4,%esp
  809bb6:	ff 36                	pushl  (%esi)
  809bb8:	e8 39 dd ff ff       	call   8078f6 <ntohl>
  809bbd:	88 45 e7             	mov    %al,-0x19(%ebp)
  809bc0:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809bc3:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809bc6:	eb 05                	jmp    809bcd <etharp_output+0xc8>
    dest = (struct eth_addr *)&ethbroadcast;
  809bc8:	b8 24 24 81 00       	mov    $0x812424,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809bcd:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809bd0:	83 ec 0c             	sub    $0xc,%esp
  809bd3:	50                   	push   %eax
  809bd4:	8b 55 0c             	mov    0xc(%ebp),%edx
  809bd7:	89 d8                	mov    %ebx,%eax
  809bd9:	e8 36 f7 ff ff       	call   809314 <etharp_send_ip>
  809bde:	83 c4 10             	add    $0x10,%esp
}
  809be1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809be4:	5b                   	pop    %ebx
  809be5:	5e                   	pop    %esi
  809be6:	5f                   	pop    %edi
  809be7:	5d                   	pop    %ebp
  809be8:	c3                   	ret    
    return ERR_BUF;
  809be9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809bee:	eb f1                	jmp    809be1 <etharp_output+0xdc>
        return ERR_RTE;
  809bf0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809bf5:	eb ea                	jmp    809be1 <etharp_output+0xdc>

00809bf7 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809bf7:	55                   	push   %ebp
  809bf8:	89 e5                	mov    %esp,%ebp
  809bfa:	56                   	push   %esi
  809bfb:	53                   	push   %ebx
  809bfc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809bff:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809c02:	83 ec 0c             	sub    $0xc,%esp
  809c05:	8b 43 04             	mov    0x4(%ebx),%eax
  809c08:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809c0c:	50                   	push   %eax
  809c0d:	e8 b3 da ff ff       	call   8076c5 <htons>
  809c12:	83 c4 10             	add    $0x10,%esp
  809c15:	66 3d 00 08          	cmp    $0x800,%ax
  809c19:	74 14                	je     809c2f <ethernet_input+0x38>
  809c1b:	66 3d 06 08          	cmp    $0x806,%ax
  809c1f:	74 50                	je     809c71 <ethernet_input+0x7a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809c21:	83 ec 0c             	sub    $0xc,%esp
  809c24:	53                   	push   %ebx
  809c25:	e8 b9 ab ff ff       	call   8047e3 <pbuf_free>
      p = NULL;
      break;
  809c2a:	83 c4 10             	add    $0x10,%esp
  809c2d:	eb 53                	jmp    809c82 <ethernet_input+0x8b>
      etharp_ip_input(netif, p);
  809c2f:	83 ec 08             	sub    $0x8,%esp
  809c32:	53                   	push   %ebx
  809c33:	56                   	push   %esi
  809c34:	e8 44 f9 ff ff       	call   80957d <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809c39:	83 c4 08             	add    $0x8,%esp
  809c3c:	6a f2                	push   $0xfffffff2
  809c3e:	53                   	push   %ebx
  809c3f:	e8 d2 aa ff ff       	call   804716 <pbuf_header>
  809c44:	83 c4 10             	add    $0x10,%esp
  809c47:	84 c0                	test   %al,%al
  809c49:	75 0f                	jne    809c5a <ethernet_input+0x63>
        ip_input(p, netif);
  809c4b:	83 ec 08             	sub    $0x8,%esp
  809c4e:	56                   	push   %esi
  809c4f:	53                   	push   %ebx
  809c50:	e8 a9 c8 ff ff       	call   8064fe <ip_input>
      break;
  809c55:	83 c4 10             	add    $0x10,%esp
  809c58:	eb 28                	jmp    809c82 <ethernet_input+0x8b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809c5a:	83 ec 04             	sub    $0x4,%esp
  809c5d:	68 f8 23 81 00       	push   $0x8123f8
  809c62:	68 7e 04 00 00       	push   $0x47e
  809c67:	68 ba 22 81 00       	push   $0x8122ba
  809c6c:	e8 ff 48 00 00       	call   80e570 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809c71:	83 ec 04             	sub    $0x4,%esp
  809c74:	53                   	push   %ebx
  809c75:	8d 46 25             	lea    0x25(%esi),%eax
  809c78:	50                   	push   %eax
  809c79:	56                   	push   %esi
  809c7a:	e8 4a f9 ff ff       	call   8095c9 <etharp_arp_input>
      break;
  809c7f:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809c82:	b8 00 00 00 00       	mov    $0x0,%eax
  809c87:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809c8a:	5b                   	pop    %ebx
  809c8b:	5e                   	pop    %esi
  809c8c:	5d                   	pop    %ebp
  809c8d:	c3                   	ret    

00809c8e <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809c8e:	55                   	push   %ebp
  809c8f:	89 e5                	mov    %esp,%ebp
  809c91:	53                   	push   %ebx
  809c92:	83 ec 10             	sub    $0x10,%esp
  809c95:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809c98:	ff 73 04             	pushl  0x4(%ebx)
  809c9b:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809c9d:	89 1c 24             	mov    %ebx,(%esp)
  809ca0:	e8 2f 6a 00 00       	call   8106d4 <free>
}
  809ca5:	83 c4 10             	add    $0x10,%esp
  809ca8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809cab:	c9                   	leave  
  809cac:	c3                   	ret    

00809cad <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809cad:	55                   	push   %ebp
  809cae:	89 e5                	mov    %esp,%ebp
  809cb0:	83 ec 08             	sub    $0x8,%esp
  809cb3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809cb6:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809cbb:	89 c8                	mov    %ecx,%eax
  809cbd:	f7 e2                	mul    %edx
  809cbf:	c1 ea 08             	shr    $0x8,%edx
  809cc2:	89 d0                	mov    %edx,%eax
  809cc4:	c1 e0 08             	shl    $0x8,%eax
  809cc7:	01 c2                	add    %eax,%edx
  809cc9:	89 c8                	mov    %ecx,%eax
  809ccb:	29 d0                	sub    %edx,%eax
  809ccd:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809cd4:	85 c0                	test   %eax,%eax
  809cd6:	74 2a                	je     809d02 <timeout_cleanup+0x55>
	if (t->tid == tid) {
  809cd8:	39 08                	cmp    %ecx,(%eax)
  809cda:	74 05                	je     809ce1 <timeout_cleanup+0x34>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809cdc:	8b 40 08             	mov    0x8(%eax),%eax
  809cdf:	eb f3                	jmp    809cd4 <timeout_cleanup+0x27>
	    LIST_REMOVE(t, link);
  809ce1:	8b 50 08             	mov    0x8(%eax),%edx
  809ce4:	85 d2                	test   %edx,%edx
  809ce6:	74 06                	je     809cee <timeout_cleanup+0x41>
  809ce8:	8b 48 0c             	mov    0xc(%eax),%ecx
  809ceb:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809cee:	8b 50 0c             	mov    0xc(%eax),%edx
  809cf1:	8b 48 08             	mov    0x8(%eax),%ecx
  809cf4:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809cf6:	83 ec 0c             	sub    $0xc,%esp
  809cf9:	50                   	push   %eax
  809cfa:	e8 d5 69 00 00       	call   8106d4 <free>
	    goto done;
  809cff:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809d02:	c9                   	leave  
  809d03:	c3                   	ret    

00809d04 <sys_init>:
{
  809d04:	55                   	push   %ebp
  809d05:	89 e5                	mov    %esp,%ebp
  809d07:	56                   	push   %esi
  809d08:	53                   	push   %ebx
  809d09:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809d0f:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809d14:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809d19:	eb 10                	jmp    809d2b <sys_init+0x27>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809d1b:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809d22:	83 c0 14             	add    $0x14,%eax
  809d25:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
  809d27:	39 f0                	cmp    %esi,%eax
  809d29:	74 17                	je     809d42 <sys_init+0x3e>
  809d2b:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  809d2d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809d33:	89 50 0c             	mov    %edx,0xc(%eax)
  809d36:	85 d2                	test   %edx,%edx
  809d38:	74 e1                	je     809d1b <sys_init+0x17>
  809d3a:	8d 58 0c             	lea    0xc(%eax),%ebx
  809d3d:	89 5a 10             	mov    %ebx,0x10(%edx)
  809d40:	eb d9                	jmp    809d1b <sys_init+0x17>
  809d42:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809d49:	b1 b3 00 
  809d4c:	8b 15 44 4f b3 00    	mov    0xb34f44,%edx
  809d52:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809d57:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809d5c:	eb 15                	jmp    809d73 <sys_init+0x6f>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809d5e:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809d65:	4f b3 00 
  809d68:	05 9c 00 00 00       	add    $0x9c,%eax
  809d6d:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NMBOX; i++) {
  809d6f:	39 f0                	cmp    %esi,%eax
  809d71:	74 20                	je     809d93 <sys_init+0x8f>
  809d73:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  809d75:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809d7b:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809d81:	85 d2                	test   %edx,%edx
  809d83:	74 d9                	je     809d5e <sys_init+0x5a>
  809d85:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809d8b:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809d91:	eb cb                	jmp    809d5e <sys_init+0x5a>
  809d93:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809d9a:	9c b3 00 
}
  809d9d:	5b                   	pop    %ebx
  809d9e:	5e                   	pop    %esi
  809d9f:	5d                   	pop    %ebp
  809da0:	c3                   	ret    

00809da1 <sys_sem_new>:
{
  809da1:	55                   	push   %ebp
  809da2:	89 e5                	mov    %esp,%ebp
  809da4:	53                   	push   %ebx
  809da5:	83 ec 04             	sub    $0x4,%esp
  809da8:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809dab:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809db0:	85 c0                	test   %eax,%eax
  809db2:	74 3e                	je     809df2 <sys_sem_new+0x51>
    LIST_REMOVE(se, link);
  809db4:	8b 48 0c             	mov    0xc(%eax),%ecx
  809db7:	85 c9                	test   %ecx,%ecx
  809db9:	74 06                	je     809dc1 <sys_sem_new+0x20>
  809dbb:	8b 58 10             	mov    0x10(%eax),%ebx
  809dbe:	89 59 10             	mov    %ebx,0x10(%ecx)
  809dc1:	8b 48 10             	mov    0x10(%eax),%ecx
  809dc4:	8b 58 0c             	mov    0xc(%eax),%ebx
  809dc7:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809dc9:	83 38 00             	cmpl   $0x0,(%eax)
  809dcc:	74 3b                	je     809e09 <sys_sem_new+0x68>
    se->freed = 0;
  809dce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  809dd4:	0f b6 d2             	movzbl %dl,%edx
  809dd7:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809ddb:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809ddf:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809de4:	c1 f8 02             	sar    $0x2,%eax
  809de7:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809ded:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809df0:	c9                   	leave  
  809df1:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809df2:	83 ec 0c             	sub    $0xc,%esp
  809df5:	68 2c 24 81 00       	push   $0x81242c
  809dfa:	e8 4c 48 00 00       	call   80e64b <cprintf>
	return SYS_SEM_NULL;
  809dff:	83 c4 10             	add    $0x10,%esp
  809e02:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809e07:	eb e4                	jmp    809ded <sys_sem_new+0x4c>
    assert(se->freed);
  809e09:	68 a1 25 81 00       	push   $0x8125a1
  809e0e:	68 ab 25 81 00       	push   $0x8125ab
  809e13:	68 8d 00 00 00       	push   $0x8d
  809e18:	68 c0 25 81 00       	push   $0x8125c0
  809e1d:	e8 4e 47 00 00       	call   80e570 <_panic>

00809e22 <sys_sem_free>:
{
  809e22:	55                   	push   %ebp
  809e23:	89 e5                	mov    %esp,%ebp
  809e25:	83 ec 08             	sub    $0x8,%esp
  809e28:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809e2b:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809e2e:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809e35:	00 
  809e36:	75 5a                	jne    809e92 <sys_sem_free+0x70>
    sems[sem].freed = 1;
  809e38:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809e3b:	c1 e2 02             	shl    $0x2,%edx
  809e3e:	8d 8a 80 9d b3 00    	lea    0xb39d80(%edx),%ecx
  809e44:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  809e4b:	00 00 00 
    sems[sem].gen++;
  809e4e:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809e52:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809e58:	89 51 0c             	mov    %edx,0xc(%ecx)
  809e5b:	85 d2                	test   %edx,%edx
  809e5d:	74 0d                	je     809e6c <sys_sem_free+0x4a>
  809e5f:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809e62:	8d 0c 8d 8c 9d b3 00 	lea    0xb39d8c(,%ecx,4),%ecx
  809e69:	89 4a 10             	mov    %ecx,0x10(%edx)
  809e6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809e73:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809e76:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  809e7d:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  809e83:	01 d0                	add    %edx,%eax
  809e85:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  809e8c:	60 9d b3 00 
}
  809e90:	c9                   	leave  
  809e91:	c3                   	ret    
    assert(!sems[sem].freed);
  809e92:	68 dd 25 81 00       	push   $0x8125dd
  809e97:	68 ab 25 81 00       	push   $0x8125ab
  809e9c:	68 98 00 00 00       	push   $0x98
  809ea1:	68 c0 25 81 00       	push   $0x8125c0
  809ea6:	e8 c5 46 00 00       	call   80e570 <_panic>

00809eab <sys_mbox_free>:
{
  809eab:	55                   	push   %ebp
  809eac:	89 e5                	mov    %esp,%ebp
  809eae:	56                   	push   %esi
  809eaf:	53                   	push   %ebx
  809eb0:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809eb3:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809eb9:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  809ec0:	75 72                	jne    809f34 <sys_mbox_free+0x89>
    sys_sem_free(mboxes[mbox].queued_msg);
  809ec2:	83 ec 0c             	sub    $0xc,%esp
  809ec5:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809ecb:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  809ed1:	e8 4c ff ff ff       	call   809e22 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809ed6:	83 c4 04             	add    $0x4,%esp
  809ed9:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  809edf:	e8 3e ff ff ff       	call   809e22 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809ee4:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  809ee9:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  809eef:	83 c4 10             	add    $0x10,%esp
  809ef2:	85 c0                	test   %eax,%eax
  809ef4:	74 12                	je     809f08 <sys_mbox_free+0x5d>
  809ef6:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809efc:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  809f02:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809f08:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809f0e:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  809f14:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  809f19:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  809f20:	4f b3 00 
    mboxes[mbox].freed = 1;
  809f23:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  809f2a:	00 00 00 
}
  809f2d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809f30:	5b                   	pop    %ebx
  809f31:	5e                   	pop    %esi
  809f32:	5d                   	pop    %ebp
  809f33:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  809f34:	68 ee 25 81 00       	push   $0x8125ee
  809f39:	68 ab 25 81 00       	push   $0x8125ab
  809f3e:	6a 62                	push   $0x62
  809f40:	68 c0 25 81 00       	push   $0x8125c0
  809f45:	e8 26 46 00 00       	call   80e570 <_panic>

00809f4a <sys_mbox_new>:
{
  809f4a:	55                   	push   %ebp
  809f4b:	89 e5                	mov    %esp,%ebp
  809f4d:	57                   	push   %edi
  809f4e:	56                   	push   %esi
  809f4f:	53                   	push   %ebx
  809f50:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  809f53:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809f57:	0f 8f 9f 00 00 00    	jg     809ffc <sys_mbox_new+0xb2>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809f5d:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  809f63:	85 db                	test   %ebx,%ebx
  809f65:	0f 84 a7 00 00 00    	je     80a012 <sys_mbox_new+0xc8>
    LIST_REMOVE(mbe, link);
  809f6b:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  809f71:	85 c0                	test   %eax,%eax
  809f73:	74 0c                	je     809f81 <sys_mbox_new+0x37>
  809f75:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  809f7b:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809f81:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809f87:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  809f8d:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  809f8f:	83 3b 00             	cmpl   $0x0,(%ebx)
  809f92:	0f 84 91 00 00 00    	je     80a029 <sys_mbox_new+0xdf>
    mbe->freed = 0;
  809f98:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  809f9e:	89 de                	mov    %ebx,%esi
  809fa0:	81 ee 60 4f b3 00    	sub    $0xb34f60,%esi
  809fa6:	c1 fe 02             	sar    $0x2,%esi
  809fa9:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  809faf:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  809fb1:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  809fb8:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  809fbf:	83 ec 0c             	sub    $0xc,%esp
  809fc2:	6a 00                	push   $0x0
  809fc4:	e8 d8 fd ff ff       	call   809da1 <sys_sem_new>
  809fc9:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  809fcf:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  809fd6:	e8 c6 fd ff ff       	call   809da1 <sys_sem_new>
  809fdb:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  809fe1:	83 c4 10             	add    $0x10,%esp
  809fe4:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  809feb:	74 52                	je     80a03f <sys_mbox_new+0xf5>
  809fed:	83 f8 ff             	cmp    $0xffffffff,%eax
  809ff0:	74 4d                	je     80a03f <sys_mbox_new+0xf5>
}
  809ff2:	89 f8                	mov    %edi,%eax
  809ff4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809ff7:	5b                   	pop    %ebx
  809ff8:	5e                   	pop    %esi
  809ff9:	5f                   	pop    %edi
  809ffa:	5d                   	pop    %ebp
  809ffb:	c3                   	ret    
    assert(size < MBOXSLOTS);
  809ffc:	68 02 26 81 00       	push   $0x812602
  80a001:	68 ab 25 81 00       	push   $0x8125ab
  80a006:	6a 45                	push   $0x45
  80a008:	68 c0 25 81 00       	push   $0x8125c0
  80a00d:	e8 5e 45 00 00       	call   80e570 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a012:	83 ec 0c             	sub    $0xc,%esp
  80a015:	68 54 24 81 00       	push   $0x812454
  80a01a:	e8 2c 46 00 00       	call   80e64b <cprintf>
	return SYS_MBOX_NULL;
  80a01f:	83 c4 10             	add    $0x10,%esp
  80a022:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a027:	eb c9                	jmp    809ff2 <sys_mbox_new+0xa8>
    assert(mbe->freed);
  80a029:	68 13 26 81 00       	push   $0x812613
  80a02e:	68 ab 25 81 00       	push   $0x8125ab
  80a033:	6a 4c                	push   $0x4c
  80a035:	68 c0 25 81 00       	push   $0x8125c0
  80a03a:	e8 31 45 00 00       	call   80e570 <_panic>
	sys_mbox_free(i);
  80a03f:	83 ec 0c             	sub    $0xc,%esp
  80a042:	56                   	push   %esi
  80a043:	e8 63 fe ff ff       	call   809eab <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a048:	c7 04 24 7c 24 81 00 	movl   $0x81247c,(%esp)
  80a04f:	e8 f7 45 00 00       	call   80e64b <cprintf>
	return SYS_MBOX_NULL;
  80a054:	83 c4 10             	add    $0x10,%esp
  80a057:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a05c:	eb 94                	jmp    809ff2 <sys_mbox_new+0xa8>

0080a05e <sys_sem_signal>:
{
  80a05e:	55                   	push   %ebp
  80a05f:	89 e5                	mov    %esp,%ebp
  80a061:	83 ec 08             	sub    $0x8,%esp
  80a064:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a067:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a06a:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a071:	00 
  80a072:	75 18                	jne    80a08c <sys_sem_signal+0x2e>
    sems[sem].counter++;
  80a074:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a077:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a07e:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a083:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a088:	75 1b                	jne    80a0a5 <sys_sem_signal+0x47>
}
  80a08a:	c9                   	leave  
  80a08b:	c3                   	ret    
    assert(!sems[sem].freed);
  80a08c:	68 dd 25 81 00       	push   $0x8125dd
  80a091:	68 ab 25 81 00       	push   $0x8125ab
  80a096:	68 a1 00 00 00       	push   $0xa1
  80a09b:	68 c0 25 81 00       	push   $0x8125c0
  80a0a0:	e8 cb 44 00 00       	call   80e570 <_panic>
	sems[sem].waiters = 0;
  80a0a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a0ac:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a0af:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a0b6:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a0b9:	83 ec 0c             	sub    $0xc,%esp
  80a0bc:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a0c3:	50                   	push   %eax
  80a0c4:	e8 a4 04 00 00       	call   80a56d <thread_wakeup>
  80a0c9:	83 c4 10             	add    $0x10,%esp
}
  80a0cc:	eb bc                	jmp    80a08a <sys_sem_signal+0x2c>

0080a0ce <sys_arch_sem_wait>:
{
  80a0ce:	55                   	push   %ebp
  80a0cf:	89 e5                	mov    %esp,%ebp
  80a0d1:	57                   	push   %edi
  80a0d2:	56                   	push   %esi
  80a0d3:	53                   	push   %ebx
  80a0d4:	83 ec 1c             	sub    $0x1c,%esp
  80a0d7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    assert(!sems[sem].freed);
  80a0da:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0dd:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a0e0:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a0e7:	00 
  80a0e8:	75 2c                	jne    80a116 <sys_arch_sem_wait+0x48>
    int gen = sems[sem].gen;
  80a0ea:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0ed:	c1 e0 02             	shl    $0x2,%eax
  80a0f0:	89 c2                	mov    %eax,%edx
  80a0f2:	03 55 08             	add    0x8(%ebp),%edx
  80a0f5:	8b 3c 95 84 9d b3 00 	mov    0xb39d84(,%edx,4),%edi
  80a0fc:	89 7d d8             	mov    %edi,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a0ff:	8d 04 95 88 9d b3 00 	lea    0xb39d88(,%edx,4),%eax
  80a106:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a109:	bf 00 00 00 00       	mov    $0x0,%edi
	if (sems[sem].counter > 0) {
  80a10e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a111:	e9 80 00 00 00       	jmp    80a196 <sys_arch_sem_wait+0xc8>
    assert(!sems[sem].freed);
  80a116:	68 dd 25 81 00       	push   $0x8125dd
  80a11b:	68 ab 25 81 00       	push   $0x8125ab
  80a120:	68 ac 00 00 00       	push   $0xac
  80a125:	68 c0 25 81 00       	push   $0x8125c0
  80a12a:	e8 41 44 00 00       	call   80e570 <_panic>
	if (sems[sem].counter > 0) {
  80a12f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a132:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a139:	00 
  80a13a:	66 85 c0             	test   %ax,%ax
  80a13d:	75 6e                	jne    80a1ad <sys_arch_sem_wait+0xdf>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a13f:	83 fb fe             	cmp    $0xfffffffe,%ebx
  80a142:	0f 84 8f 00 00 00    	je     80a1d7 <sys_arch_sem_wait+0x109>
	    uint32_t a = sys_time_msec();
  80a148:	e8 bd 50 00 00       	call   80f20a <sys_time_msec>
  80a14d:	89 c1                	mov    %eax,%ecx
  80a14f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a152:	89 d8                	mov    %ebx,%eax
  80a154:	29 f8                	sub    %edi,%eax
  80a156:	01 c8                	add    %ecx,%eax
  80a158:	85 db                	test   %ebx,%ebx
  80a15a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a15f:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a162:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a165:	8d 34 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%esi
  80a16c:	66 c7 46 0a 01 00    	movw   $0x1,0xa(%esi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a172:	83 ec 04             	sub    $0x4,%esp
  80a175:	50                   	push   %eax
  80a176:	ff 76 08             	pushl  0x8(%esi)
  80a179:	ff 75 dc             	pushl  -0x24(%ebp)
  80a17c:	e8 02 06 00 00       	call   80a783 <thread_wait>
	    if (gen != sems[sem].gen) {
  80a181:	83 c4 10             	add    $0x10,%esp
  80a184:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a187:	39 46 04             	cmp    %eax,0x4(%esi)
  80a18a:	75 34                	jne    80a1c0 <sys_arch_sem_wait+0xf2>
	    uint32_t b = sys_time_msec();
  80a18c:	e8 79 50 00 00       	call   80f20a <sys_time_msec>
	    waited += (b - a);
  80a191:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a194:	01 c7                	add    %eax,%edi
    while (tm_msec == 0 || waited < tm_msec) {
  80a196:	85 db                	test   %ebx,%ebx
  80a198:	74 95                	je     80a12f <sys_arch_sem_wait+0x61>
  80a19a:	39 df                	cmp    %ebx,%edi
  80a19c:	72 91                	jb     80a12f <sys_arch_sem_wait+0x61>
    return SYS_ARCH_TIMEOUT;
  80a19e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  80a1a3:	89 f8                	mov    %edi,%eax
  80a1a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a1a8:	5b                   	pop    %ebx
  80a1a9:	5e                   	pop    %esi
  80a1aa:	5f                   	pop    %edi
  80a1ab:	5d                   	pop    %ebp
  80a1ac:	c3                   	ret    
	    sems[sem].counter--;
  80a1ad:	8b 55 08             	mov    0x8(%ebp),%edx
  80a1b0:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a1b3:	83 e8 01             	sub    $0x1,%eax
  80a1b6:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a1bd:	00 
	    return waited;
  80a1be:	eb e3                	jmp    80a1a3 <sys_arch_sem_wait+0xd5>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a1c0:	83 ec 0c             	sub    $0xc,%esp
  80a1c3:	68 a8 24 81 00       	push   $0x8124a8
  80a1c8:	e8 7e 44 00 00       	call   80e64b <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a1cd:	83 c4 10             	add    $0x10,%esp
  80a1d0:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a1d5:	eb cc                	jmp    80a1a3 <sys_arch_sem_wait+0xd5>
	    return SYS_ARCH_TIMEOUT;
  80a1d7:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a1dc:	eb c5                	jmp    80a1a3 <sys_arch_sem_wait+0xd5>

0080a1de <sys_mbox_trypost>:
{
  80a1de:	55                   	push   %ebp
  80a1df:	89 e5                	mov    %esp,%ebp
  80a1e1:	57                   	push   %edi
  80a1e2:	56                   	push   %esi
  80a1e3:	53                   	push   %ebx
  80a1e4:	83 ec 0c             	sub    $0xc,%esp
  80a1e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a1ea:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1f0:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a1f7:	75 7f                	jne    80a278 <sys_mbox_trypost+0x9a>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a1f9:	83 ec 08             	sub    $0x8,%esp
  80a1fc:	6a 00                	push   $0x0
  80a1fe:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a204:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a20a:	e8 bf fe ff ff       	call   80a0ce <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a20f:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a215:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a21b:	83 c4 10             	add    $0x10,%esp
  80a21e:	39 ca                	cmp    %ecx,%edx
  80a220:	74 7a                	je     80a29c <sys_mbox_trypost+0xbe>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a222:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a228:	8d 42 01             	lea    0x1(%edx),%eax
  80a22b:	89 c7                	mov    %eax,%edi
  80a22d:	c1 ff 1f             	sar    $0x1f,%edi
  80a230:	c1 ef 1b             	shr    $0x1b,%edi
  80a233:	01 f8                	add    %edi,%eax
  80a235:	83 e0 1f             	and    $0x1f,%eax
  80a238:	29 f8                	sub    %edi,%eax
  80a23a:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a240:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a243:	01 d0                	add    %edx,%eax
  80a245:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a248:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a24f:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a252:	74 3a                	je     80a28e <sys_mbox_trypost+0xb0>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a254:	83 ec 0c             	sub    $0xc,%esp
  80a257:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a25d:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a263:	e8 f6 fd ff ff       	call   80a05e <sys_sem_signal>
    return ERR_OK;
  80a268:	83 c4 10             	add    $0x10,%esp
  80a26b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a270:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a273:	5b                   	pop    %ebx
  80a274:	5e                   	pop    %esi
  80a275:	5f                   	pop    %edi
  80a276:	5d                   	pop    %ebp
  80a277:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a278:	68 ee 25 81 00       	push   $0x8125ee
  80a27d:	68 ab 25 81 00       	push   $0x8125ab
  80a282:	6a 72                	push   $0x72
  80a284:	68 c0 25 81 00       	push   $0x8125c0
  80a289:	e8 e2 42 00 00       	call   80e570 <_panic>
	mboxes[mbox].head = slot;
  80a28e:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a294:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)
  80a29a:	eb b8                	jmp    80a254 <sys_mbox_trypost+0x76>
	return ERR_MEM;
  80a29c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a2a1:	eb cd                	jmp    80a270 <sys_mbox_trypost+0x92>

0080a2a3 <sys_mbox_post>:
{
  80a2a3:	55                   	push   %ebp
  80a2a4:	89 e5                	mov    %esp,%ebp
  80a2a6:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a2a9:	ff 75 0c             	pushl  0xc(%ebp)
  80a2ac:	ff 75 08             	pushl  0x8(%ebp)
  80a2af:	e8 2a ff ff ff       	call   80a1de <sys_mbox_trypost>
  80a2b4:	83 c4 10             	add    $0x10,%esp
  80a2b7:	84 c0                	test   %al,%al
  80a2b9:	75 02                	jne    80a2bd <sys_mbox_post+0x1a>
}
  80a2bb:	c9                   	leave  
  80a2bc:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a2bd:	68 d4 24 81 00       	push   $0x8124d4
  80a2c2:	68 ab 25 81 00       	push   $0x8125ab
  80a2c7:	6a 6c                	push   $0x6c
  80a2c9:	68 c0 25 81 00       	push   $0x8125c0
  80a2ce:	e8 9d 42 00 00       	call   80e570 <_panic>

0080a2d3 <sys_arch_mbox_fetch>:
{
  80a2d3:	55                   	push   %ebp
  80a2d4:	89 e5                	mov    %esp,%ebp
  80a2d6:	57                   	push   %edi
  80a2d7:	56                   	push   %esi
  80a2d8:	53                   	push   %ebx
  80a2d9:	83 ec 0c             	sub    $0xc,%esp
  80a2dc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a2df:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a2e2:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2e8:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a2ef:	0f 85 8a 00 00 00    	jne    80a37f <sys_arch_mbox_fetch+0xac>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a2f5:	83 ec 08             	sub    $0x8,%esp
  80a2f8:	ff 75 10             	pushl  0x10(%ebp)
  80a2fb:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a301:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a307:	e8 c2 fd ff ff       	call   80a0ce <sys_arch_sem_wait>
  80a30c:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a30e:	83 c4 10             	add    $0x10,%esp
  80a311:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a314:	74 5f                	je     80a375 <sys_arch_mbox_fetch+0xa2>
    int slot = mboxes[mbox].head;
  80a316:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a31c:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a322:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a325:	74 71                	je     80a398 <sys_arch_mbox_fetch+0xc5>
    if (msg)
  80a327:	85 ff                	test   %edi,%edi
  80a329:	74 0e                	je     80a339 <sys_arch_mbox_fetch+0x66>
	*msg = mboxes[mbox].msg[slot];
  80a32b:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a32e:	01 c2                	add    %eax,%edx
  80a330:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a337:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a339:	83 c0 01             	add    $0x1,%eax
  80a33c:	99                   	cltd   
  80a33d:	c1 ea 1b             	shr    $0x1b,%edx
  80a340:	01 d0                	add    %edx,%eax
  80a342:	83 e0 1f             	and    $0x1f,%eax
  80a345:	29 d0                	sub    %edx,%eax
  80a347:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a34d:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a353:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a359:	3b 42 08             	cmp    0x8(%edx),%eax
  80a35c:	74 51                	je     80a3af <sys_arch_mbox_fetch+0xdc>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a35e:	83 ec 0c             	sub    $0xc,%esp
  80a361:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a367:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a36d:	e8 ec fc ff ff       	call   80a05e <sys_sem_signal>
    return waited;
  80a372:	83 c4 10             	add    $0x10,%esp
}
  80a375:	89 f0                	mov    %esi,%eax
  80a377:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a37a:	5b                   	pop    %ebx
  80a37b:	5e                   	pop    %esi
  80a37c:	5f                   	pop    %edi
  80a37d:	5d                   	pop    %ebp
  80a37e:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a37f:	68 ee 25 81 00       	push   $0x8125ee
  80a384:	68 ab 25 81 00       	push   $0x8125ab
  80a389:	68 ce 00 00 00       	push   $0xce
  80a38e:	68 c0 25 81 00       	push   $0x8125c0
  80a393:	e8 d8 41 00 00       	call   80e570 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a398:	83 ec 04             	sub    $0x4,%esp
  80a39b:	68 fc 24 81 00       	push   $0x8124fc
  80a3a0:	68 d6 00 00 00       	push   $0xd6
  80a3a5:	68 c0 25 81 00       	push   $0x8125c0
  80a3aa:	e8 c1 41 00 00       	call   80e570 <_panic>
	mboxes[mbox].head = -1;
  80a3af:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3b5:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a3bc:	ff ff ff 
  80a3bf:	eb 9d                	jmp    80a35e <sys_arch_mbox_fetch+0x8b>

0080a3c1 <sys_arch_mbox_tryfetch>:
{
  80a3c1:	55                   	push   %ebp
  80a3c2:	89 e5                	mov    %esp,%ebp
  80a3c4:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a3c7:	6a fe                	push   $0xfffffffe
  80a3c9:	ff 75 0c             	pushl  0xc(%ebp)
  80a3cc:	ff 75 08             	pushl  0x8(%ebp)
  80a3cf:	e8 ff fe ff ff       	call   80a2d3 <sys_arch_mbox_fetch>
}
  80a3d4:	c9                   	leave  
  80a3d5:	c3                   	ret    

0080a3d6 <sys_thread_new>:
{
  80a3d6:	55                   	push   %ebp
  80a3d7:	89 e5                	mov    %esp,%ebp
  80a3d9:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a3dc:	6a 08                	push   $0x8
  80a3de:	e8 9d 63 00 00       	call   810780 <malloc>
    if (lt == 0)
  80a3e3:	83 c4 10             	add    $0x10,%esp
  80a3e6:	85 c0                	test   %eax,%eax
  80a3e8:	74 32                	je     80a41c <sys_thread_new+0x46>
    if (stacksize > PGSIZE)
  80a3ea:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a3f1:	7f 40                	jg     80a433 <sys_thread_new+0x5d>
    lt->func = thread;
  80a3f3:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a3f6:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a3f8:	8b 55 10             	mov    0x10(%ebp),%edx
  80a3fb:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a3fe:	50                   	push   %eax
  80a3ff:	68 8e 9c 80 00       	push   $0x809c8e
  80a404:	ff 75 08             	pushl  0x8(%ebp)
  80a407:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a40a:	50                   	push   %eax
  80a40b:	e8 c7 01 00 00       	call   80a5d7 <thread_create>
    if (r < 0)
  80a410:	83 c4 10             	add    $0x10,%esp
  80a413:	85 c0                	test   %eax,%eax
  80a415:	78 33                	js     80a44a <sys_thread_new+0x74>
}
  80a417:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a41a:	c9                   	leave  
  80a41b:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a41c:	83 ec 04             	sub    $0x4,%esp
  80a41f:	68 24 25 81 00       	push   $0x812524
  80a424:	68 fd 00 00 00       	push   $0xfd
  80a429:	68 c0 25 81 00       	push   $0x8125c0
  80a42e:	e8 3d 41 00 00       	call   80e570 <_panic>
	panic("large stack %d", stacksize);
  80a433:	ff 75 14             	pushl  0x14(%ebp)
  80a436:	68 1e 26 81 00       	push   $0x81261e
  80a43b:	68 00 01 00 00       	push   $0x100
  80a440:	68 c0 25 81 00       	push   $0x8125c0
  80a445:	e8 26 41 00 00       	call   80e570 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a44a:	83 ec 0c             	sub    $0xc,%esp
  80a44d:	50                   	push   %eax
  80a44e:	e8 b6 04 00 00       	call   80a909 <e2s>
  80a453:	50                   	push   %eax
  80a454:	68 54 25 81 00       	push   $0x812554
  80a459:	68 09 01 00 00       	push   $0x109
  80a45e:	68 c0 25 81 00       	push   $0x8125c0
  80a463:	e8 08 41 00 00       	call   80e570 <_panic>

0080a468 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a468:	55                   	push   %ebp
  80a469:	89 e5                	mov    %esp,%ebp
  80a46b:	57                   	push   %edi
  80a46c:	56                   	push   %esi
  80a46d:	53                   	push   %ebx
  80a46e:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a471:	e8 ef 00 00 00       	call   80a565 <thread_id>
  80a476:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a478:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a47d:	f7 e2                	mul    %edx
  80a47f:	c1 ea 08             	shr    $0x8,%edx
  80a482:	89 d7                	mov    %edx,%edi
  80a484:	c1 e2 08             	shl    $0x8,%edx
  80a487:	01 d7                	add    %edx,%edi
  80a489:	89 f0                	mov    %esi,%eax
  80a48b:	29 f8                	sub    %edi,%eax
  80a48d:	89 c7                	mov    %eax,%edi
  80a48f:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a496:	85 db                	test   %ebx,%ebx
  80a498:	74 09                	je     80a4a3 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a49a:	39 33                	cmp    %esi,(%ebx)
  80a49c:	74 66                	je     80a504 <sys_arch_timeouts+0x9c>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a49e:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a4a1:	eb f3                	jmp    80a496 <sys_arch_timeouts+0x2e>
	    goto out;

    t = malloc(sizeof(*t));
  80a4a3:	83 ec 0c             	sub    $0xc,%esp
  80a4a6:	6a 10                	push   $0x10
  80a4a8:	e8 d3 62 00 00       	call   810780 <malloc>
  80a4ad:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a4af:	83 c4 10             	add    $0x10,%esp
  80a4b2:	85 c0                	test   %eax,%eax
  80a4b4:	74 59                	je     80a50f <sys_arch_timeouts+0xa7>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a4b6:	83 ec 0c             	sub    $0xc,%esp
  80a4b9:	68 ad 9c 80 00       	push   $0x809cad
  80a4be:	e8 ea 00 00 00       	call   80a5ad <thread_onhalt>
    if (r < 0)
  80a4c3:	83 c4 10             	add    $0x10,%esp
  80a4c6:	85 c0                	test   %eax,%eax
  80a4c8:	78 5c                	js     80a526 <sys_arch_timeouts+0xbe>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a4ca:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a4cc:	83 ec 04             	sub    $0x4,%esp
  80a4cf:	6a 04                	push   $0x4
  80a4d1:	6a 00                	push   $0x0
  80a4d3:	8d 43 04             	lea    0x4(%ebx),%eax
  80a4d6:	50                   	push   %eax
  80a4d7:	e8 91 48 00 00       	call   80ed6d <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a4dc:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a4e3:	89 43 08             	mov    %eax,0x8(%ebx)
  80a4e6:	83 c4 10             	add    $0x10,%esp
  80a4e9:	85 c0                	test   %eax,%eax
  80a4eb:	74 06                	je     80a4f3 <sys_arch_timeouts+0x8b>
  80a4ed:	8d 53 08             	lea    0x8(%ebx),%edx
  80a4f0:	89 50 0c             	mov    %edx,0xc(%eax)
  80a4f3:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a4fa:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a501:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a504:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a507:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a50a:	5b                   	pop    %ebx
  80a50b:	5e                   	pop    %esi
  80a50c:	5f                   	pop    %edi
  80a50d:	5d                   	pop    %ebp
  80a50e:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a50f:	83 ec 04             	sub    $0x4,%esp
  80a512:	68 80 25 81 00       	push   $0x812580
  80a517:	68 2c 01 00 00       	push   $0x12c
  80a51c:	68 c0 25 81 00       	push   $0x8125c0
  80a521:	e8 4a 40 00 00       	call   80e570 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a526:	83 ec 0c             	sub    $0xc,%esp
  80a529:	50                   	push   %eax
  80a52a:	e8 da 03 00 00       	call   80a909 <e2s>
  80a52f:	50                   	push   %eax
  80a530:	68 2d 26 81 00       	push   $0x81262d
  80a535:	68 30 01 00 00       	push   $0x130
  80a53a:	68 c0 25 81 00       	push   $0x8125c0
  80a53f:	e8 2c 40 00 00       	call   80e570 <_panic>

0080a544 <lwip_core_lock>:

void
lwip_core_lock(void)
{
}
  80a544:	c3                   	ret    

0080a545 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
}
  80a545:	c3                   	ret    

0080a546 <thread_init>:
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a546:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a54d:	00 00 00 
    tq->tq_last = 0;
  80a550:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a557:	00 00 00 
static struct thread_queue kill_queue;

void
thread_init(void) {
    threadq_init(&thread_queue);
    max_tid = 0;
  80a55a:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a561:	00 00 00 
}
  80a564:	c3                   	ret    

0080a565 <thread_id>:

uint32_t
thread_id(void) {
    return cur_tc->tc_tid;
  80a565:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a56a:	8b 00                	mov    (%eax),%eax
}
  80a56c:	c3                   	ret    

0080a56d <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a56d:	55                   	push   %ebp
  80a56e:	89 e5                	mov    %esp,%ebp
  80a570:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a573:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a578:	eb 07                	jmp    80a581 <thread_wakeup+0x14>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
  80a57a:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a57e:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a581:	85 c0                	test   %eax,%eax
  80a583:	74 07                	je     80a58c <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80a585:	39 50 48             	cmp    %edx,0x48(%eax)
  80a588:	75 f4                	jne    80a57e <thread_wakeup+0x11>
  80a58a:	eb ee                	jmp    80a57a <thread_wakeup+0xd>
    }
}
  80a58c:	5d                   	pop    %ebp
  80a58d:	c3                   	ret    

0080a58e <thread_wakeups_pending>:
}

int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
  80a58e:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
    int n = 0;
  80a594:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a599:	85 d2                	test   %edx,%edx
  80a59b:	74 0f                	je     80a5ac <thread_wakeups_pending+0x1e>
	if (tc->tc_wakeup)
  80a59d:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a5a1:	80 f9 01             	cmp    $0x1,%cl
  80a5a4:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a5a7:	8b 52 64             	mov    0x64(%edx),%edx
  80a5aa:	eb ed                	jmp    80a599 <thread_wakeups_pending+0xb>
    }
    return n;
}
  80a5ac:	c3                   	ret    

0080a5ad <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a5ad:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a5b2:	8b 50 60             	mov    0x60(%eax),%edx
  80a5b5:	83 fa 03             	cmp    $0x3,%edx
  80a5b8:	7f 17                	jg     80a5d1 <thread_onhalt+0x24>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a5ba:	55                   	push   %ebp
  80a5bb:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a5bd:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a5c0:	89 48 60             	mov    %ecx,0x60(%eax)
  80a5c3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a5c6:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a5ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a5cf:	5d                   	pop    %ebp
  80a5d0:	c3                   	ret    
	return -E_NO_MEM;
  80a5d1:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a5d6:	c3                   	ret    

0080a5d7 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a5d7:	55                   	push   %ebp
  80a5d8:	89 e5                	mov    %esp,%ebp
  80a5da:	57                   	push   %edi
  80a5db:	56                   	push   %esi
  80a5dc:	53                   	push   %ebx
  80a5dd:	83 ec 18             	sub    $0x18,%esp
  80a5e0:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a5e3:	6a 68                	push   $0x68
  80a5e5:	e8 96 61 00 00       	call   810780 <malloc>
    if (!tc)
  80a5ea:	83 c4 10             	add    $0x10,%esp
  80a5ed:	85 c0                	test   %eax,%eax
  80a5ef:	0f 84 04 01 00 00    	je     80a6f9 <thread_create+0x122>
  80a5f5:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a5f7:	83 ec 04             	sub    $0x4,%esp
  80a5fa:	6a 68                	push   $0x68
  80a5fc:	6a 00                	push   $0x0
  80a5fe:	50                   	push   %eax
  80a5ff:	e8 69 47 00 00       	call   80ed6d <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a604:	83 c4 0c             	add    $0xc,%esp
  80a607:	6a 1f                	push   $0x1f
  80a609:	ff 75 0c             	pushl  0xc(%ebp)
  80a60c:	8d 43 08             	lea    0x8(%ebx),%eax
  80a60f:	50                   	push   %eax
  80a610:	e8 57 46 00 00       	call   80ec6c <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a615:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a619:	a1 94 b1 b3 00       	mov    0xb3b194,%eax
  80a61e:	8d 50 01             	lea    0x1(%eax),%edx
  80a621:	89 15 94 b1 b3 00    	mov    %edx,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a627:	83 c4 10             	add    $0x10,%esp
  80a62a:	83 fa ff             	cmp    $0xffffffff,%edx
  80a62d:	0f 84 91 00 00 00    	je     80a6c4 <thread_create+0xed>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a633:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a635:	83 ec 0c             	sub    $0xc,%esp
  80a638:	68 00 10 00 00       	push   $0x1000
  80a63d:	e8 3e 61 00 00       	call   810780 <malloc>
  80a642:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a645:	83 c4 10             	add    $0x10,%esp
  80a648:	85 c0                	test   %eax,%eax
  80a64a:	0f 84 88 00 00 00    	je     80a6d8 <thread_create+0x101>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a650:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a656:	83 ec 04             	sub    $0x4,%esp
  80a659:	6a 04                	push   $0x4
  80a65b:	6a 00                	push   $0x0
  80a65d:	57                   	push   %edi
  80a65e:	e8 0a 47 00 00       	call   80ed6d <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a663:	83 c4 0c             	add    $0xc,%esp
  80a666:	6a 18                	push   $0x18
  80a668:	6a 00                	push   $0x0
  80a66a:	8d 43 30             	lea    0x30(%ebx),%eax
  80a66d:	50                   	push   %eax
  80a66e:	e8 fa 46 00 00       	call   80ed6d <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a673:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a676:	c7 43 30 84 a8 80 00 	movl   $0x80a884,0x30(%ebx)
    tc->tc_entry = entry;
  80a67d:	8b 45 10             	mov    0x10(%ebp),%eax
  80a680:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a683:	8b 45 14             	mov    0x14(%ebp),%eax
  80a686:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a689:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a690:	83 c4 10             	add    $0x10,%esp
  80a693:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a69a:	74 4f                	je     80a6eb <thread_create+0x114>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a69c:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a6a1:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a6a4:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a6aa:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a6af:	85 f6                	test   %esi,%esi
  80a6b1:	74 09                	je     80a6bc <thread_create+0xe5>
	*tid = tc->tc_tid;
  80a6b3:	8b 03                	mov    (%ebx),%eax
  80a6b5:	89 06                	mov    %eax,(%esi)
    return 0;
  80a6b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a6bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a6bf:	5b                   	pop    %ebx
  80a6c0:	5e                   	pop    %esi
  80a6c1:	5f                   	pop    %edi
  80a6c2:	5d                   	pop    %ebp
  80a6c3:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80a6c4:	83 ec 04             	sub    $0x4,%esp
  80a6c7:	68 46 26 81 00       	push   $0x812646
  80a6cc:	6a 54                	push   $0x54
  80a6ce:	68 64 26 81 00       	push   $0x812664
  80a6d3:	e8 98 3e 00 00       	call   80e570 <_panic>
	free(tc);
  80a6d8:	83 ec 0c             	sub    $0xc,%esp
  80a6db:	53                   	push   %ebx
  80a6dc:	e8 f3 5f 00 00       	call   8106d4 <free>
	return -E_NO_MEM;
  80a6e1:	83 c4 10             	add    $0x10,%esp
  80a6e4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a6e9:	eb d1                	jmp    80a6bc <thread_create+0xe5>
	tq->tq_first = tc;
  80a6eb:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a6f1:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a6f7:	eb b1                	jmp    80a6aa <thread_create+0xd3>
	return -E_NO_MEM;
  80a6f9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a6fe:	eb bc                	jmp    80a6bc <thread_create+0xe5>

0080a700 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a700:	55                   	push   %ebp
  80a701:	89 e5                	mov    %esp,%ebp
  80a703:	53                   	push   %ebx
  80a704:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a707:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a70d:	85 db                	test   %ebx,%ebx
  80a70f:	74 2b                	je     80a73c <thread_yield+0x3c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a711:	8b 43 64             	mov    0x64(%ebx),%eax
  80a714:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a719:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a720:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a725:	85 c0                	test   %eax,%eax
  80a727:	74 3b                	je     80a764 <thread_yield+0x64>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a729:	83 ec 0c             	sub    $0xc,%esp
  80a72c:	83 c0 30             	add    $0x30,%eax
  80a72f:	50                   	push   %eax
  80a730:	e8 6b 01 00 00       	call   80a8a0 <jos_setjmp>
  80a735:	83 c4 10             	add    $0x10,%esp
  80a738:	85 c0                	test   %eax,%eax
  80a73a:	74 05                	je     80a741 <thread_yield+0x41>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80a73c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a73f:	c9                   	leave  
  80a740:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80a741:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a746:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a74d:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a754:	74 21                	je     80a777 <thread_yield+0x77>
	tq->tq_last->tc_queue_link = tc;
  80a756:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a75c:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a75f:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    cur_tc = next_tc;
  80a764:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a76a:	8d 43 30             	lea    0x30(%ebx),%eax
  80a76d:	ba 01 00 00 00       	mov    $0x1,%edx
  80a772:	e8 59 01 00 00       	call   80a8d0 <jos_longjmp>
	tq->tq_first = tc;
  80a777:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a77c:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a781:	eb e1                	jmp    80a764 <thread_yield+0x64>

0080a783 <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a783:	55                   	push   %ebp
  80a784:	89 e5                	mov    %esp,%ebp
  80a786:	57                   	push   %edi
  80a787:	56                   	push   %esi
  80a788:	53                   	push   %ebx
  80a789:	83 ec 0c             	sub    $0xc,%esp
  80a78c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a78f:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a792:	e8 73 4a 00 00       	call   80f20a <sys_time_msec>
  80a797:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80a799:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a79e:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a7a1:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80a7a5:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80a7a7:	eb 17                	jmp    80a7c0 <thread_wait+0x3d>
	if (cur_tc->tc_wakeup)
  80a7a9:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a7ae:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a7b2:	84 c0                	test   %al,%al
  80a7b4:	75 1d                	jne    80a7d3 <thread_wait+0x50>
	thread_yield();
  80a7b6:	e8 45 ff ff ff       	call   80a700 <thread_yield>
	p = sys_time_msec();
  80a7bb:	e8 4a 4a 00 00       	call   80f20a <sys_time_msec>
	if (p < s)
  80a7c0:	39 f0                	cmp    %esi,%eax
  80a7c2:	72 0f                	jb     80a7d3 <thread_wait+0x50>
  80a7c4:	39 f8                	cmp    %edi,%eax
  80a7c6:	73 0b                	jae    80a7d3 <thread_wait+0x50>
	if (addr && *addr != val)
  80a7c8:	85 db                	test   %ebx,%ebx
  80a7ca:	74 dd                	je     80a7a9 <thread_wait+0x26>
  80a7cc:	8b 03                	mov    (%ebx),%eax
  80a7ce:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a7d1:	74 d6                	je     80a7a9 <thread_wait+0x26>
    cur_tc->tc_wait_addr = 0;
  80a7d3:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a7d8:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a7df:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a7e3:	83 c4 0c             	add    $0xc,%esp
  80a7e6:	5b                   	pop    %ebx
  80a7e7:	5e                   	pop    %esi
  80a7e8:	5f                   	pop    %edi
  80a7e9:	5d                   	pop    %ebp
  80a7ea:	c3                   	ret    

0080a7eb <thread_halt>:
thread_halt() {
  80a7eb:	55                   	push   %ebp
  80a7ec:	89 e5                	mov    %esp,%ebp
  80a7ee:	56                   	push   %esi
  80a7ef:	53                   	push   %ebx
    if (!tq->tq_first)
  80a7f0:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80a7f6:	85 db                	test   %ebx,%ebx
  80a7f8:	74 40                	je     80a83a <thread_halt+0x4f>
    tq->tq_first = tc->tc_queue_link;
  80a7fa:	8b 43 64             	mov    0x64(%ebx),%eax
  80a7fd:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80a802:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a809:	be 00 00 00 00       	mov    $0x0,%esi
  80a80e:	eb 0f                	jmp    80a81f <thread_halt+0x34>
	tc->tc_onhalt[i](tc->tc_tid);
  80a810:	83 ec 0c             	sub    $0xc,%esp
  80a813:	ff 33                	pushl  (%ebx)
  80a815:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a819:	83 c6 01             	add    $0x1,%esi
  80a81c:	83 c4 10             	add    $0x10,%esp
  80a81f:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a822:	7c ec                	jl     80a810 <thread_halt+0x25>
    free(tc->tc_stack_bottom);
  80a824:	83 ec 0c             	sub    $0xc,%esp
  80a827:	ff 73 04             	pushl  0x4(%ebx)
  80a82a:	e8 a5 5e 00 00       	call   8106d4 <free>
    free(tc);
  80a82f:	89 1c 24             	mov    %ebx,(%esp)
  80a832:	e8 9d 5e 00 00       	call   8106d4 <free>
  80a837:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80a83a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a83f:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a846:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80a84d:	74 29                	je     80a878 <thread_halt+0x8d>
	tq->tq_last->tc_queue_link = tc;
  80a84f:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80a855:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a858:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80a85d:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80a864:	00 00 00 
    thread_yield();
  80a867:	e8 94 fe ff ff       	call   80a700 <thread_yield>
    exit();
  80a86c:	e8 e5 3c 00 00       	call   80e556 <exit>
}
  80a871:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a874:	5b                   	pop    %ebx
  80a875:	5e                   	pop    %esi
  80a876:	5d                   	pop    %ebp
  80a877:	c3                   	ret    
	tq->tq_first = tc;
  80a878:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80a87d:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80a882:	eb d9                	jmp    80a85d <thread_halt+0x72>

0080a884 <thread_entry>:
thread_entry(void) {
  80a884:	55                   	push   %ebp
  80a885:	89 e5                	mov    %esp,%ebp
  80a887:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a88a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a88f:	ff 70 2c             	pushl  0x2c(%eax)
  80a892:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a895:	e8 51 ff ff ff       	call   80a7eb <thread_halt>
}
  80a89a:	83 c4 10             	add    $0x10,%esp
  80a89d:	c9                   	leave  
  80a89e:	c3                   	ret    
  80a89f:	90                   	nop

0080a8a0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a8a0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a8a4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a8a7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a8a9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a8ad:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a8b0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a8b3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a8b6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a8b9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a8bc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a8c1:	c3                   	ret    
  80a8c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a8c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080a8d0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a8d0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a8d2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a8d5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a8d8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a8db:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a8de:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a8e1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a8e3:	ff e1                	jmp    *%ecx

0080a8e5 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a8e5:	55                   	push   %ebp
  80a8e6:	89 e5                	mov    %esp,%ebp
  80a8e8:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a8eb:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80a8f0:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80a8f7:	ff 75 08             	pushl  0x8(%ebp)
  80a8fa:	68 7f 26 81 00       	push   $0x81267f
  80a8ff:	e8 47 3d 00 00       	call   80e64b <cprintf>
}
  80a904:	83 c4 10             	add    $0x10,%esp
  80a907:	c9                   	leave  
  80a908:	c3                   	ret    

0080a909 <e2s>:
e2s(int err) {
  80a909:	55                   	push   %ebp
  80a90a:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a90c:	8b 45 08             	mov    0x8(%ebp),%eax
  80a90f:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a916:	5d                   	pop    %ebp
  80a917:	c3                   	ret    

0080a918 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a918:	55                   	push   %ebp
  80a919:	89 e5                	mov    %esp,%ebp
  80a91b:	57                   	push   %edi
  80a91c:	56                   	push   %esi
  80a91d:	53                   	push   %ebx
  80a91e:	83 ec 20             	sub    $0x20,%esp
  80a921:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a924:	6a 07                	push   $0x7
  80a926:	68 00 00 00 10       	push   $0x10000000
  80a92b:	6a 00                	push   $0x0
  80a92d:	e8 e7 46 00 00       	call   80f019 <sys_page_alloc>
    if (r < 0)
  80a932:	83 c4 10             	add    $0x10,%esp
  80a935:	85 c0                	test   %eax,%eax
  80a937:	78 49                	js     80a982 <low_level_output+0x6a>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a939:	8b 45 08             	mov    0x8(%ebp),%eax
  80a93c:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a93f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80a942:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80a947:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a94c:	85 db                	test   %ebx,%ebx
  80a94e:	74 5c                	je     80a9ac <low_level_output+0x94>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a950:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a954:	0f b7 d0             	movzwl %ax,%edx
  80a957:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80a95a:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80a960:	7f 34                	jg     80a996 <low_level_output+0x7e>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80a962:	83 ec 04             	sub    $0x4,%esp
  80a965:	0f b7 c0             	movzwl %ax,%eax
  80a968:	50                   	push   %eax
  80a969:	ff 73 04             	pushl  0x4(%ebx)
  80a96c:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80a96f:	50                   	push   %eax
  80a970:	e8 a2 44 00 00       	call   80ee17 <memcpy>
	txsize += q->len;
  80a975:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a979:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80a97b:	8b 1b                	mov    (%ebx),%ebx
  80a97d:	83 c4 10             	add    $0x10,%esp
  80a980:	eb ca                	jmp    80a94c <low_level_output+0x34>
	panic("jif: could not allocate page of memory");
  80a982:	83 ec 04             	sub    $0x4,%esp
  80a985:	68 64 2b 81 00       	push   $0x812b64
  80a98a:	6a 55                	push   $0x55
  80a98c:	68 b5 2b 81 00       	push   $0x812bb5
  80a991:	e8 da 3b 00 00       	call   80e570 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80a996:	83 ec 0c             	sub    $0xc,%esp
  80a999:	56                   	push   %esi
  80a99a:	52                   	push   %edx
  80a99b:	68 8c 2b 81 00       	push   $0x812b8c
  80a9a0:	6a 64                	push   $0x64
  80a9a2:	68 b5 2b 81 00       	push   $0x812bb5
  80a9a7:	e8 c4 3b 00 00       	call   80e570 <_panic>
    }

    pkt->jp_len = txsize;
  80a9ac:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80a9b2:	6a 07                	push   $0x7
  80a9b4:	68 00 00 00 10       	push   $0x10000000
  80a9b9:	6a 0b                	push   $0xb
  80a9bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a9be:	ff 70 04             	pushl  0x4(%eax)
  80a9c1:	e8 7b 4c 00 00       	call   80f641 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80a9c6:	83 c4 08             	add    $0x8,%esp
  80a9c9:	68 00 00 00 10       	push   $0x10000000
  80a9ce:	6a 00                	push   $0x0
  80a9d0:	e8 c9 46 00 00       	call   80f09e <sys_page_unmap>

    return ERR_OK;
}
  80a9d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80a9da:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a9dd:	5b                   	pop    %ebx
  80a9de:	5e                   	pop    %esi
  80a9df:	5f                   	pop    %edi
  80a9e0:	5d                   	pop    %ebp
  80a9e1:	c3                   	ret    

0080a9e2 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80a9e2:	55                   	push   %ebp
  80a9e3:	89 e5                	mov    %esp,%ebp
  80a9e5:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80a9e8:	ff 75 10             	pushl  0x10(%ebp)
  80a9eb:	ff 75 0c             	pushl  0xc(%ebp)
  80a9ee:	ff 75 08             	pushl  0x8(%ebp)
  80a9f1:	e8 0f f1 ff ff       	call   809b05 <etharp_output>
}
  80a9f6:	c9                   	leave  
  80a9f7:	c3                   	ret    

0080a9f8 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80a9f8:	55                   	push   %ebp
  80a9f9:	89 e5                	mov    %esp,%ebp
  80a9fb:	57                   	push   %edi
  80a9fc:	56                   	push   %esi
  80a9fd:	53                   	push   %ebx
  80a9fe:	83 ec 20             	sub    $0x20,%esp
  80aa01:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80aa04:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa07:	8b 40 1c             	mov    0x1c(%eax),%eax
  80aa0a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80aa0d:	8b 06                	mov    (%esi),%eax
  80aa0f:	89 c3                	mov    %eax,%ebx
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80aa11:	6a 03                	push   $0x3
  80aa13:	0f b7 c0             	movzwl %ax,%eax
  80aa16:	50                   	push   %eax
  80aa17:	6a 03                	push   $0x3
  80aa19:	e8 8b 9e ff ff       	call   8048a9 <pbuf_alloc>
    if (p == 0)
  80aa1e:	83 c4 10             	add    $0x10,%esp
  80aa21:	85 c0                	test   %eax,%eax
  80aa23:	0f 84 9c 00 00 00    	je     80aac5 <jif_input+0xcd>
  80aa29:	89 c7                	mov    %eax,%edi
    void *rxbuf = (void *) pkt->jp_data;
  80aa2b:	8d 46 04             	lea    0x4(%esi),%eax
  80aa2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80aa31:	89 fe                	mov    %edi,%esi
    int copied = 0;
  80aa33:	ba 00 00 00 00       	mov    $0x0,%edx
	if (bytes > (len - copied))
  80aa38:	0f bf c3             	movswl %bx,%eax
  80aa3b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80aa3e:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80aa41:	89 d7                	mov    %edx,%edi
	int bytes = q->len;
  80aa43:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (bytes > (len - copied))
  80aa47:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80aa4a:	29 fb                	sub    %edi,%ebx
  80aa4c:	39 c3                	cmp    %eax,%ebx
  80aa4e:	0f 4f d8             	cmovg  %eax,%ebx
	memcpy(q->payload, rxbuf + copied, bytes);
  80aa51:	83 ec 04             	sub    $0x4,%esp
  80aa54:	53                   	push   %ebx
  80aa55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aa58:	01 f8                	add    %edi,%eax
  80aa5a:	50                   	push   %eax
  80aa5b:	ff 76 04             	pushl  0x4(%esi)
  80aa5e:	e8 b4 43 00 00       	call   80ee17 <memcpy>
	copied += bytes;
  80aa63:	01 df                	add    %ebx,%edi
    for (q = p; q != NULL; q = q->next) {
  80aa65:	8b 36                	mov    (%esi),%esi
  80aa67:	83 c4 10             	add    $0x10,%esp
  80aa6a:	85 f6                	test   %esi,%esi
  80aa6c:	75 d5                	jne    80aa43 <jif_input+0x4b>
  80aa6e:	8b 7d dc             	mov    -0x24(%ebp),%edi
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80aa71:	83 ec 0c             	sub    $0xc,%esp
  80aa74:	8b 47 04             	mov    0x4(%edi),%eax
  80aa77:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80aa7b:	50                   	push   %eax
  80aa7c:	e8 44 cc ff ff       	call   8076c5 <htons>
  80aa81:	83 c4 10             	add    $0x10,%esp
  80aa84:	66 3d 00 08          	cmp    $0x800,%ax
  80aa88:	74 14                	je     80aa9e <jif_input+0xa6>
  80aa8a:	66 3d 06 08          	cmp    $0x806,%ax
  80aa8e:	74 3d                	je     80aacd <jif_input+0xd5>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80aa90:	83 ec 0c             	sub    $0xc,%esp
  80aa93:	57                   	push   %edi
  80aa94:	e8 4a 9d ff ff       	call   8047e3 <pbuf_free>
  80aa99:	83 c4 10             	add    $0x10,%esp
  80aa9c:	eb 27                	jmp    80aac5 <jif_input+0xcd>
	etharp_ip_input(netif, p);
  80aa9e:	83 ec 08             	sub    $0x8,%esp
  80aaa1:	57                   	push   %edi
  80aaa2:	ff 75 08             	pushl  0x8(%ebp)
  80aaa5:	e8 d3 ea ff ff       	call   80957d <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80aaaa:	83 c4 08             	add    $0x8,%esp
  80aaad:	6a f2                	push   $0xfffffff2
  80aaaf:	57                   	push   %edi
  80aab0:	e8 61 9c ff ff       	call   804716 <pbuf_header>
	netif->input(p, netif);
  80aab5:	83 c4 08             	add    $0x8,%esp
  80aab8:	ff 75 08             	pushl  0x8(%ebp)
  80aabb:	57                   	push   %edi
  80aabc:	8b 45 08             	mov    0x8(%ebp),%eax
  80aabf:	ff 50 10             	call   *0x10(%eax)
	break;
  80aac2:	83 c4 10             	add    $0x10,%esp
    }
}
  80aac5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aac8:	5b                   	pop    %ebx
  80aac9:	5e                   	pop    %esi
  80aaca:	5f                   	pop    %edi
  80aacb:	5d                   	pop    %ebp
  80aacc:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80aacd:	83 ec 04             	sub    $0x4,%esp
  80aad0:	57                   	push   %edi
  80aad1:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80aad4:	ff 30                	pushl  (%eax)
  80aad6:	ff 75 08             	pushl  0x8(%ebp)
  80aad9:	e8 eb ea ff ff       	call   8095c9 <etharp_arp_input>
	break;
  80aade:	83 c4 10             	add    $0x10,%esp
  80aae1:	eb e2                	jmp    80aac5 <jif_input+0xcd>

0080aae3 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80aae3:	55                   	push   %ebp
  80aae4:	89 e5                	mov    %esp,%ebp
  80aae6:	57                   	push   %edi
  80aae7:	56                   	push   %esi
  80aae8:	53                   	push   %ebx
  80aae9:	83 ec 28             	sub    $0x28,%esp
  80aaec:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80aaef:	6a 08                	push   $0x8
  80aaf1:	e8 f3 96 ff ff       	call   8041e9 <mem_malloc>

    if (jif == NULL) {
  80aaf6:	83 c4 10             	add    $0x10,%esp
  80aaf9:	85 c0                	test   %eax,%eax
  80aafb:	0f 84 87 00 00 00    	je     80ab88 <jif_init+0xa5>
  80ab01:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80ab03:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80ab06:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80ab09:	c7 43 14 e2 a9 80 00 	movl   $0x80a9e2,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80ab10:	c7 43 18 18 a9 80 00 	movl   $0x80a918,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ab17:	83 ec 04             	sub    $0x4,%esp
  80ab1a:	6a 02                	push   $0x2
  80ab1c:	68 ab 39 81 00       	push   $0x8139ab
  80ab21:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ab24:	50                   	push   %eax
  80ab25:	e8 ed 42 00 00       	call   80ee17 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80ab2a:	8d 43 25             	lea    0x25(%ebx),%eax
  80ab2d:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80ab2f:	8b 07                	mov    (%edi),%eax
  80ab31:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80ab34:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80ab38:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80ab3e:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80ab42:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80ab46:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80ab4a:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80ab4e:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80ab52:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80ab56:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80ab5a:	c7 04 24 cb 0f 81 00 	movl   $0x810fcb,(%esp)
  80ab61:	e8 6e cd ff ff       	call   8078d4 <inet_addr>
  80ab66:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80ab69:	83 c4 0c             	add    $0xc,%esp
  80ab6c:	6a 00                	push   $0x0
  80ab6e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab71:	50                   	push   %eax
  80ab72:	53                   	push   %ebx
  80ab73:	e8 57 ed ff ff       	call   8098cf <etharp_query>

    return ERR_OK;
  80ab78:	83 c4 10             	add    $0x10,%esp
  80ab7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ab80:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ab83:	5b                   	pop    %ebx
  80ab84:	5e                   	pop    %esi
  80ab85:	5f                   	pop    %edi
  80ab86:	5d                   	pop    %ebp
  80ab87:	c3                   	ret    
	return ERR_MEM;
  80ab88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ab8d:	eb f1                	jmp    80ab80 <jif_init+0x9d>

0080ab8f <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ab8f:	55                   	push   %ebp
  80ab90:	89 e5                	mov    %esp,%ebp
  80ab92:	56                   	push   %esi
  80ab93:	53                   	push   %ebx
  80ab94:	83 ec 28             	sub    $0x28,%esp
  80ab97:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ab9a:	ff 75 10             	pushl  0x10(%ebp)
  80ab9d:	ff 75 08             	pushl  0x8(%ebp)
  80aba0:	e8 49 0f 00 00       	call   80baee <netconn_alloc>
  80aba5:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80aba7:	83 c4 10             	add    $0x10,%esp
  80abaa:	85 c0                	test   %eax,%eax
  80abac:	74 65                	je     80ac13 <netconn_new_with_proto_and_callback+0x84>
    msg.function = do_newconn;
  80abae:	c7 45 e4 e5 b9 80 00 	movl   $0x80b9e5,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80abb5:	89 f0                	mov    %esi,%eax
  80abb7:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80abba:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80abbd:	83 ec 0c             	sub    $0xc,%esp
  80abc0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80abc3:	50                   	push   %eax
  80abc4:	e8 89 77 ff ff       	call   802352 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80abc9:	83 c4 10             	add    $0x10,%esp
  80abcc:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80abd0:	74 41                	je     80ac13 <netconn_new_with_proto_and_callback+0x84>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80abd2:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80abd6:	75 44                	jne    80ac1c <netconn_new_with_proto_and_callback+0x8d>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80abd8:	8b 43 10             	mov    0x10(%ebx),%eax
  80abdb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80abde:	74 50                	je     80ac30 <netconn_new_with_proto_and_callback+0xa1>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80abe0:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80abe4:	74 5e                	je     80ac44 <netconn_new_with_proto_and_callback+0xb5>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80abe6:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80abea:	75 6c                	jne    80ac58 <netconn_new_with_proto_and_callback+0xc9>
      sys_sem_free(conn->op_completed);
  80abec:	83 ec 0c             	sub    $0xc,%esp
  80abef:	50                   	push   %eax
  80abf0:	e8 2d f2 ff ff       	call   809e22 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80abf5:	83 c4 04             	add    $0x4,%esp
  80abf8:	ff 73 14             	pushl  0x14(%ebx)
  80abfb:	e8 ab f2 ff ff       	call   809eab <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ac00:	83 c4 08             	add    $0x8,%esp
  80ac03:	53                   	push   %ebx
  80ac04:	6a 07                	push   $0x7
  80ac06:	e8 88 98 ff ff       	call   804493 <memp_free>
      return NULL;
  80ac0b:	83 c4 10             	add    $0x10,%esp
  80ac0e:	bb 00 00 00 00       	mov    $0x0,%ebx
    }
  }
  return conn;
}
  80ac13:	89 d8                	mov    %ebx,%eax
  80ac15:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ac18:	5b                   	pop    %ebx
  80ac19:	5e                   	pop    %esi
  80ac1a:	5d                   	pop    %ebp
  80ac1b:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ac1c:	83 ec 04             	sub    $0x4,%esp
  80ac1f:	68 cc 2b 81 00       	push   $0x812bcc
  80ac24:	6a 52                	push   $0x52
  80ac26:	68 7e 2c 81 00       	push   $0x812c7e
  80ac2b:	e8 40 39 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ac30:	83 ec 04             	sub    $0x4,%esp
  80ac33:	68 95 2c 81 00       	push   $0x812c95
  80ac38:	6a 53                	push   $0x53
  80ac3a:	68 7e 2c 81 00       	push   $0x812c7e
  80ac3f:	e8 2c 39 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ac44:	83 ec 04             	sub    $0x4,%esp
  80ac47:	68 ae 2c 81 00       	push   $0x812cae
  80ac4c:	6a 54                	push   $0x54
  80ac4e:	68 7e 2c 81 00       	push   $0x812c7e
  80ac53:	e8 18 39 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ac58:	83 ec 04             	sub    $0x4,%esp
  80ac5b:	68 f0 2b 81 00       	push   $0x812bf0
  80ac60:	6a 55                	push   $0x55
  80ac62:	68 7e 2c 81 00       	push   $0x812c7e
  80ac67:	e8 04 39 00 00       	call   80e570 <_panic>

0080ac6c <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ac6c:	55                   	push   %ebp
  80ac6d:	89 e5                	mov    %esp,%ebp
  80ac6f:	53                   	push   %ebx
  80ac70:	83 ec 24             	sub    $0x24,%esp
  80ac73:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ac76:	85 db                	test   %ebx,%ebx
  80ac78:	74 28                	je     80aca2 <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ac7a:	c7 45 e4 2d bd 80 00 	movl   $0x80bd2d,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac81:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ac84:	83 ec 0c             	sub    $0xc,%esp
  80ac87:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac8a:	50                   	push   %eax
  80ac8b:	e8 c2 76 ff ff       	call   802352 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ac90:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ac97:	89 1c 24             	mov    %ebx,(%esp)
  80ac9a:	e8 fd 0e 00 00       	call   80bb9c <netconn_free>

  return ERR_OK;
  80ac9f:	83 c4 10             	add    $0x10,%esp
}
  80aca2:	b8 00 00 00 00       	mov    $0x0,%eax
  80aca7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80acaa:	c9                   	leave  
  80acab:	c3                   	ret    

0080acac <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80acac:	55                   	push   %ebp
  80acad:	89 e5                	mov    %esp,%ebp
  80acaf:	83 ec 08             	sub    $0x8,%esp
  80acb2:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80acb5:	85 c0                	test   %eax,%eax
  80acb7:	74 04                	je     80acbd <netconn_type+0x11>
  80acb9:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80acbb:	c9                   	leave  
  80acbc:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80acbd:	83 ec 04             	sub    $0x4,%esp
  80acc0:	68 c3 2c 81 00       	push   $0x812cc3
  80acc5:	68 84 00 00 00       	push   $0x84
  80acca:	68 7e 2c 81 00       	push   $0x812c7e
  80accf:	e8 9c 38 00 00       	call   80e570 <_panic>

0080acd4 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80acd4:	55                   	push   %ebp
  80acd5:	89 e5                	mov    %esp,%ebp
  80acd7:	53                   	push   %ebx
  80acd8:	83 ec 24             	sub    $0x24,%esp
  80acdb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80acde:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ace1:	8b 45 10             	mov    0x10(%ebp),%eax
  80ace4:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ace7:	85 db                	test   %ebx,%ebx
  80ace9:	74 30                	je     80ad1b <netconn_getaddr+0x47>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80aceb:	85 d2                	test   %edx,%edx
  80aced:	74 43                	je     80ad32 <netconn_getaddr+0x5e>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80acef:	85 c0                	test   %eax,%eax
  80acf1:	74 56                	je     80ad49 <netconn_getaddr+0x75>

  msg.function = do_getaddr;
  80acf3:	c7 45 e4 7c c1 80 00 	movl   $0x80c17c,-0x1c(%ebp)
  msg.msg.conn = conn;
  80acfa:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80acfd:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80ad00:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80ad03:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80ad06:	83 ec 0c             	sub    $0xc,%esp
  80ad09:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad0c:	50                   	push   %eax
  80ad0d:	e8 40 76 ff ff       	call   802352 <tcpip_apimsg>

  return conn->err;
  80ad12:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad16:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad19:	c9                   	leave  
  80ad1a:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad1b:	83 ec 04             	sub    $0x4,%esp
  80ad1e:	68 de 2c 81 00       	push   $0x812cde
  80ad23:	68 98 00 00 00       	push   $0x98
  80ad28:	68 7e 2c 81 00       	push   $0x812c7e
  80ad2d:	e8 3e 38 00 00       	call   80e570 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80ad32:	83 ec 04             	sub    $0x4,%esp
  80ad35:	68 fc 2c 81 00       	push   $0x812cfc
  80ad3a:	68 99 00 00 00       	push   $0x99
  80ad3f:	68 7e 2c 81 00       	push   $0x812c7e
  80ad44:	e8 27 38 00 00       	call   80e570 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ad49:	83 ec 04             	sub    $0x4,%esp
  80ad4c:	68 1a 2d 81 00       	push   $0x812d1a
  80ad51:	68 9a 00 00 00       	push   $0x9a
  80ad56:	68 7e 2c 81 00       	push   $0x812c7e
  80ad5b:	e8 10 38 00 00       	call   80e570 <_panic>

0080ad60 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad60:	55                   	push   %ebp
  80ad61:	89 e5                	mov    %esp,%ebp
  80ad63:	53                   	push   %ebx
  80ad64:	83 ec 24             	sub    $0x24,%esp
  80ad67:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad6a:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad6d:	85 db                	test   %ebx,%ebx
  80ad6f:	74 29                	je     80ad9a <netconn_bind+0x3a>

  msg.function = do_bind;
  80ad71:	c7 45 e4 d6 bd 80 00 	movl   $0x80bdd6,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad78:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ad7b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad7e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ad81:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ad85:	83 ec 0c             	sub    $0xc,%esp
  80ad88:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad8b:	50                   	push   %eax
  80ad8c:	e8 c1 75 ff ff       	call   802352 <tcpip_apimsg>
  return conn->err;
  80ad91:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad95:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad98:	c9                   	leave  
  80ad99:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad9a:	83 ec 04             	sub    $0x4,%esp
  80ad9d:	68 38 2d 81 00       	push   $0x812d38
  80ada2:	68 b5 00 00 00       	push   $0xb5
  80ada7:	68 7e 2c 81 00       	push   $0x812c7e
  80adac:	e8 bf 37 00 00       	call   80e570 <_panic>

0080adb1 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80adb1:	55                   	push   %ebp
  80adb2:	89 e5                	mov    %esp,%ebp
  80adb4:	53                   	push   %ebx
  80adb5:	83 ec 24             	sub    $0x24,%esp
  80adb8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80adbb:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80adbe:	85 db                	test   %ebx,%ebx
  80adc0:	74 29                	je     80adeb <netconn_connect+0x3a>

  msg.function = do_connect;
  80adc2:	c7 45 e4 66 be 80 00 	movl   $0x80be66,-0x1c(%ebp)
  msg.msg.conn = conn;
  80adc9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80adcc:	8b 55 0c             	mov    0xc(%ebp),%edx
  80adcf:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80add2:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80add6:	83 ec 0c             	sub    $0xc,%esp
  80add9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80addc:	50                   	push   %eax
  80addd:	e8 70 75 ff ff       	call   802352 <tcpip_apimsg>
  return conn->err;
  80ade2:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ade6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ade9:	c9                   	leave  
  80adea:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80adeb:	83 ec 04             	sub    $0x4,%esp
  80adee:	68 53 2d 81 00       	push   $0x812d53
  80adf3:	68 cc 00 00 00       	push   $0xcc
  80adf8:	68 7e 2c 81 00       	push   $0x812c7e
  80adfd:	e8 6e 37 00 00       	call   80e570 <_panic>

0080ae02 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80ae02:	55                   	push   %ebp
  80ae03:	89 e5                	mov    %esp,%ebp
  80ae05:	53                   	push   %ebx
  80ae06:	83 ec 24             	sub    $0x24,%esp
  80ae09:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae0c:	85 db                	test   %ebx,%ebx
  80ae0e:	74 1f                	je     80ae2f <netconn_disconnect+0x2d>

  msg.function = do_disconnect;
  80ae10:	c7 45 e4 1b bf 80 00 	movl   $0x80bf1b,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae17:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80ae1a:	83 ec 0c             	sub    $0xc,%esp
  80ae1d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae20:	50                   	push   %eax
  80ae21:	e8 2c 75 ff ff       	call   802352 <tcpip_apimsg>
  return conn->err;
  80ae26:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae2a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae2d:	c9                   	leave  
  80ae2e:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae2f:	83 ec 04             	sub    $0x4,%esp
  80ae32:	68 14 2c 81 00       	push   $0x812c14
  80ae37:	68 e2 00 00 00       	push   $0xe2
  80ae3c:	68 7e 2c 81 00       	push   $0x812c7e
  80ae41:	e8 2a 37 00 00       	call   80e570 <_panic>

0080ae46 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80ae46:	55                   	push   %ebp
  80ae47:	89 e5                	mov    %esp,%ebp
  80ae49:	53                   	push   %ebx
  80ae4a:	83 ec 24             	sub    $0x24,%esp
  80ae4d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae50:	85 db                	test   %ebx,%ebx
  80ae52:	74 1f                	je     80ae73 <netconn_listen_with_backlog+0x2d>

  msg.function = do_listen;
  80ae54:	c7 45 e4 58 bf 80 00 	movl   $0x80bf58,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae5b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80ae5e:	83 ec 0c             	sub    $0xc,%esp
  80ae61:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae64:	50                   	push   %eax
  80ae65:	e8 e8 74 ff ff       	call   802352 <tcpip_apimsg>
  return conn->err;
  80ae6a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae6e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae71:	c9                   	leave  
  80ae72:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae73:	83 ec 04             	sub    $0x4,%esp
  80ae76:	68 71 2d 81 00       	push   $0x812d71
  80ae7b:	68 fa 00 00 00       	push   $0xfa
  80ae80:	68 7e 2c 81 00       	push   $0x812c7e
  80ae85:	e8 e6 36 00 00       	call   80e570 <_panic>

0080ae8a <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80ae8a:	55                   	push   %ebp
  80ae8b:	89 e5                	mov    %esp,%ebp
  80ae8d:	53                   	push   %ebx
  80ae8e:	83 ec 14             	sub    $0x14,%esp
  80ae91:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80ae94:	85 db                	test   %ebx,%ebx
  80ae96:	74 36                	je     80aece <netconn_accept+0x44>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ae98:	8b 43 18             	mov    0x18(%ebx),%eax
  80ae9b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae9e:	74 45                	je     80aee5 <netconn_accept+0x5b>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80aea0:	83 ec 04             	sub    $0x4,%esp
  80aea3:	6a 00                	push   $0x0
  80aea5:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80aea8:	52                   	push   %edx
  80aea9:	50                   	push   %eax
  80aeaa:	e8 24 f4 ff ff       	call   80a2d3 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80aeaf:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80aeb2:	83 c4 10             	add    $0x10,%esp
  80aeb5:	85 c0                	test   %eax,%eax
  80aeb7:	74 0d                	je     80aec6 <netconn_accept+0x3c>
  80aeb9:	83 ec 04             	sub    $0x4,%esp
  80aebc:	6a 00                	push   $0x0
  80aebe:	6a 01                	push   $0x1
  80aec0:	53                   	push   %ebx
  80aec1:	ff d0                	call   *%eax
  80aec3:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80aec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80aec9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aecc:	c9                   	leave  
  80aecd:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80aece:	83 ec 04             	sub    $0x4,%esp
  80aed1:	68 8e 2d 81 00       	push   $0x812d8e
  80aed6:	68 10 01 00 00       	push   $0x110
  80aedb:	68 7e 2c 81 00       	push   $0x812c7e
  80aee0:	e8 8b 36 00 00       	call   80e570 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80aee5:	83 ec 04             	sub    $0x4,%esp
  80aee8:	68 38 2c 81 00       	push   $0x812c38
  80aeed:	68 11 01 00 00       	push   $0x111
  80aef2:	68 7e 2c 81 00       	push   $0x812c7e
  80aef7:	e8 74 36 00 00       	call   80e570 <_panic>

0080aefc <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80aefc:	55                   	push   %ebp
  80aefd:	89 e5                	mov    %esp,%ebp
  80aeff:	53                   	push   %ebx
  80af00:	83 ec 24             	sub    $0x24,%esp
  80af03:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80af06:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80af0d:	85 db                	test   %ebx,%ebx
  80af0f:	0f 84 cc 00 00 00    	je     80afe1 <netconn_recv+0xe5>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80af15:	8b 43 14             	mov    0x14(%ebx),%eax
  80af18:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af1b:	0f 84 d7 00 00 00    	je     80aff8 <netconn_recv+0xfc>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80af21:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80af25:	0f 8c 27 01 00 00    	jl     80b052 <netconn_recv+0x156>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80af2b:	83 3b 10             	cmpl   $0x10,(%ebx)
  80af2e:	0f 85 e0 00 00 00    	jne    80b014 <netconn_recv+0x118>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80af34:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80af38:	0f 84 c5 00 00 00    	je     80b003 <netconn_recv+0x107>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80af3e:	83 ec 0c             	sub    $0xc,%esp
  80af41:	6a 06                	push   $0x6
  80af43:	e8 f5 94 ff ff       	call   80443d <memp_malloc>
  80af48:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80af4b:	83 c4 10             	add    $0x10,%esp
  80af4e:	85 c0                	test   %eax,%eax
  80af50:	0f 84 b8 00 00 00    	je     80b00e <netconn_recv+0x112>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80af56:	83 ec 04             	sub    $0x4,%esp
  80af59:	6a 00                	push   $0x0
  80af5b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80af5e:	50                   	push   %eax
  80af5f:	ff 73 14             	pushl  0x14(%ebx)
  80af62:	e8 6c f3 ff ff       	call   80a2d3 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80af67:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af6a:	83 c4 10             	add    $0x10,%esp
  80af6d:	85 c0                	test   %eax,%eax
  80af6f:	0f 84 e4 00 00 00    	je     80b059 <netconn_recv+0x15d>
      len = p->tot_len;
  80af75:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80af79:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af7d:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80af80:	85 c9                	test   %ecx,%ecx
  80af82:	74 1a                	je     80af9e <netconn_recv+0xa2>
  80af84:	83 ec 04             	sub    $0x4,%esp
  80af87:	0f b7 d2             	movzwl %dx,%edx
  80af8a:	52                   	push   %edx
  80af8b:	6a 01                	push   $0x1
  80af8d:	53                   	push   %ebx
  80af8e:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80af90:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af93:	83 c4 10             	add    $0x10,%esp
  80af96:	85 c0                	test   %eax,%eax
  80af98:	0f 84 cb 00 00 00    	je     80b069 <netconn_recv+0x16d>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80af9e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80afa1:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80afa3:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80afa6:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80afa9:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80afaf:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80afb6:	c7 45 e4 e6 c0 80 00 	movl   $0x80c0e6,-0x1c(%ebp)
    msg.msg.conn = conn;
  80afbd:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80afc0:	8b 02                	mov    (%edx),%eax
  80afc2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80afc6:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80afca:	83 ec 0c             	sub    $0xc,%esp
  80afcd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afd0:	50                   	push   %eax
  80afd1:	e8 7c 73 ff ff       	call   802352 <tcpip_apimsg>
  80afd6:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80afd9:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80afdc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afdf:	c9                   	leave  
  80afe0:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80afe1:	83 ec 04             	sub    $0x4,%esp
  80afe4:	68 ab 2d 81 00       	push   $0x812dab
  80afe9:	68 3a 01 00 00       	push   $0x13a
  80afee:	68 7e 2c 81 00       	push   $0x812c7e
  80aff3:	e8 78 35 00 00       	call   80e570 <_panic>
    conn->err = ERR_CONN;
  80aff8:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80affc:	b8 00 00 00 00       	mov    $0x0,%eax
  80b001:	eb d9                	jmp    80afdc <netconn_recv+0xe0>
      conn->err = ERR_CONN;
  80b003:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b007:	b8 00 00 00 00       	mov    $0x0,%eax
  80b00c:	eb ce                	jmp    80afdc <netconn_recv+0xe0>
      conn->err = ERR_MEM;
  80b00e:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b012:	eb c8                	jmp    80afdc <netconn_recv+0xe0>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b014:	83 ec 04             	sub    $0x4,%esp
  80b017:	6a 00                	push   $0x0
  80b019:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b01c:	52                   	push   %edx
  80b01d:	50                   	push   %eax
  80b01e:	e8 b0 f2 ff ff       	call   80a2d3 <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b023:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b026:	83 c4 10             	add    $0x10,%esp
  80b029:	85 c0                	test   %eax,%eax
  80b02b:	74 ac                	je     80afd9 <netconn_recv+0xdd>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b02d:	8b 10                	mov    (%eax),%edx
  80b02f:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b033:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b037:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b03a:	85 d2                	test   %edx,%edx
  80b03c:	74 9b                	je     80afd9 <netconn_recv+0xdd>
  80b03e:	83 ec 04             	sub    $0x4,%esp
  80b041:	8b 00                	mov    (%eax),%eax
  80b043:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b047:	50                   	push   %eax
  80b048:	6a 01                	push   $0x1
  80b04a:	53                   	push   %ebx
  80b04b:	ff d2                	call   *%edx
  80b04d:	83 c4 10             	add    $0x10,%esp
  80b050:	eb 87                	jmp    80afd9 <netconn_recv+0xdd>
    return NULL;
  80b052:	b8 00 00 00 00       	mov    $0x0,%eax
  80b057:	eb 83                	jmp    80afdc <netconn_recv+0xe0>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b059:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b05c:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b061:	85 c9                	test   %ecx,%ecx
  80b063:	0f 85 1b ff ff ff    	jne    80af84 <netconn_recv+0x88>
      memp_free(MEMP_NETBUF, buf);
  80b069:	83 ec 08             	sub    $0x8,%esp
  80b06c:	ff 75 e0             	pushl  -0x20(%ebp)
  80b06f:	6a 06                	push   $0x6
  80b071:	e8 1d 94 ff ff       	call   804493 <memp_free>
      if (conn->err == ERR_OK) {
  80b076:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b079:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b07e:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b082:	0f 85 54 ff ff ff    	jne    80afdc <netconn_recv+0xe0>
        conn->err = ERR_CLSD;
  80b088:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b08c:	e9 4b ff ff ff       	jmp    80afdc <netconn_recv+0xe0>

0080b091 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b091:	55                   	push   %ebp
  80b092:	89 e5                	mov    %esp,%ebp
  80b094:	53                   	push   %ebx
  80b095:	83 ec 24             	sub    $0x24,%esp
  80b098:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b09b:	85 db                	test   %ebx,%ebx
  80b09d:	74 25                	je     80b0c4 <netconn_send+0x33>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b09f:	c7 45 e4 40 c0 80 00 	movl   $0x80c040,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b0a6:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b0a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b0ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b0af:	83 ec 0c             	sub    $0xc,%esp
  80b0b2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b0b5:	50                   	push   %eax
  80b0b6:	e8 97 72 ff ff       	call   802352 <tcpip_apimsg>
  return conn->err;
  80b0bb:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b0bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0c2:	c9                   	leave  
  80b0c3:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b0c4:	83 ec 04             	sub    $0x4,%esp
  80b0c7:	68 c6 2d 81 00       	push   $0x812dc6
  80b0cc:	68 b9 01 00 00       	push   $0x1b9
  80b0d1:	68 7e 2c 81 00       	push   $0x812c7e
  80b0d6:	e8 95 34 00 00       	call   80e570 <_panic>

0080b0db <netconn_sendto>:
{
  80b0db:	55                   	push   %ebp
  80b0dc:	89 e5                	mov    %esp,%ebp
  80b0de:	83 ec 08             	sub    $0x8,%esp
  80b0e1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b0e4:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b0e7:	85 c0                	test   %eax,%eax
  80b0e9:	74 1b                	je     80b106 <netconn_sendto+0x2b>
    buf->addr = addr;
  80b0eb:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b0ee:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b0f1:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b0f5:	83 ec 08             	sub    $0x8,%esp
  80b0f8:	50                   	push   %eax
  80b0f9:	ff 75 08             	pushl  0x8(%ebp)
  80b0fc:	e8 90 ff ff ff       	call   80b091 <netconn_send>
  80b101:	83 c4 10             	add    $0x10,%esp
}
  80b104:	c9                   	leave  
  80b105:	c3                   	ret    
  return ERR_VAL;
  80b106:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b10b:	eb f7                	jmp    80b104 <netconn_sendto+0x29>

0080b10d <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b10d:	55                   	push   %ebp
  80b10e:	89 e5                	mov    %esp,%ebp
  80b110:	53                   	push   %ebx
  80b111:	83 ec 24             	sub    $0x24,%esp
  80b114:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b117:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b11a:	85 db                	test   %ebx,%ebx
  80b11c:	74 33                	je     80b151 <netconn_write+0x44>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b11e:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b121:	75 45                	jne    80b168 <netconn_write+0x5b>

  msg.function = do_write;
  80b123:	c7 45 e4 2c c1 80 00 	movl   $0x80c12c,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b12a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b12d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b130:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b133:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b136:	8b 45 10             	mov    0x10(%ebp),%eax
  80b139:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b13c:	83 ec 0c             	sub    $0xc,%esp
  80b13f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b142:	50                   	push   %eax
  80b143:	e8 0a 72 ff ff       	call   802352 <tcpip_apimsg>
  return conn->err;
  80b148:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b14c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b14f:	c9                   	leave  
  80b150:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b151:	83 ec 04             	sub    $0x4,%esp
  80b154:	68 e1 2d 81 00       	push   $0x812de1
  80b159:	68 d3 01 00 00       	push   $0x1d3
  80b15e:	68 7e 2c 81 00       	push   $0x812c7e
  80b163:	e8 08 34 00 00       	call   80e570 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b168:	83 ec 04             	sub    $0x4,%esp
  80b16b:	68 5c 2c 81 00       	push   $0x812c5c
  80b170:	68 d4 01 00 00       	push   $0x1d4
  80b175:	68 7e 2c 81 00       	push   $0x812c7e
  80b17a:	e8 f1 33 00 00       	call   80e570 <_panic>

0080b17f <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b17f:	55                   	push   %ebp
  80b180:	89 e5                	mov    %esp,%ebp
  80b182:	53                   	push   %ebx
  80b183:	83 ec 24             	sub    $0x24,%esp
  80b186:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b189:	85 db                	test   %ebx,%ebx
  80b18b:	74 1f                	je     80b1ac <netconn_close+0x2d>

  msg.function = do_close;
  80b18d:	c7 45 e4 43 c2 80 00 	movl   $0x80c243,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b194:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b197:	83 ec 0c             	sub    $0xc,%esp
  80b19a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b19d:	50                   	push   %eax
  80b19e:	e8 af 71 ff ff       	call   802352 <tcpip_apimsg>
  return conn->err;
  80b1a3:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b1a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b1aa:	c9                   	leave  
  80b1ab:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b1ac:	83 ec 04             	sub    $0x4,%esp
  80b1af:	68 fd 2d 81 00       	push   $0x812dfd
  80b1b4:	68 ed 01 00 00       	push   $0x1ed
  80b1b9:	68 7e 2c 81 00       	push   $0x812c7e
  80b1be:	e8 ad 33 00 00       	call   80e570 <_panic>

0080b1c3 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b1c3:	55                   	push   %ebp
  80b1c4:	89 e5                	mov    %esp,%ebp
  80b1c6:	56                   	push   %esi
  80b1c7:	53                   	push   %ebx
  80b1c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b1cb:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b1ce:	8b 75 10             	mov    0x10(%ebp),%esi
  80b1d1:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b1d4:	85 c0                	test   %eax,%eax
  80b1d6:	74 5a                	je     80b232 <recv_tcp+0x6f>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b1d8:	85 db                	test   %ebx,%ebx
  80b1da:	74 6d                	je     80b249 <recv_tcp+0x86>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b1dc:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b1df:	75 7f                	jne    80b260 <recv_tcp+0x9d>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b1e1:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b1e5:	0f 84 8c 00 00 00    	je     80b277 <recv_tcp+0xb4>
    return ERR_VAL;
  }

  conn->err = err;
  80b1eb:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b1ee:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b1f3:	85 f6                	test   %esi,%esi
  80b1f5:	74 08                	je     80b1ff <recv_tcp+0x3c>
    len = p->tot_len;
  80b1f7:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b1fb:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b1ff:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b202:	85 d2                	test   %edx,%edx
  80b204:	74 0f                	je     80b215 <recv_tcp+0x52>
  80b206:	83 ec 04             	sub    $0x4,%esp
  80b209:	0f b7 c0             	movzwl %ax,%eax
  80b20c:	50                   	push   %eax
  80b20d:	6a 00                	push   $0x0
  80b20f:	53                   	push   %ebx
  80b210:	ff d2                	call   *%edx
  80b212:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b215:	83 ec 08             	sub    $0x8,%esp
  80b218:	56                   	push   %esi
  80b219:	ff 73 14             	pushl  0x14(%ebx)
  80b21c:	e8 bd ef ff ff       	call   80a1de <sys_mbox_trypost>
  80b221:	83 c4 10             	add    $0x10,%esp
  80b224:	84 c0                	test   %al,%al
  80b226:	0f 95 c0             	setne  %al
  80b229:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b22b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b22e:	5b                   	pop    %ebx
  80b22f:	5e                   	pop    %esi
  80b230:	5d                   	pop    %ebp
  80b231:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b232:	83 ec 04             	sub    $0x4,%esp
  80b235:	68 1c 2e 81 00       	push   $0x812e1c
  80b23a:	68 c1 00 00 00       	push   $0xc1
  80b23f:	68 66 2f 81 00       	push   $0x812f66
  80b244:	e8 27 33 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b249:	83 ec 04             	sub    $0x4,%esp
  80b24c:	68 40 2e 81 00       	push   $0x812e40
  80b251:	68 c2 00 00 00       	push   $0xc2
  80b256:	68 66 2f 81 00       	push   $0x812f66
  80b25b:	e8 10 33 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b260:	83 ec 04             	sub    $0x4,%esp
  80b263:	68 7d 2f 81 00       	push   $0x812f7d
  80b268:	68 c4 00 00 00       	push   $0xc4
  80b26d:	68 66 2f 81 00       	push   $0x812f66
  80b272:	e8 f9 32 00 00       	call   80e570 <_panic>
    return ERR_VAL;
  80b277:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b27c:	eb ad                	jmp    80b22b <recv_tcp+0x68>

0080b27e <recv_udp>:
{
  80b27e:	55                   	push   %ebp
  80b27f:	89 e5                	mov    %esp,%ebp
  80b281:	57                   	push   %edi
  80b282:	56                   	push   %esi
  80b283:	53                   	push   %ebx
  80b284:	83 ec 1c             	sub    $0x1c,%esp
  80b287:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b28a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b28d:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b290:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b293:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b296:	85 c0                	test   %eax,%eax
  80b298:	74 7f                	je     80b319 <recv_udp+0x9b>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b29a:	85 db                	test   %ebx,%ebx
  80b29c:	0f 84 8e 00 00 00    	je     80b330 <recv_udp+0xb2>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b2a2:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b2a5:	0f 85 9c 00 00 00    	jne    80b347 <recv_udp+0xc9>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b2ab:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b2af:	0f 84 a9 00 00 00    	je     80b35e <recv_udp+0xe0>
  buf = memp_malloc(MEMP_NETBUF);
  80b2b5:	83 ec 0c             	sub    $0xc,%esp
  80b2b8:	6a 06                	push   $0x6
  80b2ba:	e8 7e 91 ff ff       	call   80443d <memp_malloc>
  80b2bf:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b2c1:	83 c4 10             	add    $0x10,%esp
  80b2c4:	85 c0                	test   %eax,%eax
  80b2c6:	0f 84 a0 00 00 00    	je     80b36c <recv_udp+0xee>
    buf->p = p;
  80b2cc:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b2ce:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b2d1:	8b 45 14             	mov    0x14(%ebp),%eax
  80b2d4:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b2d7:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b2db:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b2df:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b2e3:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b2e7:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b2ea:	85 c0                	test   %eax,%eax
  80b2ec:	74 10                	je     80b2fe <recv_udp+0x80>
  80b2ee:	83 ec 04             	sub    $0x4,%esp
  80b2f1:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b2f5:	52                   	push   %edx
  80b2f6:	6a 00                	push   $0x0
  80b2f8:	53                   	push   %ebx
  80b2f9:	ff d0                	call   *%eax
  80b2fb:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b2fe:	83 ec 08             	sub    $0x8,%esp
  80b301:	56                   	push   %esi
  80b302:	ff 73 14             	pushl  0x14(%ebx)
  80b305:	e8 d4 ee ff ff       	call   80a1de <sys_mbox_trypost>
  80b30a:	83 c4 10             	add    $0x10,%esp
  80b30d:	84 c0                	test   %al,%al
  80b30f:	75 69                	jne    80b37a <recv_udp+0xfc>
}
  80b311:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b314:	5b                   	pop    %ebx
  80b315:	5e                   	pop    %esi
  80b316:	5f                   	pop    %edi
  80b317:	5d                   	pop    %ebp
  80b318:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b319:	83 ec 04             	sub    $0x4,%esp
  80b31c:	68 60 2e 81 00       	push   $0x812e60
  80b321:	68 8e 00 00 00       	push   $0x8e
  80b326:	68 66 2f 81 00       	push   $0x812f66
  80b32b:	e8 40 32 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b330:	83 ec 04             	sub    $0x4,%esp
  80b333:	68 84 2e 81 00       	push   $0x812e84
  80b338:	68 8f 00 00 00       	push   $0x8f
  80b33d:	68 66 2f 81 00       	push   $0x812f66
  80b342:	e8 29 32 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b347:	83 ec 04             	sub    $0x4,%esp
  80b34a:	68 9b 2f 81 00       	push   $0x812f9b
  80b34f:	68 91 00 00 00       	push   $0x91
  80b354:	68 66 2f 81 00       	push   $0x812f66
  80b359:	e8 12 32 00 00       	call   80e570 <_panic>
    pbuf_free(p);
  80b35e:	83 ec 0c             	sub    $0xc,%esp
  80b361:	57                   	push   %edi
  80b362:	e8 7c 94 ff ff       	call   8047e3 <pbuf_free>
    return;
  80b367:	83 c4 10             	add    $0x10,%esp
  80b36a:	eb a5                	jmp    80b311 <recv_udp+0x93>
    pbuf_free(p);
  80b36c:	83 ec 0c             	sub    $0xc,%esp
  80b36f:	57                   	push   %edi
  80b370:	e8 6e 94 ff ff       	call   8047e3 <pbuf_free>
    return;
  80b375:	83 c4 10             	add    $0x10,%esp
  80b378:	eb 97                	jmp    80b311 <recv_udp+0x93>
    netbuf_delete(buf);
  80b37a:	83 ec 0c             	sub    $0xc,%esp
  80b37d:	56                   	push   %esi
  80b37e:	e8 bf 70 ff ff       	call   802442 <netbuf_delete>
    return;
  80b383:	83 c4 10             	add    $0x10,%esp
  80b386:	eb 89                	jmp    80b311 <recv_udp+0x93>

0080b388 <recv_raw>:
{
  80b388:	55                   	push   %ebp
  80b389:	89 e5                	mov    %esp,%ebp
  80b38b:	57                   	push   %edi
  80b38c:	56                   	push   %esi
  80b38d:	53                   	push   %ebx
  80b38e:	83 ec 0c             	sub    $0xc,%esp
  80b391:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b394:	85 db                	test   %ebx,%ebx
  80b396:	74 06                	je     80b39e <recv_raw+0x16>
  80b398:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b39c:	75 0d                	jne    80b3ab <recv_raw+0x23>
}
  80b39e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b3a6:	5b                   	pop    %ebx
  80b3a7:	5e                   	pop    %esi
  80b3a8:	5f                   	pop    %edi
  80b3a9:	5d                   	pop    %ebp
  80b3aa:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b3ab:	83 ec 04             	sub    $0x4,%esp
  80b3ae:	6a 00                	push   $0x0
  80b3b0:	8b 45 10             	mov    0x10(%ebp),%eax
  80b3b3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b3b7:	50                   	push   %eax
  80b3b8:	6a 03                	push   $0x3
  80b3ba:	e8 ea 94 ff ff       	call   8048a9 <pbuf_alloc>
  80b3bf:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b3c1:	83 c4 10             	add    $0x10,%esp
  80b3c4:	85 c0                	test   %eax,%eax
  80b3c6:	74 d6                	je     80b39e <recv_raw+0x16>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b3c8:	83 ec 08             	sub    $0x8,%esp
  80b3cb:	ff 75 10             	pushl  0x10(%ebp)
  80b3ce:	50                   	push   %eax
  80b3cf:	e8 b7 99 ff ff       	call   804d8b <pbuf_copy>
  80b3d4:	83 c4 10             	add    $0x10,%esp
  80b3d7:	84 c0                	test   %al,%al
  80b3d9:	75 73                	jne    80b44e <recv_raw+0xc6>
      buf = memp_malloc(MEMP_NETBUF);
  80b3db:	83 ec 0c             	sub    $0xc,%esp
  80b3de:	6a 06                	push   $0x6
  80b3e0:	e8 58 90 ff ff       	call   80443d <memp_malloc>
  80b3e5:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b3e7:	83 c4 10             	add    $0x10,%esp
  80b3ea:	85 c0                	test   %eax,%eax
  80b3ec:	74 71                	je     80b45f <recv_raw+0xd7>
      buf->p = q;
  80b3ee:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b3f0:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b3f3:	8b 46 04             	mov    0x4(%esi),%eax
  80b3f6:	83 c0 0c             	add    $0xc,%eax
  80b3f9:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b3fc:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b3ff:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b403:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b407:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b40b:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b40f:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b412:	85 c0                	test   %eax,%eax
  80b414:	74 10                	je     80b426 <recv_raw+0x9e>
  80b416:	83 ec 04             	sub    $0x4,%esp
  80b419:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b41d:	52                   	push   %edx
  80b41e:	6a 00                	push   $0x0
  80b420:	53                   	push   %ebx
  80b421:	ff d0                	call   *%eax
  80b423:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b426:	83 ec 08             	sub    $0x8,%esp
  80b429:	57                   	push   %edi
  80b42a:	ff 73 14             	pushl  0x14(%ebx)
  80b42d:	e8 ac ed ff ff       	call   80a1de <sys_mbox_trypost>
  80b432:	83 c4 10             	add    $0x10,%esp
  80b435:	84 c0                	test   %al,%al
  80b437:	0f 84 61 ff ff ff    	je     80b39e <recv_raw+0x16>
        netbuf_delete(buf);
  80b43d:	83 ec 0c             	sub    $0xc,%esp
  80b440:	57                   	push   %edi
  80b441:	e8 fc 6f ff ff       	call   802442 <netbuf_delete>
  80b446:	83 c4 10             	add    $0x10,%esp
  80b449:	e9 50 ff ff ff       	jmp    80b39e <recv_raw+0x16>
        pbuf_free(q);
  80b44e:	83 ec 0c             	sub    $0xc,%esp
  80b451:	56                   	push   %esi
  80b452:	e8 8c 93 ff ff       	call   8047e3 <pbuf_free>
  80b457:	83 c4 10             	add    $0x10,%esp
  80b45a:	e9 3f ff ff ff       	jmp    80b39e <recv_raw+0x16>
        pbuf_free(q);
  80b45f:	83 ec 0c             	sub    $0xc,%esp
  80b462:	56                   	push   %esi
  80b463:	e8 7b 93 ff ff       	call   8047e3 <pbuf_free>
        return 0;
  80b468:	83 c4 10             	add    $0x10,%esp
  80b46b:	e9 2e ff ff ff       	jmp    80b39e <recv_raw+0x16>

0080b470 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b470:	55                   	push   %ebp
  80b471:	89 e5                	mov    %esp,%ebp
  80b473:	53                   	push   %ebx
  80b474:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b477:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b47a:	50                   	push   %eax
  80b47b:	53                   	push   %ebx
  80b47c:	e8 36 a3 ff ff       	call   8057b7 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b481:	83 c4 08             	add    $0x8,%esp
  80b484:	68 c3 b1 80 00       	push   $0x80b1c3
  80b489:	53                   	push   %ebx
  80b48a:	e8 36 a3 ff ff       	call   8057c5 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b48f:	83 c4 08             	add    $0x8,%esp
  80b492:	68 52 b9 80 00       	push   $0x80b952
  80b497:	53                   	push   %ebx
  80b498:	e8 39 a3 ff ff       	call   8057d6 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b49d:	83 c4 0c             	add    $0xc,%esp
  80b4a0:	6a 04                	push   $0x4
  80b4a2:	68 0c b9 80 00       	push   $0x80b90c
  80b4a7:	53                   	push   %ebx
  80b4a8:	e8 59 a3 ff ff       	call   805806 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b4ad:	83 c4 08             	add    $0x8,%esp
  80b4b0:	68 0f b5 80 00       	push   $0x80b50f
  80b4b5:	53                   	push   %ebx
  80b4b6:	e8 2c a3 ff ff       	call   8057e7 <tcp_err>
}
  80b4bb:	83 c4 10             	add    $0x10,%esp
  80b4be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4c1:	c9                   	leave  
  80b4c2:	c3                   	ret    

0080b4c3 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b4c3:	55                   	push   %ebp
  80b4c4:	89 e5                	mov    %esp,%ebp
  80b4c6:	53                   	push   %ebx
  80b4c7:	83 ec 04             	sub    $0x4,%esp
  80b4ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b4cd:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b4d0:	85 db                	test   %ebx,%ebx
  80b4d2:	74 34                	je     80b508 <do_connected+0x45>
    return ERR_VAL;
  }

  conn->err = err;
  80b4d4:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b4d7:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b4da:	75 04                	jne    80b4e0 <do_connected+0x1d>
  80b4dc:	84 c0                	test   %al,%al
  80b4de:	74 1f                	je     80b4ff <do_connected+0x3c>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b4e0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b4e7:	83 ec 0c             	sub    $0xc,%esp
  80b4ea:	ff 73 10             	pushl  0x10(%ebx)
  80b4ed:	e8 6c eb ff ff       	call   80a05e <sys_sem_signal>
  return ERR_OK;
  80b4f2:	83 c4 10             	add    $0x10,%esp
  80b4f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b4fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4fd:	c9                   	leave  
  80b4fe:	c3                   	ret    
    setup_tcp(conn);
  80b4ff:	89 d8                	mov    %ebx,%eax
  80b501:	e8 6a ff ff ff       	call   80b470 <setup_tcp>
  80b506:	eb d8                	jmp    80b4e0 <do_connected+0x1d>
    return ERR_VAL;
  80b508:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b50d:	eb eb                	jmp    80b4fa <do_connected+0x37>

0080b50f <err_tcp>:
{
  80b50f:	55                   	push   %ebp
  80b510:	89 e5                	mov    %esp,%ebp
  80b512:	53                   	push   %ebx
  80b513:	83 ec 04             	sub    $0x4,%esp
  80b516:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b519:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b51c:	85 db                	test   %ebx,%ebx
  80b51e:	74 7e                	je     80b59e <err_tcp+0x8f>
  conn->pcb.tcp = NULL;
  80b520:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b527:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b52a:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b52e:	74 24                	je     80b554 <err_tcp+0x45>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b530:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b533:	85 c0                	test   %eax,%eax
  80b535:	74 0d                	je     80b544 <err_tcp+0x35>
  80b537:	83 ec 04             	sub    $0x4,%esp
  80b53a:	6a 00                	push   $0x0
  80b53c:	6a 00                	push   $0x0
  80b53e:	53                   	push   %ebx
  80b53f:	ff d0                	call   *%eax
  80b541:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b544:	83 ec 08             	sub    $0x8,%esp
  80b547:	6a 00                	push   $0x0
  80b549:	ff 73 14             	pushl  0x14(%ebx)
  80b54c:	e8 52 ed ff ff       	call   80a2a3 <sys_mbox_post>
  80b551:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b554:	8b 43 10             	mov    0x10(%ebx),%eax
  80b557:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b55a:	74 06                	je     80b562 <err_tcp+0x53>
  80b55c:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b560:	74 53                	je     80b5b5 <err_tcp+0xa6>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b562:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b566:	74 24                	je     80b58c <err_tcp+0x7d>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b568:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b56b:	85 c0                	test   %eax,%eax
  80b56d:	74 0d                	je     80b57c <err_tcp+0x6d>
  80b56f:	83 ec 04             	sub    $0x4,%esp
  80b572:	6a 00                	push   $0x0
  80b574:	6a 00                	push   $0x0
  80b576:	53                   	push   %ebx
  80b577:	ff d0                	call   *%eax
  80b579:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b57c:	83 ec 08             	sub    $0x8,%esp
  80b57f:	6a 00                	push   $0x0
  80b581:	ff 73 18             	pushl  0x18(%ebx)
  80b584:	e8 1a ed ff ff       	call   80a2a3 <sys_mbox_post>
  80b589:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b58c:	8b 43 04             	mov    0x4(%ebx),%eax
  80b58f:	83 f8 01             	cmp    $0x1,%eax
  80b592:	74 36                	je     80b5ca <err_tcp+0xbb>
  80b594:	83 f8 04             	cmp    $0x4,%eax
  80b597:	74 31                	je     80b5ca <err_tcp+0xbb>
}
  80b599:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b59c:	c9                   	leave  
  80b59d:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b59e:	83 ec 04             	sub    $0x4,%esp
  80b5a1:	68 b9 2f 81 00       	push   $0x812fb9
  80b5a6:	68 22 01 00 00       	push   $0x122
  80b5ab:	68 66 2f 81 00       	push   $0x812f66
  80b5b0:	e8 bb 2f 00 00       	call   80e570 <_panic>
    conn->state = NETCONN_NONE;
  80b5b5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b5bc:	83 ec 0c             	sub    $0xc,%esp
  80b5bf:	50                   	push   %eax
  80b5c0:	e8 99 ea ff ff       	call   80a05e <sys_sem_signal>
  80b5c5:	83 c4 10             	add    $0x10,%esp
  80b5c8:	eb 98                	jmp    80b562 <err_tcp+0x53>
    conn->state = NETCONN_NONE;
  80b5ca:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b5d1:	83 ec 0c             	sub    $0xc,%esp
  80b5d4:	ff 73 10             	pushl  0x10(%ebx)
  80b5d7:	e8 82 ea ff ff       	call   80a05e <sys_sem_signal>
  80b5dc:	83 c4 10             	add    $0x10,%esp
}
  80b5df:	eb b8                	jmp    80b599 <err_tcp+0x8a>

0080b5e1 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b5e1:	55                   	push   %ebp
  80b5e2:	89 e5                	mov    %esp,%ebp
  80b5e4:	57                   	push   %edi
  80b5e5:	56                   	push   %esi
  80b5e6:	53                   	push   %ebx
  80b5e7:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b5ea:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b5ee:	0f 85 c9 00 00 00    	jne    80b6bd <do_writemore+0xdc>
  80b5f4:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b5f6:	8b 40 24             	mov    0x24(%eax),%eax
  80b5f9:	8b 7e 28             	mov    0x28(%esi),%edi
  80b5fc:	89 fa                	mov    %edi,%edx
  80b5fe:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b601:	8b 58 08             	mov    0x8(%eax),%ebx
  80b604:	89 d9                	mov    %ebx,%ecx
  80b606:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b608:	29 fb                	sub    %edi,%ebx
  80b60a:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b610:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b615:	0f 4d d9             	cmovge %ecx,%ebx
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b618:	8b 4e 08             	mov    0x8(%esi),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b61b:	66 39 59 6e          	cmp    %bx,0x6e(%ecx)
  80b61f:	66 0f 46 59 6e       	cmovbe 0x6e(%ecx),%bx
  80b624:	0f b7 db             	movzwl %bx,%ebx
  80b627:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b62b:	50                   	push   %eax
  80b62c:	53                   	push   %ebx
  80b62d:	52                   	push   %edx
  80b62e:	51                   	push   %ecx
  80b62f:	e8 9b c9 ff ff       	call   807fcf <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b634:	89 da                	mov    %ebx,%edx
  80b636:	03 56 28             	add    0x28(%esi),%edx
  80b639:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b63c:	83 c4 10             	add    $0x10,%esp
  80b63f:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b642:	0f 8f 8c 00 00 00    	jg     80b6d4 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80b648:	84 c0                	test   %al,%al
  80b64a:	0f 85 bf 00 00 00    	jne    80b70f <do_writemore+0x12e>
    conn->write_offset += len;
  80b650:	89 56 28             	mov    %edx,0x28(%esi)
  u8_t write_finished = 0;
  80b653:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b658:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b65b:	0f 84 8a 00 00 00    	je     80b6eb <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b661:	8b 46 08             	mov    0x8(%esi),%eax
  80b664:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b668:	74 1a                	je     80b684 <do_writemore+0xa3>
  80b66a:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b66e:	75 14                	jne    80b684 <do_writemore+0xa3>
  80b670:	8b 50 74             	mov    0x74(%eax),%edx
  80b673:	85 d2                	test   %edx,%edx
  80b675:	0f 84 88 00 00 00    	je     80b703 <do_writemore+0x122>
  80b67b:	83 3a 00             	cmpl   $0x0,(%edx)
  80b67e:	0f 84 85 00 00 00    	je     80b709 <do_writemore+0x128>
  80b684:	83 ec 0c             	sub    $0xc,%esp
  80b687:	50                   	push   %eax
  80b688:	e8 99 c9 ff ff       	call   808026 <tcp_output>
    conn->err = err;
  80b68d:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b690:	83 c4 10             	add    $0x10,%esp
  80b693:	84 c0                	test   %al,%al
  80b695:	75 1e                	jne    80b6b5 <do_writemore+0xd4>
  80b697:	8b 46 08             	mov    0x8(%esi),%eax
  80b69a:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b6a0:	77 13                	ja     80b6b5 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b6a2:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b6a5:	85 c0                	test   %eax,%eax
  80b6a7:	74 0c                	je     80b6b5 <do_writemore+0xd4>
  80b6a9:	83 ec 04             	sub    $0x4,%esp
  80b6ac:	53                   	push   %ebx
  80b6ad:	6a 03                	push   $0x3
  80b6af:	56                   	push   %esi
  80b6b0:	ff d0                	call   *%eax
  80b6b2:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80b6b5:	89 f8                	mov    %edi,%eax
  80b6b7:	84 c0                	test   %al,%al
  80b6b9:	74 70                	je     80b72b <do_writemore+0x14a>
  80b6bb:	eb 59                	jmp    80b716 <do_writemore+0x135>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b6bd:	83 ec 04             	sub    $0x4,%esp
  80b6c0:	68 c6 2f 81 00       	push   $0x812fc6
  80b6c5:	68 b8 03 00 00       	push   $0x3b8
  80b6ca:	68 66 2f 81 00       	push   $0x812f66
  80b6cf:	e8 9c 2e 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b6d4:	83 ec 04             	sub    $0x4,%esp
  80b6d7:	68 e3 2f 81 00       	push   $0x812fe3
  80b6dc:	68 cd 03 00 00       	push   $0x3cd
  80b6e1:	68 66 2f 81 00       	push   $0x812f66
  80b6e6:	e8 85 2e 00 00       	call   80e570 <_panic>
      conn->write_msg = NULL;
  80b6eb:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b6f2:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
      write_finished = 1;
  80b6f9:	bf 01 00 00 00       	mov    $0x1,%edi
  80b6fe:	e9 5e ff ff ff       	jmp    80b661 <do_writemore+0x80>
    conn->err = err;
  80b703:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b707:	eb 8e                	jmp    80b697 <do_writemore+0xb6>
  80b709:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b70d:	eb 88                	jmp    80b697 <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80b70f:	3c ff                	cmp    $0xff,%al
  80b711:	74 25                	je     80b738 <do_writemore+0x157>
    conn->err = err;
  80b713:	88 46 0c             	mov    %al,0xc(%esi)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b716:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b71d:	83 ec 0c             	sub    $0xc,%esp
  80b720:	ff 76 10             	pushl  0x10(%esi)
  80b723:	e8 36 e9 ff ff       	call   80a05e <sys_sem_signal>
  80b728:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b72b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b730:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b733:	5b                   	pop    %ebx
  80b734:	5e                   	pop    %esi
  80b735:	5f                   	pop    %edi
  80b736:	5d                   	pop    %ebp
  80b737:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80b738:	83 ec 0c             	sub    $0xc,%esp
  80b73b:	ff 76 08             	pushl  0x8(%esi)
  80b73e:	e8 e3 c8 ff ff       	call   808026 <tcp_output>
  80b743:	83 c4 10             	add    $0x10,%esp
  80b746:	eb e3                	jmp    80b72b <do_writemore+0x14a>

0080b748 <do_close_internal>:
{
  80b748:	55                   	push   %ebp
  80b749:	89 e5                	mov    %esp,%ebp
  80b74b:	53                   	push   %ebx
  80b74c:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b74f:	85 c0                	test   %eax,%eax
  80b751:	0f 84 e2 00 00 00    	je     80b839 <do_close_internal+0xf1>
  80b757:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b759:	83 38 10             	cmpl   $0x10,(%eax)
  80b75c:	0f 85 ee 00 00 00    	jne    80b850 <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b762:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b766:	0f 85 fb 00 00 00    	jne    80b867 <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b76c:	8b 40 08             	mov    0x8(%eax),%eax
  80b76f:	85 c0                	test   %eax,%eax
  80b771:	0f 84 07 01 00 00    	je     80b87e <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80b777:	83 ec 08             	sub    $0x8,%esp
  80b77a:	6a 00                	push   $0x0
  80b77c:	50                   	push   %eax
  80b77d:	e8 35 a0 ff ff       	call   8057b7 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b782:	8b 43 08             	mov    0x8(%ebx),%eax
  80b785:	83 c4 10             	add    $0x10,%esp
  80b788:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b78c:	0f 84 03 01 00 00    	je     80b895 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80b792:	83 ec 08             	sub    $0x8,%esp
  80b795:	6a 00                	push   $0x0
  80b797:	50                   	push   %eax
  80b798:	e8 28 a0 ff ff       	call   8057c5 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b79d:	83 c4 08             	add    $0x8,%esp
  80b7a0:	6a 00                	push   $0x0
  80b7a2:	ff 73 08             	pushl  0x8(%ebx)
  80b7a5:	e8 4e a0 ff ff       	call   8057f8 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80b7aa:	83 c4 08             	add    $0x8,%esp
  80b7ad:	6a 00                	push   $0x0
  80b7af:	ff 73 08             	pushl  0x8(%ebx)
  80b7b2:	e8 1f a0 ff ff       	call   8057d6 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b7b7:	83 c4 0c             	add    $0xc,%esp
  80b7ba:	6a 04                	push   $0x4
  80b7bc:	6a 00                	push   $0x0
  80b7be:	ff 73 08             	pushl  0x8(%ebx)
  80b7c1:	e8 40 a0 ff ff       	call   805806 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b7c6:	83 c4 08             	add    $0x8,%esp
  80b7c9:	6a 00                	push   $0x0
  80b7cb:	ff 73 08             	pushl  0x8(%ebx)
  80b7ce:	e8 14 a0 ff ff       	call   8057e7 <tcp_err>
  80b7d3:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80b7d6:	83 ec 0c             	sub    $0xc,%esp
  80b7d9:	ff 73 08             	pushl  0x8(%ebx)
  80b7dc:	e8 d8 a1 ff ff       	call   8059b9 <tcp_close>
  if (err == ERR_OK) {
  80b7e1:	83 c4 10             	add    $0x10,%esp
  80b7e4:	84 c0                	test   %al,%al
  80b7e6:	0f 85 bc 00 00 00    	jne    80b8a8 <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80b7ec:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80b7f3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b7fa:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b7fe:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b801:	85 c0                	test   %eax,%eax
  80b803:	74 21                	je     80b826 <do_close_internal+0xde>
  80b805:	83 ec 04             	sub    $0x4,%esp
  80b808:	6a 00                	push   $0x0
  80b80a:	6a 00                	push   $0x0
  80b80c:	53                   	push   %ebx
  80b80d:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b80f:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b812:	83 c4 10             	add    $0x10,%esp
  80b815:	85 c0                	test   %eax,%eax
  80b817:	74 0d                	je     80b826 <do_close_internal+0xde>
  80b819:	83 ec 04             	sub    $0x4,%esp
  80b81c:	6a 00                	push   $0x0
  80b81e:	6a 02                	push   $0x2
  80b820:	53                   	push   %ebx
  80b821:	ff d0                	call   *%eax
  80b823:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80b826:	83 ec 0c             	sub    $0xc,%esp
  80b829:	ff 73 10             	pushl  0x10(%ebx)
  80b82c:	e8 2d e8 ff ff       	call   80a05e <sys_sem_signal>
  80b831:	83 c4 10             	add    $0x10,%esp
}
  80b834:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b837:	c9                   	leave  
  80b838:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b839:	83 ec 04             	sub    $0x4,%esp
  80b83c:	68 d4 2d 81 00       	push   $0x812dd4
  80b841:	68 53 02 00 00       	push   $0x253
  80b846:	68 66 2f 81 00       	push   $0x812f66
  80b84b:	e8 20 2d 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b850:	83 ec 04             	sub    $0x4,%esp
  80b853:	68 01 30 81 00       	push   $0x813001
  80b858:	68 54 02 00 00       	push   $0x254
  80b85d:	68 66 2f 81 00       	push   $0x812f66
  80b862:	e8 09 2d 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b867:	83 ec 04             	sub    $0x4,%esp
  80b86a:	68 a4 2e 81 00       	push   $0x812ea4
  80b86f:	68 55 02 00 00       	push   $0x255
  80b874:	68 66 2f 81 00       	push   $0x812f66
  80b879:	e8 f2 2c 00 00       	call   80e570 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b87e:	83 ec 04             	sub    $0x4,%esp
  80b881:	68 1f 30 81 00       	push   $0x81301f
  80b886:	68 56 02 00 00       	push   $0x256
  80b88b:	68 66 2f 81 00       	push   $0x812f66
  80b890:	e8 db 2c 00 00       	call   80e570 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80b895:	83 ec 08             	sub    $0x8,%esp
  80b898:	6a 00                	push   $0x0
  80b89a:	50                   	push   %eax
  80b89b:	e8 58 9f ff ff       	call   8057f8 <tcp_accept>
  80b8a0:	83 c4 10             	add    $0x10,%esp
  80b8a3:	e9 2e ff ff ff       	jmp    80b7d6 <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b8a8:	8b 43 08             	mov    0x8(%ebx),%eax
  80b8ab:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b8af:	74 44                	je     80b8f5 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b8b1:	83 ec 08             	sub    $0x8,%esp
  80b8b4:	68 52 b9 80 00       	push   $0x80b952
  80b8b9:	50                   	push   %eax
  80b8ba:	e8 17 9f ff ff       	call   8057d6 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b8bf:	83 c4 0c             	add    $0xc,%esp
  80b8c2:	6a 04                	push   $0x4
  80b8c4:	68 0c b9 80 00       	push   $0x80b90c
  80b8c9:	ff 73 08             	pushl  0x8(%ebx)
  80b8cc:	e8 35 9f ff ff       	call   805806 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b8d1:	83 c4 08             	add    $0x8,%esp
  80b8d4:	68 0f b5 80 00       	push   $0x80b50f
  80b8d9:	ff 73 08             	pushl  0x8(%ebx)
  80b8dc:	e8 06 9f ff ff       	call   8057e7 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b8e1:	83 c4 08             	add    $0x8,%esp
  80b8e4:	53                   	push   %ebx
  80b8e5:	ff 73 08             	pushl  0x8(%ebx)
  80b8e8:	e8 ca 9e ff ff       	call   8057b7 <tcp_arg>
  80b8ed:	83 c4 10             	add    $0x10,%esp
}
  80b8f0:	e9 3f ff ff ff       	jmp    80b834 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b8f5:	83 ec 04             	sub    $0x4,%esp
  80b8f8:	68 c8 2e 81 00       	push   $0x812ec8
  80b8fd:	68 75 02 00 00       	push   $0x275
  80b902:	68 66 2f 81 00       	push   $0x812f66
  80b907:	e8 64 2c 00 00       	call   80e570 <_panic>

0080b90c <poll_tcp>:
{
  80b90c:	55                   	push   %ebp
  80b90d:	89 e5                	mov    %esp,%ebp
  80b90f:	83 ec 08             	sub    $0x8,%esp
  80b912:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b915:	85 c0                	test   %eax,%eax
  80b917:	74 14                	je     80b92d <poll_tcp+0x21>
  if (conn->state == NETCONN_WRITE) {
  80b919:	8b 50 04             	mov    0x4(%eax),%edx
  80b91c:	83 fa 01             	cmp    $0x1,%edx
  80b91f:	74 23                	je     80b944 <poll_tcp+0x38>
  } else if (conn->state == NETCONN_CLOSE) {
  80b921:	83 fa 04             	cmp    $0x4,%edx
  80b924:	74 25                	je     80b94b <poll_tcp+0x3f>
}
  80b926:	b8 00 00 00 00       	mov    $0x0,%eax
  80b92b:	c9                   	leave  
  80b92c:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b92d:	83 ec 04             	sub    $0x4,%esp
  80b930:	68 b9 2f 81 00       	push   $0x812fb9
  80b935:	68 eb 00 00 00       	push   $0xeb
  80b93a:	68 66 2f 81 00       	push   $0x812f66
  80b93f:	e8 2c 2c 00 00       	call   80e570 <_panic>
    do_writemore(conn);
  80b944:	e8 98 fc ff ff       	call   80b5e1 <do_writemore>
  80b949:	eb db                	jmp    80b926 <poll_tcp+0x1a>
    do_close_internal(conn);
  80b94b:	e8 f8 fd ff ff       	call   80b748 <do_close_internal>
  80b950:	eb d4                	jmp    80b926 <poll_tcp+0x1a>

0080b952 <sent_tcp>:
{
  80b952:	55                   	push   %ebp
  80b953:	89 e5                	mov    %esp,%ebp
  80b955:	56                   	push   %esi
  80b956:	53                   	push   %ebx
  80b957:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b95a:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b95d:	85 db                	test   %ebx,%ebx
  80b95f:	74 3e                	je     80b99f <sent_tcp+0x4d>
  if (conn->state == NETCONN_WRITE) {
  80b961:	8b 43 04             	mov    0x4(%ebx),%eax
  80b964:	83 f8 01             	cmp    $0x1,%eax
  80b967:	74 4d                	je     80b9b6 <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
  80b969:	83 f8 04             	cmp    $0x4,%eax
  80b96c:	74 6e                	je     80b9dc <sent_tcp+0x8a>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b96e:	8b 43 08             	mov    0x8(%ebx),%eax
  80b971:	85 c0                	test   %eax,%eax
  80b973:	74 1e                	je     80b993 <sent_tcp+0x41>
  80b975:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b97b:	76 16                	jbe    80b993 <sent_tcp+0x41>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80b97d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b980:	85 c0                	test   %eax,%eax
  80b982:	74 0f                	je     80b993 <sent_tcp+0x41>
  80b984:	83 ec 04             	sub    $0x4,%esp
  80b987:	0f b7 f6             	movzwl %si,%esi
  80b98a:	56                   	push   %esi
  80b98b:	6a 02                	push   $0x2
  80b98d:	53                   	push   %ebx
  80b98e:	ff d0                	call   *%eax
  80b990:	83 c4 10             	add    $0x10,%esp
}
  80b993:	b8 00 00 00 00       	mov    $0x0,%eax
  80b998:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b99b:	5b                   	pop    %ebx
  80b99c:	5e                   	pop    %esi
  80b99d:	5d                   	pop    %ebp
  80b99e:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b99f:	83 ec 04             	sub    $0x4,%esp
  80b9a2:	68 b9 2f 81 00       	push   $0x812fb9
  80b9a7:	68 03 01 00 00       	push   $0x103
  80b9ac:	68 66 2f 81 00       	push   $0x812f66
  80b9b1:	e8 ba 2b 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b9b6:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b9ba:	74 09                	je     80b9c5 <sent_tcp+0x73>
    do_writemore(conn);
  80b9bc:	89 d8                	mov    %ebx,%eax
  80b9be:	e8 1e fc ff ff       	call   80b5e1 <do_writemore>
  80b9c3:	eb a9                	jmp    80b96e <sent_tcp+0x1c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b9c5:	83 ec 04             	sub    $0x4,%esp
  80b9c8:	68 32 30 81 00       	push   $0x813032
  80b9cd:	68 06 01 00 00       	push   $0x106
  80b9d2:	68 66 2f 81 00       	push   $0x812f66
  80b9d7:	e8 94 2b 00 00       	call   80e570 <_panic>
    do_close_internal(conn);
  80b9dc:	89 d8                	mov    %ebx,%eax
  80b9de:	e8 65 fd ff ff       	call   80b748 <do_close_internal>
  80b9e3:	eb 89                	jmp    80b96e <sent_tcp+0x1c>

0080b9e5 <do_newconn>:
{
  80b9e5:	55                   	push   %ebp
  80b9e6:	89 e5                	mov    %esp,%ebp
  80b9e8:	56                   	push   %esi
  80b9e9:	53                   	push   %ebx
  80b9ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80b9ed:	8b 03                	mov    (%ebx),%eax
  80b9ef:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b9f3:	74 17                	je     80ba0c <do_newconn+0x27>
   TCPIP_APIMSG_ACK(msg);
  80b9f5:	83 ec 0c             	sub    $0xc,%esp
  80b9f8:	8b 03                	mov    (%ebx),%eax
  80b9fa:	ff 70 10             	pushl  0x10(%eax)
  80b9fd:	e8 5c e6 ff ff       	call   80a05e <sys_sem_signal>
}
  80ba02:	83 c4 10             	add    $0x10,%esp
  80ba05:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ba08:	5b                   	pop    %ebx
  80ba09:	5e                   	pop    %esi
  80ba0a:	5d                   	pop    %ebp
  80ba0b:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80ba0c:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80ba10:	8b 33                	mov    (%ebx),%esi
  80ba12:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80ba16:	75 20                	jne    80ba38 <do_newconn+0x53>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80ba18:	8b 06                	mov    (%esi),%eax
  80ba1a:	25 f0 00 00 00       	and    $0xf0,%eax
  80ba1f:	83 f8 20             	cmp    $0x20,%eax
  80ba22:	74 67                	je     80ba8b <do_newconn+0xa6>
  80ba24:	83 f8 40             	cmp    $0x40,%eax
  80ba27:	74 26                	je     80ba4f <do_newconn+0x6a>
  80ba29:	83 f8 10             	cmp    $0x10,%eax
  80ba2c:	0f 84 99 00 00 00    	je     80bacb <do_newconn+0xe6>
     msg->conn->err = ERR_VAL;
  80ba32:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80ba36:	eb bd                	jmp    80b9f5 <do_newconn+0x10>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80ba38:	83 ec 04             	sub    $0x4,%esp
  80ba3b:	68 ec 2e 81 00       	push   $0x812eec
  80ba40:	68 8a 01 00 00       	push   $0x18a
  80ba45:	68 66 2f 81 00       	push   $0x812f66
  80ba4a:	e8 21 2b 00 00       	call   80e570 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80ba4f:	83 ec 0c             	sub    $0xc,%esp
  80ba52:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80ba56:	50                   	push   %eax
  80ba57:	e8 89 25 00 00       	call   80dfe5 <raw_new>
  80ba5c:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80ba5f:	8b 03                	mov    (%ebx),%eax
  80ba61:	8b 50 08             	mov    0x8(%eax),%edx
  80ba64:	83 c4 10             	add    $0x10,%esp
  80ba67:	85 d2                	test   %edx,%edx
  80ba69:	74 17                	je     80ba82 <do_newconn+0x9d>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80ba6b:	83 ec 04             	sub    $0x4,%esp
  80ba6e:	50                   	push   %eax
  80ba6f:	68 88 b3 80 00       	push   $0x80b388
  80ba74:	52                   	push   %edx
  80ba75:	e8 ef 23 00 00       	call   80de69 <raw_recv>
  80ba7a:	83 c4 10             	add    $0x10,%esp
  80ba7d:	e9 73 ff ff ff       	jmp    80b9f5 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80ba82:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80ba86:	e9 6a ff ff ff       	jmp    80b9f5 <do_newconn+0x10>
     msg->conn->pcb.udp = udp_new();
  80ba8b:	e8 2f d5 ff ff       	call   808fbf <udp_new>
  80ba90:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80ba93:	8b 03                	mov    (%ebx),%eax
  80ba95:	8b 50 08             	mov    0x8(%eax),%edx
  80ba98:	85 d2                	test   %edx,%edx
  80ba9a:	74 20                	je     80babc <do_newconn+0xd7>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80ba9c:	83 38 22             	cmpl   $0x22,(%eax)
  80ba9f:	74 24                	je     80bac5 <do_newconn+0xe0>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80baa1:	8b 03                	mov    (%ebx),%eax
  80baa3:	83 ec 04             	sub    $0x4,%esp
  80baa6:	50                   	push   %eax
  80baa7:	68 7e b2 80 00       	push   $0x80b27e
  80baac:	ff 70 08             	pushl  0x8(%eax)
  80baaf:	e8 b3 d4 ff ff       	call   808f67 <udp_recv>
  80bab4:	83 c4 10             	add    $0x10,%esp
  80bab7:	e9 39 ff ff ff       	jmp    80b9f5 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80babc:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bac0:	e9 30 ff ff ff       	jmp    80b9f5 <do_newconn+0x10>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80bac5:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bac9:	eb d6                	jmp    80baa1 <do_newconn+0xbc>
     msg->conn->pcb.tcp = tcp_new();
  80bacb:	e8 b7 a7 ff ff       	call   806287 <tcp_new>
  80bad0:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80bad3:	8b 03                	mov    (%ebx),%eax
  80bad5:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bad9:	74 0a                	je     80bae5 <do_newconn+0x100>
     setup_tcp(msg->conn);
  80badb:	e8 90 f9 ff ff       	call   80b470 <setup_tcp>
  80bae0:	e9 10 ff ff ff       	jmp    80b9f5 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bae5:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bae9:	e9 07 ff ff ff       	jmp    80b9f5 <do_newconn+0x10>

0080baee <netconn_alloc>:
{
  80baee:	55                   	push   %ebp
  80baef:	89 e5                	mov    %esp,%ebp
  80baf1:	53                   	push   %ebx
  80baf2:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80baf5:	6a 07                	push   $0x7
  80baf7:	e8 41 89 ff ff       	call   80443d <memp_malloc>
  80bafc:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bafe:	83 c4 10             	add    $0x10,%esp
  80bb01:	85 c0                	test   %eax,%eax
  80bb03:	74 5b                	je     80bb60 <netconn_alloc+0x72>
  conn->err = ERR_OK;
  80bb05:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80bb09:	8b 45 08             	mov    0x8(%ebp),%eax
  80bb0c:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bb0e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bb15:	83 ec 0c             	sub    $0xc,%esp
  80bb18:	6a 00                	push   $0x0
  80bb1a:	e8 82 e2 ff ff       	call   809da1 <sys_sem_new>
  80bb1f:	89 43 10             	mov    %eax,0x10(%ebx)
  80bb22:	83 c4 10             	add    $0x10,%esp
  80bb25:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb28:	74 3d                	je     80bb67 <netconn_alloc+0x79>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80bb2a:	83 ec 0c             	sub    $0xc,%esp
  80bb2d:	6a 00                	push   $0x0
  80bb2f:	e8 16 e4 ff ff       	call   809f4a <sys_mbox_new>
  80bb34:	89 43 14             	mov    %eax,0x14(%ebx)
  80bb37:	83 c4 10             	add    $0x10,%esp
  80bb3a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb3d:	74 3d                	je     80bb7c <netconn_alloc+0x8e>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bb3f:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bb46:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bb4d:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bb54:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb57:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bb5a:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bb60:	89 d8                	mov    %ebx,%eax
  80bb62:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bb65:	c9                   	leave  
  80bb66:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bb67:	83 ec 08             	sub    $0x8,%esp
  80bb6a:	53                   	push   %ebx
  80bb6b:	6a 07                	push   $0x7
  80bb6d:	e8 21 89 ff ff       	call   804493 <memp_free>
    return NULL;
  80bb72:	83 c4 10             	add    $0x10,%esp
  80bb75:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bb7a:	eb e4                	jmp    80bb60 <netconn_alloc+0x72>
    sys_sem_free(conn->op_completed);
  80bb7c:	83 ec 0c             	sub    $0xc,%esp
  80bb7f:	ff 73 10             	pushl  0x10(%ebx)
  80bb82:	e8 9b e2 ff ff       	call   809e22 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bb87:	83 c4 08             	add    $0x8,%esp
  80bb8a:	53                   	push   %ebx
  80bb8b:	6a 07                	push   $0x7
  80bb8d:	e8 01 89 ff ff       	call   804493 <memp_free>
    return NULL;
  80bb92:	83 c4 10             	add    $0x10,%esp
  80bb95:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bb9a:	eb c4                	jmp    80bb60 <netconn_alloc+0x72>

0080bb9c <netconn_free>:
{
  80bb9c:	55                   	push   %ebp
  80bb9d:	89 e5                	mov    %esp,%ebp
  80bb9f:	56                   	push   %esi
  80bba0:	53                   	push   %ebx
  80bba1:	83 ec 10             	sub    $0x10,%esp
  80bba4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bba7:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bbab:	75 0b                	jne    80bbb8 <netconn_free+0x1c>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bbad:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bbb0:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bbb4:	75 27                	jne    80bbdd <netconn_free+0x41>
  80bbb6:	eb 68                	jmp    80bc20 <netconn_free+0x84>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bbb8:	83 ec 04             	sub    $0x4,%esp
  80bbbb:	68 0c 2f 81 00       	push   $0x812f0c
  80bbc0:	68 26 02 00 00       	push   $0x226
  80bbc5:	68 66 2f 81 00       	push   $0x812f66
  80bbca:	e8 a1 29 00 00       	call   80e570 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bbcf:	83 ec 0c             	sub    $0xc,%esp
  80bbd2:	ff 75 f4             	pushl  -0xc(%ebp)
  80bbd5:	e8 68 68 ff ff       	call   802442 <netbuf_delete>
  80bbda:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bbdd:	83 ec 08             	sub    $0x8,%esp
  80bbe0:	56                   	push   %esi
  80bbe1:	ff 73 14             	pushl  0x14(%ebx)
  80bbe4:	e8 d8 e7 ff ff       	call   80a3c1 <sys_arch_mbox_tryfetch>
  80bbe9:	83 c4 10             	add    $0x10,%esp
  80bbec:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bbef:	74 1a                	je     80bc0b <netconn_free+0x6f>
      if (conn->type == NETCONN_TCP) {
  80bbf1:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bbf4:	75 d9                	jne    80bbcf <netconn_free+0x33>
        if(mem != NULL) {
  80bbf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bbf9:	85 c0                	test   %eax,%eax
  80bbfb:	74 e0                	je     80bbdd <netconn_free+0x41>
          pbuf_free((struct pbuf *)mem);
  80bbfd:	83 ec 0c             	sub    $0xc,%esp
  80bc00:	50                   	push   %eax
  80bc01:	e8 dd 8b ff ff       	call   8047e3 <pbuf_free>
  80bc06:	83 c4 10             	add    $0x10,%esp
  80bc09:	eb d2                	jmp    80bbdd <netconn_free+0x41>
    sys_mbox_free(conn->recvmbox);
  80bc0b:	83 ec 0c             	sub    $0xc,%esp
  80bc0e:	ff 73 14             	pushl  0x14(%ebx)
  80bc11:	e8 95 e2 ff ff       	call   809eab <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bc16:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bc1d:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc20:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bc23:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bc27:	74 39                	je     80bc62 <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc29:	83 ec 08             	sub    $0x8,%esp
  80bc2c:	56                   	push   %esi
  80bc2d:	ff 73 18             	pushl  0x18(%ebx)
  80bc30:	e8 8c e7 ff ff       	call   80a3c1 <sys_arch_mbox_tryfetch>
  80bc35:	83 c4 10             	add    $0x10,%esp
  80bc38:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc3b:	74 10                	je     80bc4d <netconn_free+0xb1>
      netconn_delete((struct netconn *)mem);
  80bc3d:	83 ec 0c             	sub    $0xc,%esp
  80bc40:	ff 75 f4             	pushl  -0xc(%ebp)
  80bc43:	e8 24 f0 ff ff       	call   80ac6c <netconn_delete>
  80bc48:	83 c4 10             	add    $0x10,%esp
  80bc4b:	eb dc                	jmp    80bc29 <netconn_free+0x8d>
    sys_mbox_free(conn->acceptmbox);
  80bc4d:	83 ec 0c             	sub    $0xc,%esp
  80bc50:	ff 73 18             	pushl  0x18(%ebx)
  80bc53:	e8 53 e2 ff ff       	call   809eab <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bc58:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bc5f:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80bc62:	83 ec 0c             	sub    $0xc,%esp
  80bc65:	ff 73 10             	pushl  0x10(%ebx)
  80bc68:	e8 b5 e1 ff ff       	call   809e22 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bc6d:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80bc74:	83 c4 08             	add    $0x8,%esp
  80bc77:	53                   	push   %ebx
  80bc78:	6a 07                	push   $0x7
  80bc7a:	e8 14 88 ff ff       	call   804493 <memp_free>
}
  80bc7f:	83 c4 10             	add    $0x10,%esp
  80bc82:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bc85:	5b                   	pop    %ebx
  80bc86:	5e                   	pop    %esi
  80bc87:	5d                   	pop    %ebp
  80bc88:	c3                   	ret    

0080bc89 <accept_function>:
{
  80bc89:	55                   	push   %ebp
  80bc8a:	89 e5                	mov    %esp,%ebp
  80bc8c:	57                   	push   %edi
  80bc8d:	56                   	push   %esi
  80bc8e:	53                   	push   %ebx
  80bc8f:	83 ec 0c             	sub    $0xc,%esp
  80bc92:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc95:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bc98:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bc9c:	74 57                	je     80bcf5 <accept_function+0x6c>
  newconn = netconn_alloc(conn->type, conn->callback);
  80bc9e:	83 ec 08             	sub    $0x8,%esp
  80bca1:	ff 73 2c             	pushl  0x2c(%ebx)
  80bca4:	ff 33                	pushl  (%ebx)
  80bca6:	e8 43 fe ff ff       	call   80baee <netconn_alloc>
  80bcab:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bcad:	83 c4 10             	add    $0x10,%esp
  80bcb0:	85 c0                	test   %eax,%eax
  80bcb2:	74 72                	je     80bd26 <accept_function+0x9d>
  newconn->pcb.tcp = newpcb;
  80bcb4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bcb7:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bcba:	89 f0                	mov    %esi,%eax
  80bcbc:	e8 af f7 ff ff       	call   80b470 <setup_tcp>
  newconn->err = err;
  80bcc1:	89 f8                	mov    %edi,%eax
  80bcc3:	88 46 0c             	mov    %al,0xc(%esi)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bcc6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bcc9:	85 c0                	test   %eax,%eax
  80bccb:	74 0d                	je     80bcda <accept_function+0x51>
  80bccd:	83 ec 04             	sub    $0x4,%esp
  80bcd0:	6a 00                	push   $0x0
  80bcd2:	6a 00                	push   $0x0
  80bcd4:	53                   	push   %ebx
  80bcd5:	ff d0                	call   *%eax
  80bcd7:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bcda:	83 ec 08             	sub    $0x8,%esp
  80bcdd:	56                   	push   %esi
  80bcde:	ff 73 18             	pushl  0x18(%ebx)
  80bce1:	e8 f8 e4 ff ff       	call   80a1de <sys_mbox_trypost>
  80bce6:	83 c4 10             	add    $0x10,%esp
  80bce9:	84 c0                	test   %al,%al
  80bceb:	75 1f                	jne    80bd0c <accept_function+0x83>
}
  80bced:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bcf0:	5b                   	pop    %ebx
  80bcf1:	5e                   	pop    %esi
  80bcf2:	5f                   	pop    %edi
  80bcf3:	5d                   	pop    %ebp
  80bcf4:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bcf5:	83 ec 04             	sub    $0x4,%esp
  80bcf8:	68 3c 2f 81 00       	push   $0x812f3c
  80bcfd:	68 65 01 00 00       	push   $0x165
  80bd02:	68 66 2f 81 00       	push   $0x812f66
  80bd07:	e8 64 28 00 00       	call   80e570 <_panic>
    newconn->pcb.tcp = NULL;
  80bd0c:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bd13:	83 ec 0c             	sub    $0xc,%esp
  80bd16:	56                   	push   %esi
  80bd17:	e8 80 fe ff ff       	call   80bb9c <netconn_free>
    return ERR_MEM;
  80bd1c:	83 c4 10             	add    $0x10,%esp
  80bd1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bd24:	eb c7                	jmp    80bced <accept_function+0x64>
    return ERR_MEM;
  80bd26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bd2b:	eb c0                	jmp    80bced <accept_function+0x64>

0080bd2d <do_delconn>:
{
  80bd2d:	55                   	push   %ebp
  80bd2e:	89 e5                	mov    %esp,%ebp
  80bd30:	53                   	push   %ebx
  80bd31:	83 ec 04             	sub    $0x4,%esp
  80bd34:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bd37:	8b 13                	mov    (%ebx),%edx
  80bd39:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bd3c:	85 c9                	test   %ecx,%ecx
  80bd3e:	74 16                	je     80bd56 <do_delconn+0x29>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd40:	8b 02                	mov    (%edx),%eax
  80bd42:	25 f0 00 00 00       	and    $0xf0,%eax
  80bd47:	83 f8 20             	cmp    $0x20,%eax
  80bd4a:	74 53                	je     80bd9f <do_delconn+0x72>
  80bd4c:	83 f8 40             	cmp    $0x40,%eax
  80bd4f:	74 40                	je     80bd91 <do_delconn+0x64>
  80bd51:	83 f8 10             	cmp    $0x10,%eax
  80bd54:	74 62                	je     80bdb8 <do_delconn+0x8b>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bd56:	8b 13                	mov    (%ebx),%edx
  80bd58:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bd5b:	85 c0                	test   %eax,%eax
  80bd5d:	74 23                	je     80bd82 <do_delconn+0x55>
  80bd5f:	83 ec 04             	sub    $0x4,%esp
  80bd62:	6a 00                	push   $0x0
  80bd64:	6a 00                	push   $0x0
  80bd66:	52                   	push   %edx
  80bd67:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bd69:	8b 13                	mov    (%ebx),%edx
  80bd6b:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bd6e:	83 c4 10             	add    $0x10,%esp
  80bd71:	85 c0                	test   %eax,%eax
  80bd73:	74 0d                	je     80bd82 <do_delconn+0x55>
  80bd75:	83 ec 04             	sub    $0x4,%esp
  80bd78:	6a 00                	push   $0x0
  80bd7a:	6a 02                	push   $0x2
  80bd7c:	52                   	push   %edx
  80bd7d:	ff d0                	call   *%eax
  80bd7f:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bd82:	8b 03                	mov    (%ebx),%eax
  80bd84:	8b 40 10             	mov    0x10(%eax),%eax
  80bd87:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd8a:	75 3c                	jne    80bdc8 <do_delconn+0x9b>
}
  80bd8c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bd8f:	c9                   	leave  
  80bd90:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80bd91:	83 ec 0c             	sub    $0xc,%esp
  80bd94:	51                   	push   %ecx
  80bd95:	e8 07 22 00 00       	call   80dfa1 <raw_remove>
      break;
  80bd9a:	83 c4 10             	add    $0x10,%esp
  80bd9d:	eb b7                	jmp    80bd56 <do_delconn+0x29>
      msg->conn->pcb.udp->recv_arg = NULL;
  80bd9f:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bda6:	83 ec 0c             	sub    $0xc,%esp
  80bda9:	8b 03                	mov    (%ebx),%eax
  80bdab:	ff 70 08             	pushl  0x8(%eax)
  80bdae:	e8 c8 d1 ff ff       	call   808f7b <udp_remove>
      break;
  80bdb3:	83 c4 10             	add    $0x10,%esp
  80bdb6:	eb 9e                	jmp    80bd56 <do_delconn+0x29>
      msg->conn->state = NETCONN_CLOSE;
  80bdb8:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bdbf:	8b 03                	mov    (%ebx),%eax
  80bdc1:	e8 82 f9 ff ff       	call   80b748 <do_close_internal>
      return;
  80bdc6:	eb c4                	jmp    80bd8c <do_delconn+0x5f>
    sys_sem_signal(msg->conn->op_completed);
  80bdc8:	83 ec 0c             	sub    $0xc,%esp
  80bdcb:	50                   	push   %eax
  80bdcc:	e8 8d e2 ff ff       	call   80a05e <sys_sem_signal>
  80bdd1:	83 c4 10             	add    $0x10,%esp
  80bdd4:	eb b6                	jmp    80bd8c <do_delconn+0x5f>

0080bdd6 <do_bind>:
{
  80bdd6:	55                   	push   %ebp
  80bdd7:	89 e5                	mov    %esp,%ebp
  80bdd9:	56                   	push   %esi
  80bdda:	53                   	push   %ebx
  80bddb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bdde:	8b 33                	mov    (%ebx),%esi
  80bde0:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bde4:	7c 1d                	jl     80be03 <do_bind+0x2d>
    if (msg->conn->pcb.tcp != NULL) {
  80bde6:	8b 56 08             	mov    0x8(%esi),%edx
  80bde9:	85 d2                	test   %edx,%edx
  80bdeb:	74 73                	je     80be60 <do_bind+0x8a>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bded:	8b 06                	mov    (%esi),%eax
  80bdef:	25 f0 00 00 00       	and    $0xf0,%eax
  80bdf4:	83 f8 20             	cmp    $0x20,%eax
  80bdf7:	74 35                	je     80be2e <do_bind+0x58>
  80bdf9:	83 f8 40             	cmp    $0x40,%eax
  80bdfc:	74 1c                	je     80be1a <do_bind+0x44>
  80bdfe:	83 f8 10             	cmp    $0x10,%eax
  80be01:	74 44                	je     80be47 <do_bind+0x71>
  TCPIP_APIMSG_ACK(msg);
  80be03:	83 ec 0c             	sub    $0xc,%esp
  80be06:	8b 03                	mov    (%ebx),%eax
  80be08:	ff 70 10             	pushl  0x10(%eax)
  80be0b:	e8 4e e2 ff ff       	call   80a05e <sys_sem_signal>
}
  80be10:	83 c4 10             	add    $0x10,%esp
  80be13:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be16:	5b                   	pop    %ebx
  80be17:	5e                   	pop    %esi
  80be18:	5d                   	pop    %ebp
  80be19:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80be1a:	83 ec 08             	sub    $0x8,%esp
  80be1d:	ff 73 04             	pushl  0x4(%ebx)
  80be20:	52                   	push   %edx
  80be21:	e8 08 20 00 00       	call   80de2e <raw_bind>
  80be26:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be29:	83 c4 10             	add    $0x10,%esp
  80be2c:	eb d5                	jmp    80be03 <do_bind+0x2d>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80be2e:	83 ec 04             	sub    $0x4,%esp
  80be31:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be35:	50                   	push   %eax
  80be36:	ff 73 04             	pushl  0x4(%ebx)
  80be39:	52                   	push   %edx
  80be3a:	e8 ec cd ff ff       	call   808c2b <udp_bind>
  80be3f:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be42:	83 c4 10             	add    $0x10,%esp
  80be45:	eb bc                	jmp    80be03 <do_bind+0x2d>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80be47:	83 ec 04             	sub    $0x4,%esp
  80be4a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be4e:	50                   	push   %eax
  80be4f:	ff 73 04             	pushl  0x4(%ebx)
  80be52:	52                   	push   %edx
  80be53:	e8 3b 95 ff ff       	call   805393 <tcp_bind>
  80be58:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be5b:	83 c4 10             	add    $0x10,%esp
  80be5e:	eb a3                	jmp    80be03 <do_bind+0x2d>
      msg->conn->err = ERR_VAL;
  80be60:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80be64:	eb 9d                	jmp    80be03 <do_bind+0x2d>

0080be66 <do_connect>:
{
  80be66:	55                   	push   %ebp
  80be67:	89 e5                	mov    %esp,%ebp
  80be69:	56                   	push   %esi
  80be6a:	53                   	push   %ebx
  80be6b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80be6e:	8b 33                	mov    (%ebx),%esi
  80be70:	8b 56 08             	mov    0x8(%esi),%edx
  80be73:	85 d2                	test   %edx,%edx
  80be75:	74 1d                	je     80be94 <do_connect+0x2e>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80be77:	8b 06                	mov    (%esi),%eax
  80be79:	25 f0 00 00 00       	and    $0xf0,%eax
  80be7e:	83 f8 20             	cmp    $0x20,%eax
  80be81:	74 42                	je     80bec5 <do_connect+0x5f>
  80be83:	83 f8 40             	cmp    $0x40,%eax
  80be86:	74 1c                	je     80bea4 <do_connect+0x3e>
  80be88:	83 f8 10             	cmp    $0x10,%eax
  80be8b:	74 5e                	je     80beeb <do_connect+0x85>
}
  80be8d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be90:	5b                   	pop    %ebx
  80be91:	5e                   	pop    %esi
  80be92:	5d                   	pop    %ebp
  80be93:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80be94:	83 ec 0c             	sub    $0xc,%esp
  80be97:	ff 76 10             	pushl  0x10(%esi)
  80be9a:	e8 bf e1 ff ff       	call   80a05e <sys_sem_signal>
    return;
  80be9f:	83 c4 10             	add    $0x10,%esp
  80bea2:	eb e9                	jmp    80be8d <do_connect+0x27>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bea4:	83 ec 08             	sub    $0x8,%esp
  80bea7:	ff 73 04             	pushl  0x4(%ebx)
  80beaa:	52                   	push   %edx
  80beab:	e8 9b 1f 00 00       	call   80de4b <raw_connect>
  80beb0:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80beb3:	83 c4 04             	add    $0x4,%esp
  80beb6:	8b 03                	mov    (%ebx),%eax
  80beb8:	ff 70 10             	pushl  0x10(%eax)
  80bebb:	e8 9e e1 ff ff       	call   80a05e <sys_sem_signal>
    break;
  80bec0:	83 c4 10             	add    $0x10,%esp
  80bec3:	eb c8                	jmp    80be8d <do_connect+0x27>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bec5:	83 ec 04             	sub    $0x4,%esp
  80bec8:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80becc:	50                   	push   %eax
  80becd:	ff 73 04             	pushl  0x4(%ebx)
  80bed0:	52                   	push   %edx
  80bed1:	e8 05 d0 ff ff       	call   808edb <udp_connect>
  80bed6:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bed9:	83 c4 04             	add    $0x4,%esp
  80bedc:	8b 03                	mov    (%ebx),%eax
  80bede:	ff 70 10             	pushl  0x10(%eax)
  80bee1:	e8 78 e1 ff ff       	call   80a05e <sys_sem_signal>
    break;
  80bee6:	83 c4 10             	add    $0x10,%esp
  80bee9:	eb a2                	jmp    80be8d <do_connect+0x27>
    msg->conn->state = NETCONN_CONNECT;
  80beeb:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80bef2:	8b 03                	mov    (%ebx),%eax
  80bef4:	e8 77 f5 ff ff       	call   80b470 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80bef9:	8b 33                	mov    (%ebx),%esi
  80befb:	68 c3 b4 80 00       	push   $0x80b4c3
  80bf00:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bf04:	50                   	push   %eax
  80bf05:	ff 73 04             	pushl  0x4(%ebx)
  80bf08:	ff 76 08             	pushl  0x8(%esi)
  80bf0b:	e8 bf a3 ff ff       	call   8062cf <tcp_connect>
  80bf10:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80bf13:	83 c4 10             	add    $0x10,%esp
  80bf16:	e9 72 ff ff ff       	jmp    80be8d <do_connect+0x27>

0080bf1b <do_disconnect>:
{
  80bf1b:	55                   	push   %ebp
  80bf1c:	89 e5                	mov    %esp,%ebp
  80bf1e:	53                   	push   %ebx
  80bf1f:	83 ec 04             	sub    $0x4,%esp
  80bf22:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80bf25:	8b 13                	mov    (%ebx),%edx
  80bf27:	8b 02                	mov    (%edx),%eax
  80bf29:	25 f0 00 00 00       	and    $0xf0,%eax
  80bf2e:	83 f8 20             	cmp    $0x20,%eax
  80bf31:	74 15                	je     80bf48 <do_disconnect+0x2d>
  TCPIP_APIMSG_ACK(msg);
  80bf33:	83 ec 0c             	sub    $0xc,%esp
  80bf36:	8b 03                	mov    (%ebx),%eax
  80bf38:	ff 70 10             	pushl  0x10(%eax)
  80bf3b:	e8 1e e1 ff ff       	call   80a05e <sys_sem_signal>
}
  80bf40:	83 c4 10             	add    $0x10,%esp
  80bf43:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bf46:	c9                   	leave  
  80bf47:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80bf48:	83 ec 0c             	sub    $0xc,%esp
  80bf4b:	ff 72 08             	pushl  0x8(%edx)
  80bf4e:	e8 f9 cf ff ff       	call   808f4c <udp_disconnect>
  80bf53:	83 c4 10             	add    $0x10,%esp
  80bf56:	eb db                	jmp    80bf33 <do_disconnect+0x18>

0080bf58 <do_listen>:
{
  80bf58:	55                   	push   %ebp
  80bf59:	89 e5                	mov    %esp,%ebp
  80bf5b:	57                   	push   %edi
  80bf5c:	56                   	push   %esi
  80bf5d:	53                   	push   %ebx
  80bf5e:	83 ec 0c             	sub    $0xc,%esp
  80bf61:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bf64:	8b 03                	mov    (%ebx),%eax
  80bf66:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bf6a:	7c 0c                	jl     80bf78 <do_listen+0x20>
    if (msg->conn->pcb.tcp != NULL) {
  80bf6c:	8b 50 08             	mov    0x8(%eax),%edx
  80bf6f:	85 d2                	test   %edx,%edx
  80bf71:	74 05                	je     80bf78 <do_listen+0x20>
      if (msg->conn->type == NETCONN_TCP) {
  80bf73:	83 38 10             	cmpl   $0x10,(%eax)
  80bf76:	74 18                	je     80bf90 <do_listen+0x38>
  TCPIP_APIMSG_ACK(msg);
  80bf78:	83 ec 0c             	sub    $0xc,%esp
  80bf7b:	8b 03                	mov    (%ebx),%eax
  80bf7d:	ff 70 10             	pushl  0x10(%eax)
  80bf80:	e8 d9 e0 ff ff       	call   80a05e <sys_sem_signal>
}
  80bf85:	83 c4 10             	add    $0x10,%esp
  80bf88:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bf8b:	5b                   	pop    %ebx
  80bf8c:	5e                   	pop    %esi
  80bf8d:	5f                   	pop    %edi
  80bf8e:	5d                   	pop    %ebp
  80bf8f:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80bf90:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80bf94:	74 06                	je     80bf9c <do_listen+0x44>
          msg->conn->err = ERR_CONN;
  80bf96:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80bf9a:	eb dc                	jmp    80bf78 <do_listen+0x20>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80bf9c:	83 ec 08             	sub    $0x8,%esp
  80bf9f:	68 ff 00 00 00       	push   $0xff
  80bfa4:	52                   	push   %edx
  80bfa5:	e8 34 95 ff ff       	call   8054de <tcp_listen_with_backlog>
  80bfaa:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80bfac:	83 c4 10             	add    $0x10,%esp
  80bfaf:	85 c0                	test   %eax,%eax
  80bfb1:	74 4e                	je     80c001 <do_listen+0xa9>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80bfb3:	8b 03                	mov    (%ebx),%eax
  80bfb5:	8b 40 14             	mov    0x14(%eax),%eax
  80bfb8:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bfbb:	75 4f                	jne    80c00c <do_listen+0xb4>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80bfbd:	8b 3b                	mov    (%ebx),%edi
  80bfbf:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80bfc3:	74 5e                	je     80c023 <do_listen+0xcb>
            if (msg->conn->err == ERR_OK) {
  80bfc5:	8b 03                	mov    (%ebx),%eax
  80bfc7:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bfcb:	75 ab                	jne    80bf78 <do_listen+0x20>
              msg->conn->state = NETCONN_LISTEN;
  80bfcd:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80bfd4:	8b 03                	mov    (%ebx),%eax
  80bfd6:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80bfd9:	8b 03                	mov    (%ebx),%eax
  80bfdb:	83 ec 08             	sub    $0x8,%esp
  80bfde:	50                   	push   %eax
  80bfdf:	ff 70 08             	pushl  0x8(%eax)
  80bfe2:	e8 d0 97 ff ff       	call   8057b7 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80bfe7:	83 c4 08             	add    $0x8,%esp
  80bfea:	68 89 bc 80 00       	push   $0x80bc89
  80bfef:	8b 03                	mov    (%ebx),%eax
  80bff1:	ff 70 08             	pushl  0x8(%eax)
  80bff4:	e8 ff 97 ff ff       	call   8057f8 <tcp_accept>
  80bff9:	83 c4 10             	add    $0x10,%esp
  80bffc:	e9 77 ff ff ff       	jmp    80bf78 <do_listen+0x20>
            msg->conn->err = ERR_MEM;
  80c001:	8b 03                	mov    (%ebx),%eax
  80c003:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c007:	e9 6c ff ff ff       	jmp    80bf78 <do_listen+0x20>
              sys_mbox_free(msg->conn->recvmbox);
  80c00c:	83 ec 0c             	sub    $0xc,%esp
  80c00f:	50                   	push   %eax
  80c010:	e8 96 de ff ff       	call   809eab <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c015:	8b 03                	mov    (%ebx),%eax
  80c017:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c01e:	83 c4 10             	add    $0x10,%esp
  80c021:	eb 9a                	jmp    80bfbd <do_listen+0x65>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c023:	83 ec 0c             	sub    $0xc,%esp
  80c026:	6a 00                	push   $0x0
  80c028:	e8 1d df ff ff       	call   809f4a <sys_mbox_new>
  80c02d:	89 47 18             	mov    %eax,0x18(%edi)
  80c030:	83 c4 10             	add    $0x10,%esp
  80c033:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c036:	75 8d                	jne    80bfc5 <do_listen+0x6d>
                msg->conn->err = ERR_MEM;
  80c038:	8b 03                	mov    (%ebx),%eax
  80c03a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c03e:	eb 85                	jmp    80bfc5 <do_listen+0x6d>

0080c040 <do_send>:
{
  80c040:	55                   	push   %ebp
  80c041:	89 e5                	mov    %esp,%ebp
  80c043:	57                   	push   %edi
  80c044:	56                   	push   %esi
  80c045:	53                   	push   %ebx
  80c046:	83 ec 0c             	sub    $0xc,%esp
  80c049:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c04c:	8b 33                	mov    (%ebx),%esi
  80c04e:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c052:	7c 34                	jl     80c088 <do_send+0x48>
    if (msg->conn->pcb.tcp != NULL) {
  80c054:	8b 56 08             	mov    0x8(%esi),%edx
  80c057:	85 d2                	test   %edx,%edx
  80c059:	74 2d                	je     80c088 <do_send+0x48>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c05b:	8b 06                	mov    (%esi),%eax
  80c05d:	25 f0 00 00 00       	and    $0xf0,%eax
  80c062:	83 f8 20             	cmp    $0x20,%eax
  80c065:	74 4c                	je     80c0b3 <do_send+0x73>
  80c067:	83 f8 40             	cmp    $0x40,%eax
  80c06a:	75 1c                	jne    80c088 <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c06c:	8b 43 04             	mov    0x4(%ebx),%eax
  80c06f:	8b 48 08             	mov    0x8(%eax),%ecx
  80c072:	85 c9                	test   %ecx,%ecx
  80c074:	74 2a                	je     80c0a0 <do_send+0x60>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c076:	83 ec 04             	sub    $0x4,%esp
  80c079:	51                   	push   %ecx
  80c07a:	ff 30                	pushl  (%eax)
  80c07c:	52                   	push   %edx
  80c07d:	e8 fb 1d 00 00       	call   80de7d <raw_sendto>
  80c082:	88 46 0c             	mov    %al,0xc(%esi)
  80c085:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c088:	83 ec 0c             	sub    $0xc,%esp
  80c08b:	8b 03                	mov    (%ebx),%eax
  80c08d:	ff 70 10             	pushl  0x10(%eax)
  80c090:	e8 c9 df ff ff       	call   80a05e <sys_sem_signal>
}
  80c095:	83 c4 10             	add    $0x10,%esp
  80c098:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c09b:	5b                   	pop    %ebx
  80c09c:	5e                   	pop    %esi
  80c09d:	5f                   	pop    %edi
  80c09e:	5d                   	pop    %ebp
  80c09f:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c0a0:	83 ec 08             	sub    $0x8,%esp
  80c0a3:	ff 30                	pushl  (%eax)
  80c0a5:	52                   	push   %edx
  80c0a6:	e8 de 1e 00 00       	call   80df89 <raw_send>
  80c0ab:	88 46 0c             	mov    %al,0xc(%esi)
  80c0ae:	83 c4 10             	add    $0x10,%esp
  80c0b1:	eb d5                	jmp    80c088 <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c0b3:	8b 43 04             	mov    0x4(%ebx),%eax
  80c0b6:	8b 48 08             	mov    0x8(%eax),%ecx
  80c0b9:	85 c9                	test   %ecx,%ecx
  80c0bb:	74 16                	je     80c0d3 <do_send+0x93>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c0bd:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c0c1:	57                   	push   %edi
  80c0c2:	51                   	push   %ecx
  80c0c3:	ff 30                	pushl  (%eax)
  80c0c5:	52                   	push   %edx
  80c0c6:	e8 b3 cd ff ff       	call   808e7e <udp_sendto>
  80c0cb:	88 46 0c             	mov    %al,0xc(%esi)
  80c0ce:	83 c4 10             	add    $0x10,%esp
  80c0d1:	eb b5                	jmp    80c088 <do_send+0x48>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c0d3:	83 ec 08             	sub    $0x8,%esp
  80c0d6:	ff 30                	pushl  (%eax)
  80c0d8:	52                   	push   %edx
  80c0d9:	e8 e0 cd ff ff       	call   808ebe <udp_send>
  80c0de:	88 46 0c             	mov    %al,0xc(%esi)
  80c0e1:	83 c4 10             	add    $0x10,%esp
  80c0e4:	eb a2                	jmp    80c088 <do_send+0x48>

0080c0e6 <do_recv>:
{
  80c0e6:	55                   	push   %ebp
  80c0e7:	89 e5                	mov    %esp,%ebp
  80c0e9:	53                   	push   %ebx
  80c0ea:	83 ec 04             	sub    $0x4,%esp
  80c0ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c0f0:	8b 03                	mov    (%ebx),%eax
  80c0f2:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c0f6:	7c 0c                	jl     80c104 <do_recv+0x1e>
    if (msg->conn->pcb.tcp != NULL) {
  80c0f8:	8b 50 08             	mov    0x8(%eax),%edx
  80c0fb:	85 d2                	test   %edx,%edx
  80c0fd:	74 05                	je     80c104 <do_recv+0x1e>
      if (msg->conn->type == NETCONN_TCP) {
  80c0ff:	83 38 10             	cmpl   $0x10,(%eax)
  80c102:	74 15                	je     80c119 <do_recv+0x33>
  TCPIP_APIMSG_ACK(msg);
  80c104:	83 ec 0c             	sub    $0xc,%esp
  80c107:	8b 03                	mov    (%ebx),%eax
  80c109:	ff 70 10             	pushl  0x10(%eax)
  80c10c:	e8 4d df ff ff       	call   80a05e <sys_sem_signal>
}
  80c111:	83 c4 10             	add    $0x10,%esp
  80c114:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c117:	c9                   	leave  
  80c118:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c119:	83 ec 08             	sub    $0x8,%esp
  80c11c:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c120:	50                   	push   %eax
  80c121:	52                   	push   %edx
  80c122:	e8 d6 94 ff ff       	call   8055fd <tcp_recved>
  80c127:	83 c4 10             	add    $0x10,%esp
  80c12a:	eb d8                	jmp    80c104 <do_recv+0x1e>

0080c12c <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c12c:	55                   	push   %ebp
  80c12d:	89 e5                	mov    %esp,%ebp
  80c12f:	83 ec 08             	sub    $0x8,%esp
  80c132:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c135:	8b 02                	mov    (%edx),%eax
  80c137:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c13b:	7c 0f                	jl     80c14c <do_write+0x20>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c13d:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c141:	74 05                	je     80c148 <do_write+0x1c>
  80c143:	83 38 10             	cmpl   $0x10,(%eax)
  80c146:	74 16                	je     80c15e <do_write+0x32>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c148:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c14c:	83 ec 0c             	sub    $0xc,%esp
  80c14f:	8b 02                	mov    (%edx),%eax
  80c151:	ff 70 10             	pushl  0x10(%eax)
  80c154:	e8 05 df ff ff       	call   80a05e <sys_sem_signal>
  80c159:	83 c4 10             	add    $0x10,%esp
}
  80c15c:	c9                   	leave  
  80c15d:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c15e:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c165:	8b 02                	mov    (%edx),%eax
  80c167:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c16a:	8b 02                	mov    (%edx),%eax
  80c16c:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c173:	8b 02                	mov    (%edx),%eax
  80c175:	e8 67 f4 ff ff       	call   80b5e1 <do_writemore>
      return;
  80c17a:	eb e0                	jmp    80c15c <do_write+0x30>

0080c17c <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c17c:	55                   	push   %ebp
  80c17d:	89 e5                	mov    %esp,%ebp
  80c17f:	83 ec 08             	sub    $0x8,%esp
  80c182:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c185:	8b 08                	mov    (%eax),%ecx
  80c187:	8b 51 08             	mov    0x8(%ecx),%edx
  80c18a:	85 d2                	test   %edx,%edx
  80c18c:	0f 84 a8 00 00 00    	je     80c23a <do_getaddr+0xbe>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c192:	8b 48 04             	mov    0x4(%eax),%ecx
  80c195:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c199:	74 2f                	je     80c1ca <do_getaddr+0x4e>
  80c19b:	8b 12                	mov    (%edx),%edx
  80c19d:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c19f:	8b 08                	mov    (%eax),%ecx
  80c1a1:	8b 11                	mov    (%ecx),%edx
  80c1a3:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c1a9:	83 fa 20             	cmp    $0x20,%edx
  80c1ac:	74 3e                	je     80c1ec <do_getaddr+0x70>
  80c1ae:	83 fa 40             	cmp    $0x40,%edx
  80c1b1:	74 1e                	je     80c1d1 <do_getaddr+0x55>
  80c1b3:	83 fa 10             	cmp    $0x10,%edx
  80c1b6:	74 64                	je     80c21c <do_getaddr+0xa0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c1b8:	83 ec 0c             	sub    $0xc,%esp
  80c1bb:	8b 00                	mov    (%eax),%eax
  80c1bd:	ff 70 10             	pushl  0x10(%eax)
  80c1c0:	e8 99 de ff ff       	call   80a05e <sys_sem_signal>
}
  80c1c5:	83 c4 10             	add    $0x10,%esp
  80c1c8:	c9                   	leave  
  80c1c9:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c1ca:	8b 52 04             	mov    0x4(%edx),%edx
  80c1cd:	89 11                	mov    %edx,(%ecx)
  80c1cf:	eb ce                	jmp    80c19f <do_getaddr+0x23>
      if (msg->msg.ad.local) {
  80c1d1:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c1d5:	74 0f                	je     80c1e6 <do_getaddr+0x6a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c1d7:	8b 50 08             	mov    0x8(%eax),%edx
  80c1da:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c1dd:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c1e1:	66 89 0a             	mov    %cx,(%edx)
  80c1e4:	eb d2                	jmp    80c1b8 <do_getaddr+0x3c>
        msg->conn->err = ERR_CONN;
  80c1e6:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c1ea:	eb cc                	jmp    80c1b8 <do_getaddr+0x3c>
      if (msg->msg.ad.local) {
  80c1ec:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c1f0:	74 0f                	je     80c201 <do_getaddr+0x85>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c1f2:	8b 50 08             	mov    0x8(%eax),%edx
  80c1f5:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c1f8:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c1fc:	66 89 0a             	mov    %cx,(%edx)
  80c1ff:	eb b7                	jmp    80c1b8 <do_getaddr+0x3c>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c201:	8b 51 08             	mov    0x8(%ecx),%edx
  80c204:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c208:	75 06                	jne    80c210 <do_getaddr+0x94>
          msg->conn->err = ERR_CONN;
  80c20a:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c20e:	eb a8                	jmp    80c1b8 <do_getaddr+0x3c>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c210:	8b 48 08             	mov    0x8(%eax),%ecx
  80c213:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c217:	66 89 11             	mov    %dx,(%ecx)
  80c21a:	eb 9c                	jmp    80c1b8 <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c21c:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c220:	74 0f                	je     80c231 <do_getaddr+0xb5>
  80c222:	8b 51 08             	mov    0x8(%ecx),%edx
  80c225:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c229:	8b 50 08             	mov    0x8(%eax),%edx
  80c22c:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c22f:	eb 87                	jmp    80c1b8 <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c231:	8b 51 08             	mov    0x8(%ecx),%edx
  80c234:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c238:	eb ef                	jmp    80c229 <do_getaddr+0xad>
    msg->conn->err = ERR_CONN;
  80c23a:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c23e:	e9 75 ff ff ff       	jmp    80c1b8 <do_getaddr+0x3c>

0080c243 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c243:	55                   	push   %ebp
  80c244:	89 e5                	mov    %esp,%ebp
  80c246:	83 ec 08             	sub    $0x8,%esp
  80c249:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c24c:	8b 02                	mov    (%edx),%eax
  80c24e:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c252:	74 05                	je     80c259 <do_close+0x16>
  80c254:	83 38 10             	cmpl   $0x10,(%eax)
  80c257:	74 16                	je     80c26f <do_close+0x2c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c259:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c25d:	83 ec 0c             	sub    $0xc,%esp
  80c260:	8b 02                	mov    (%edx),%eax
  80c262:	ff 70 10             	pushl  0x10(%eax)
  80c265:	e8 f4 dd ff ff       	call   80a05e <sys_sem_signal>
  80c26a:	83 c4 10             	add    $0x10,%esp
  }
}
  80c26d:	c9                   	leave  
  80c26e:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c26f:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c276:	8b 02                	mov    (%edx),%eax
  80c278:	e8 cb f4 ff ff       	call   80b748 <do_close_internal>
  80c27d:	eb ee                	jmp    80c26d <do_close+0x2a>

0080c27f <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c27f:	55                   	push   %ebp
  80c280:	89 e5                	mov    %esp,%ebp
  80c282:	57                   	push   %edi
  80c283:	56                   	push   %esi
  80c284:	53                   	push   %ebx
  80c285:	83 ec 18             	sub    $0x18,%esp
  80c288:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c28a:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c290:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c294:	50                   	push   %eax
  80c295:	e8 38 b4 ff ff       	call   8076d2 <ntohs>
  80c29a:	83 c4 10             	add    $0x10,%esp
  80c29d:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c2a1:	0f 86 84 00 00 00    	jbe    80c32b <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c2a7:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c2aa:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c2af:	eb 10                	jmp    80c2c1 <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c2b1:	83 c3 01             	add    $0x1,%ebx
  80c2b4:	eb 0b                	jmp    80c2c1 <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c2b6:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c2bb:	84 c0                	test   %al,%al
  80c2bd:	74 6c                	je     80c32b <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c2bf:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c2c1:	83 ec 0c             	sub    $0xc,%esp
  80c2c4:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c2c9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c2cd:	50                   	push   %eax
  80c2ce:	e8 ff b3 ff ff       	call   8076d2 <ntohs>
  80c2d3:	0f b6 d3             	movzbl %bl,%edx
  80c2d6:	66 c1 e8 0c          	shr    $0xc,%ax
  80c2da:	0f b7 c0             	movzwl %ax,%eax
  80c2dd:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c2e4:	83 c4 10             	add    $0x10,%esp
  80c2e7:	39 c2                	cmp    %eax,%edx
  80c2e9:	7d 40                	jge    80c32b <tcp_parseopt+0xac>
      opt = opts[c];
  80c2eb:	0f b6 d3             	movzbl %bl,%edx
  80c2ee:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c2f2:	84 c0                	test   %al,%al
  80c2f4:	74 35                	je     80c32b <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c2f6:	3c 01                	cmp    $0x1,%al
  80c2f8:	74 b7                	je     80c2b1 <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c2fa:	3c 02                	cmp    $0x2,%al
  80c2fc:	75 b8                	jne    80c2b6 <tcp_parseopt+0x37>
  80c2fe:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c303:	75 b1                	jne    80c2b6 <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c305:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c30a:	c1 e1 08             	shl    $0x8,%ecx
  80c30d:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c312:	89 d0                	mov    %edx,%eax
  80c314:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c316:	83 e8 01             	sub    $0x1,%eax
  80c319:	09 d1                	or     %edx,%ecx
  80c31b:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c31f:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c324:	0f 42 c1             	cmovb  %ecx,%eax
  80c327:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c32b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c32e:	5b                   	pop    %ebx
  80c32f:	5e                   	pop    %esi
  80c330:	5f                   	pop    %edi
  80c331:	5d                   	pop    %ebp
  80c332:	c3                   	ret    

0080c333 <tcp_receive>:
{
  80c333:	55                   	push   %ebp
  80c334:	89 e5                	mov    %esp,%ebp
  80c336:	57                   	push   %edi
  80c337:	56                   	push   %esi
  80c338:	53                   	push   %ebx
  80c339:	83 ec 1c             	sub    $0x1c,%esp
  80c33c:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c33e:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c345:	0f 84 22 04 00 00    	je     80c76d <tcp_receive+0x43a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c34b:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c34f:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c352:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80c357:	39 c2                	cmp    %eax,%edx
  80c359:	78 53                	js     80c3ae <tcp_receive+0x7b>
  80c35b:	39 c2                	cmp    %eax,%edx
  80c35d:	74 36                	je     80c395 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c35f:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c365:	39 77 64             	cmp    %esi,0x64(%edi)
  80c368:	74 38                	je     80c3a2 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c36a:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c36d:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c372:	39 c3                	cmp    %eax,%ebx
  80c374:	74 68                	je     80c3de <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c376:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c379:	39 da                	cmp    %ebx,%edx
  80c37b:	78 0d                	js     80c38a <tcp_receive+0x57>
  80c37d:	89 c2                	mov    %eax,%edx
  80c37f:	2b 57 58             	sub    0x58(%edi),%edx
  80c382:	85 d2                	test   %edx,%edx
  80c384:	0f 8e fa 00 00 00    	jle    80c484 <tcp_receive+0x151>
      pcb->acked = 0;
  80c38a:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c390:	e9 c2 02 00 00       	jmp    80c657 <tcp_receive+0x324>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c395:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c39b:	39 77 64             	cmp    %esi,0x64(%edi)
  80c39e:	79 bf                	jns    80c35f <tcp_receive+0x2c>
  80c3a0:	eb 0c                	jmp    80c3ae <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c3a2:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c3a8:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c3ac:	73 bc                	jae    80c36a <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c3ae:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c3b4:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c3b8:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c3bc:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c3bf:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c3c4:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c3c7:	66 85 db             	test   %bx,%bx
  80c3ca:	74 9e                	je     80c36a <tcp_receive+0x37>
  80c3cc:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c3d3:	74 95                	je     80c36a <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c3d5:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c3dc:	eb 8c                	jmp    80c36a <tcp_receive+0x37>
      pcb->acked = 0;
  80c3de:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c3e4:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c3e8:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c3eb:	0f b7 c9             	movzwl %cx,%ecx
  80c3ee:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c3f0:	39 d0                	cmp    %edx,%eax
  80c3f2:	0f 85 5f 02 00 00    	jne    80c657 <tcp_receive+0x324>
        ++pcb->dupacks;
  80c3f8:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c3fc:	83 c0 01             	add    $0x1,%eax
  80c3ff:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c402:	3c 02                	cmp    $0x2,%al
  80c404:	0f 86 4d 02 00 00    	jbe    80c657 <tcp_receive+0x324>
  80c40a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c40e:	0f 84 43 02 00 00    	je     80c657 <tcp_receive+0x324>
          if (!(pcb->flags & TF_INFR)) {
  80c414:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c418:	74 1c                	je     80c436 <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c41a:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c41e:	89 d0                	mov    %edx,%eax
  80c420:	66 03 47 34          	add    0x34(%edi),%ax
  80c424:	66 39 c2             	cmp    %ax,%dx
  80c427:	0f 83 2a 02 00 00    	jae    80c657 <tcp_receive+0x324>
              pcb->cwnd += pcb->mss;
  80c42d:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c431:	e9 21 02 00 00       	jmp    80c657 <tcp_receive+0x324>
            tcp_rexmit(pcb);
  80c436:	83 ec 0c             	sub    $0xc,%esp
  80c439:	57                   	push   %edi
  80c43a:	e8 09 c2 ff ff       	call   808648 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c43f:	0f b7 5f 4e          	movzwl 0x4e(%edi),%ebx
  80c443:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c447:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c44a:	89 c2                	mov    %eax,%edx
  80c44c:	66 d1 ea             	shr    %dx
  80c44f:	89 d9                	mov    %ebx,%ecx
  80c451:	66 d1 e9             	shr    %cx
  80c454:	66 39 c3             	cmp    %ax,%bx
  80c457:	0f 47 ca             	cmova  %edx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c45a:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c45e:	0f b7 f1             	movzwl %cx,%esi
  80c461:	0f b7 d8             	movzwl %ax,%ebx
  80c464:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c466:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c469:	39 de                	cmp    %ebx,%esi
  80c46b:	0f 4d d1             	cmovge %ecx,%edx
  80c46e:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c472:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c475:	01 d0                	add    %edx,%eax
  80c477:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c47b:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c47f:	e9 d3 01 00 00       	jmp    80c657 <tcp_receive+0x324>
      if (pcb->flags & TF_INFR) {
  80c484:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c488:	f6 c2 04             	test   $0x4,%dl
  80c48b:	74 0e                	je     80c49b <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c48d:	83 e2 fb             	and    $0xfffffffb,%edx
  80c490:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c493:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c497:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c49b:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c49f:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c4a3:	66 c1 fa 03          	sar    $0x3,%dx
  80c4a7:	66 03 57 42          	add    0x42(%edi),%dx
  80c4ab:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c4af:	89 c2                	mov    %eax,%edx
  80c4b1:	29 da                	sub    %ebx,%edx
  80c4b3:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c4b7:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c4bb:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c4bf:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c4c2:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c4c6:	76 1d                	jbe    80c4e5 <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c4c8:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c4cc:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c4d0:	0f 83 d7 00 00 00    	jae    80c5ad <tcp_receive+0x27a>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c4d6:	89 c8                	mov    %ecx,%eax
  80c4d8:	66 03 47 34          	add    0x34(%edi),%ax
  80c4dc:	66 39 c1             	cmp    %ax,%cx
  80c4df:	73 04                	jae    80c4e5 <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c4e1:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c4e5:	8b 47 78             	mov    0x78(%edi),%eax
  80c4e8:	85 c0                	test   %eax,%eax
  80c4ea:	0f 84 18 01 00 00    	je     80c608 <tcp_receive+0x2d5>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c4f0:	83 ec 0c             	sub    $0xc,%esp
  80c4f3:	8b 40 10             	mov    0x10(%eax),%eax
  80c4f6:	ff 70 04             	pushl  0x4(%eax)
  80c4f9:	e8 f8 b3 ff ff       	call   8078f6 <ntohl>
  80c4fe:	89 c3                	mov    %eax,%ebx
  80c500:	8b 47 78             	mov    0x78(%edi),%eax
  80c503:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c507:	8b 40 10             	mov    0x10(%eax),%eax
  80c50a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c50e:	89 04 24             	mov    %eax,(%esp)
  80c511:	e8 bc b1 ff ff       	call   8076d2 <ntohs>
  80c516:	83 c4 10             	add    $0x10,%esp
  80c519:	ba 01 00 00 00       	mov    $0x1,%edx
  80c51e:	a8 01                	test   $0x1,%al
  80c520:	0f 84 bf 00 00 00    	je     80c5e5 <tcp_receive+0x2b2>
  80c526:	2b 1d a4 b1 b3 00    	sub    0xb3b1a4,%ebx
  80c52c:	01 d6                	add    %edx,%esi
  80c52e:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c530:	85 db                	test   %ebx,%ebx
  80c532:	0f 8f d0 00 00 00    	jg     80c608 <tcp_receive+0x2d5>
        next = pcb->unacked;
  80c538:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c53b:	8b 03                	mov    (%ebx),%eax
  80c53d:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c540:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c544:	83 ec 0c             	sub    $0xc,%esp
  80c547:	ff 73 04             	pushl  0x4(%ebx)
  80c54a:	e8 de 86 ff ff       	call   804c2d <pbuf_clen>
  80c54f:	0f b6 c0             	movzbl %al,%eax
  80c552:	83 c4 10             	add    $0x10,%esp
  80c555:	66 39 c6             	cmp    %ax,%si
  80c558:	72 74                	jb     80c5ce <tcp_receive+0x29b>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c55a:	83 ec 0c             	sub    $0xc,%esp
  80c55d:	ff 73 04             	pushl  0x4(%ebx)
  80c560:	e8 c8 86 ff ff       	call   804c2d <pbuf_clen>
  80c565:	0f b6 c0             	movzbl %al,%eax
  80c568:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c56c:	89 1c 24             	mov    %ebx,(%esp)
  80c56f:	e8 90 91 ff ff       	call   805704 <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c574:	83 c4 10             	add    $0x10,%esp
  80c577:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c57c:	0f 84 63 ff ff ff    	je     80c4e5 <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c582:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c586:	0f 85 59 ff ff ff    	jne    80c4e5 <tcp_receive+0x1b2>
  80c58c:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c590:	0f 85 4f ff ff ff    	jne    80c4e5 <tcp_receive+0x1b2>
  80c596:	83 ec 04             	sub    $0x4,%esp
  80c599:	68 70 30 81 00       	push   $0x813070
  80c59e:	68 5c 03 00 00       	push   $0x35c
  80c5a3:	68 b4 31 81 00       	push   $0x8131b4
  80c5a8:	e8 c3 1f 00 00       	call   80e570 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c5ad:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c5b1:	0f af c0             	imul   %eax,%eax
  80c5b4:	0f b7 d9             	movzwl %cx,%ebx
  80c5b7:	99                   	cltd   
  80c5b8:	f7 fb                	idiv   %ebx
  80c5ba:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c5bc:	66 39 c1             	cmp    %ax,%cx
  80c5bf:	0f 83 20 ff ff ff    	jae    80c4e5 <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c5c5:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c5c9:	e9 17 ff ff ff       	jmp    80c4e5 <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c5ce:	83 ec 04             	sub    $0x4,%esp
  80c5d1:	68 48 30 81 00       	push   $0x813048
  80c5d6:	68 55 03 00 00       	push   $0x355
  80c5db:	68 b4 31 81 00       	push   $0x8131b4
  80c5e0:	e8 8b 1f 00 00       	call   80e570 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c5e5:	83 ec 0c             	sub    $0xc,%esp
  80c5e8:	8b 47 78             	mov    0x78(%edi),%eax
  80c5eb:	8b 40 10             	mov    0x10(%eax),%eax
  80c5ee:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c5f2:	50                   	push   %eax
  80c5f3:	e8 da b0 ff ff       	call   8076d2 <ntohs>
  80c5f8:	66 d1 e8             	shr    %ax
  80c5fb:	89 c2                	mov    %eax,%edx
  80c5fd:	83 e2 01             	and    $0x1,%edx
  80c600:	83 c4 10             	add    $0x10,%esp
  80c603:	e9 1e ff ff ff       	jmp    80c526 <tcp_receive+0x1f3>
      if(pcb->unacked == NULL)
  80c608:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c60c:	0f 94 c0             	sete   %al
  80c60f:	0f b6 c0             	movzbl %al,%eax
  80c612:	f7 d8                	neg    %eax
  80c614:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80c618:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c61c:	eb 39                	jmp    80c657 <tcp_receive+0x324>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c61e:	83 ec 04             	sub    $0x4,%esp
  80c621:	68 48 30 81 00       	push   $0x813048
  80c626:	68 7f 03 00 00       	push   $0x37f
  80c62b:	68 b4 31 81 00       	push   $0x8131b4
  80c630:	e8 3b 1f 00 00       	call   80e570 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c635:	83 ec 04             	sub    $0x4,%esp
  80c638:	68 70 30 81 00       	push   $0x813070
  80c63d:	68 85 03 00 00       	push   $0x385
  80c642:	68 b4 31 81 00       	push   $0x8131b4
  80c647:	e8 24 1f 00 00       	call   80e570 <_panic>
      if (pcb->unsent != NULL) {
  80c64c:	8b 47 74             	mov    0x74(%edi),%eax
  80c64f:	85 c0                	test   %eax,%eax
  80c651:	0f 85 c8 00 00 00    	jne    80c71f <tcp_receive+0x3ec>
    while (pcb->unsent != NULL &&
  80c657:	8b 47 74             	mov    0x74(%edi),%eax
  80c65a:	85 c0                	test   %eax,%eax
  80c65c:	0f 84 f9 00 00 00    	je     80c75b <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c662:	8b 1d a4 b1 b3 00    	mov    0xb3b1a4,%ebx
  80c668:	83 ec 0c             	sub    $0xc,%esp
  80c66b:	8b 40 10             	mov    0x10(%eax),%eax
  80c66e:	ff 70 04             	pushl  0x4(%eax)
  80c671:	e8 80 b2 ff ff       	call   8078f6 <ntohl>
  80c676:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c679:	8b 47 74             	mov    0x74(%edi),%eax
  80c67c:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c680:	8b 40 10             	mov    0x10(%eax),%eax
  80c683:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c687:	89 04 24             	mov    %eax,(%esp)
  80c68a:	e8 43 b0 ff ff       	call   8076d2 <ntohs>
  80c68f:	83 c4 10             	add    $0x10,%esp
  80c692:	ba 01 00 00 00       	mov    $0x1,%edx
  80c697:	a8 01                	test   $0x1,%al
  80c699:	0f 84 99 00 00 00    	je     80c738 <tcp_receive+0x405>
  80c69f:	2b 5d e4             	sub    -0x1c(%ebp),%ebx
  80c6a2:	01 d6                	add    %edx,%esi
    while (pcb->unsent != NULL &&
  80c6a4:	39 f3                	cmp    %esi,%ebx
  80c6a6:	0f 88 af 00 00 00    	js     80c75b <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c6ac:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c6b1:	2b 47 58             	sub    0x58(%edi),%eax
  80c6b4:	85 c0                	test   %eax,%eax
  80c6b6:	0f 8f 9f 00 00 00    	jg     80c75b <tcp_receive+0x428>
      next = pcb->unsent;
  80c6bc:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c6bf:	8b 03                	mov    (%ebx),%eax
  80c6c1:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c6c4:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c6c8:	83 ec 0c             	sub    $0xc,%esp
  80c6cb:	ff 73 04             	pushl  0x4(%ebx)
  80c6ce:	e8 5a 85 ff ff       	call   804c2d <pbuf_clen>
  80c6d3:	0f b6 c0             	movzbl %al,%eax
  80c6d6:	83 c4 10             	add    $0x10,%esp
  80c6d9:	66 39 c6             	cmp    %ax,%si
  80c6dc:	0f 82 3c ff ff ff    	jb     80c61e <tcp_receive+0x2eb>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c6e2:	83 ec 0c             	sub    $0xc,%esp
  80c6e5:	ff 73 04             	pushl  0x4(%ebx)
  80c6e8:	e8 40 85 ff ff       	call   804c2d <pbuf_clen>
  80c6ed:	0f b6 c0             	movzbl %al,%eax
  80c6f0:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c6f4:	89 1c 24             	mov    %ebx,(%esp)
  80c6f7:	e8 08 90 ff ff       	call   805704 <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80c6fc:	83 c4 10             	add    $0x10,%esp
  80c6ff:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c704:	0f 84 42 ff ff ff    	je     80c64c <tcp_receive+0x319>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c70a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c70e:	0f 85 38 ff ff ff    	jne    80c64c <tcp_receive+0x319>
  80c714:	8b 47 74             	mov    0x74(%edi),%eax
  80c717:	85 c0                	test   %eax,%eax
  80c719:	0f 84 16 ff ff ff    	je     80c635 <tcp_receive+0x302>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c71f:	83 ec 0c             	sub    $0xc,%esp
  80c722:	8b 40 10             	mov    0x10(%eax),%eax
  80c725:	ff 70 04             	pushl  0x4(%eax)
  80c728:	e8 b2 af ff ff       	call   8076df <htonl>
  80c72d:	89 47 54             	mov    %eax,0x54(%edi)
  80c730:	83 c4 10             	add    $0x10,%esp
  80c733:	e9 1f ff ff ff       	jmp    80c657 <tcp_receive+0x324>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c738:	83 ec 0c             	sub    $0xc,%esp
  80c73b:	8b 47 74             	mov    0x74(%edi),%eax
  80c73e:	8b 40 10             	mov    0x10(%eax),%eax
  80c741:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c745:	50                   	push   %eax
  80c746:	e8 87 af ff ff       	call   8076d2 <ntohs>
  80c74b:	66 d1 e8             	shr    %ax
  80c74e:	89 c2                	mov    %eax,%edx
  80c750:	83 e2 01             	and    $0x1,%edx
  80c753:	83 c4 10             	add    $0x10,%esp
  80c756:	e9 44 ff ff ff       	jmp    80c69f <tcp_receive+0x36c>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c75b:	8b 47 38             	mov    0x38(%edi),%eax
  80c75e:	85 c0                	test   %eax,%eax
  80c760:	74 0b                	je     80c76d <tcp_receive+0x43a>
  80c762:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c768:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c76b:	78 71                	js     80c7de <tcp_receive+0x4ab>
  if (tcplen > 0) {
  80c76d:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80c774:	66 85 c0             	test   %ax,%ax
  80c777:	0f 84 75 08 00 00    	je     80cff2 <tcp_receive+0xcbf>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c77d:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c780:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c786:	89 d9                	mov    %ebx,%ecx
  80c788:	29 d1                	sub    %edx,%ecx
  80c78a:	89 ce                	mov    %ecx,%esi
  80c78c:	83 ee 01             	sub    $0x1,%esi
  80c78f:	78 16                	js     80c7a7 <tcp_receive+0x474>
  80c791:	be 01 00 00 00       	mov    $0x1,%esi
  80c796:	29 d6                	sub    %edx,%esi
  80c798:	0f b7 c0             	movzwl %ax,%eax
  80c79b:	29 c6                	sub    %eax,%esi
  80c79d:	01 de                	add    %ebx,%esi
  80c79f:	85 f6                	test   %esi,%esi
  80c7a1:	0f 8e 85 00 00 00    	jle    80c82c <tcp_receive+0x4f9>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c7a7:	39 da                	cmp    %ebx,%edx
  80c7a9:	0f 88 be 01 00 00    	js     80c96d <tcp_receive+0x63a>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c7af:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c7b3:	89 d1                	mov    %edx,%ecx
  80c7b5:	29 c1                	sub    %eax,%ecx
  80c7b7:	8d 41 01             	lea    0x1(%ecx),%eax
  80c7ba:	29 d8                	sub    %ebx,%eax
  80c7bc:	85 c0                	test   %eax,%eax
  80c7be:	0f 8e be 01 00 00    	jle    80c982 <tcp_receive+0x64f>
      tcp_ack_now(pcb);
  80c7c4:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c7c8:	83 ec 0c             	sub    $0xc,%esp
  80c7cb:	57                   	push   %edi
  80c7cc:	e8 55 b8 ff ff       	call   808026 <tcp_output>
  80c7d1:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80c7d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80c7d9:	e9 49 08 00 00       	jmp    80d027 <tcp_receive+0xcf4>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c7de:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
      m = m - (pcb->sa >> 3);
  80c7e4:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c7e8:	89 d3                	mov    %edx,%ebx
  80c7ea:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c7ee:	89 f1                	mov    %esi,%ecx
  80c7f0:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80c7f2:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80c7f4:	01 ca                	add    %ecx,%edx
  80c7f6:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80c7fa:	29 f0                	sub    %esi,%eax
  80c7fc:	01 d8                	add    %ebx,%eax
  80c7fe:	66 85 c9             	test   %cx,%cx
  80c801:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80c804:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80c808:	89 cb                	mov    %ecx,%ebx
  80c80a:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80c80e:	29 d9                	sub    %ebx,%ecx
  80c810:	01 c8                	add    %ecx,%eax
  80c812:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c816:	66 c1 fa 03          	sar    $0x3,%dx
  80c81a:	01 d0                	add    %edx,%eax
  80c81c:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80c820:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80c827:	e9 41 ff ff ff       	jmp    80c76d <tcp_receive+0x43a>
      off = pcb->rcv_nxt - seqno;
  80c82c:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c82e:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c834:	85 db                	test   %ebx,%ebx
  80c836:	0f 84 a4 00 00 00    	je     80c8e0 <tcp_receive+0x5ad>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c83c:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c842:	0f 8f af 00 00 00    	jg     80c8f7 <tcp_receive+0x5c4>
      if (inseg.p->len < off) {
  80c848:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c84c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c84f:	39 ca                	cmp    %ecx,%edx
  80c851:	0f 8d e5 00 00 00    	jge    80c93c <tcp_receive+0x609>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c857:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c85b:	0f b7 d6             	movzwl %si,%edx
  80c85e:	39 ca                	cmp    %ecx,%edx
  80c860:	0f 8c a8 00 00 00    	jl     80c90e <tcp_receive+0x5db>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c866:	29 ce                	sub    %ecx,%esi
  80c868:	89 f1                	mov    %esi,%ecx
  80c86a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80c86d:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80c86f:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c873:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c879:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80c87b:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c87f:	39 c2                	cmp    %eax,%edx
  80c881:	7c ea                	jl     80c86d <tcp_receive+0x53a>
        if(pbuf_header(p, (s16_t)-off)) {
  80c883:	83 ec 08             	sub    $0x8,%esp
  80c886:	f7 d8                	neg    %eax
  80c888:	98                   	cwtl   
  80c889:	50                   	push   %eax
  80c88a:	53                   	push   %ebx
  80c88b:	e8 86 7e ff ff       	call   804716 <pbuf_header>
  80c890:	83 c4 10             	add    $0x10,%esp
  80c893:	84 c0                	test   %al,%al
  80c895:	0f 85 8a 00 00 00    	jne    80c925 <tcp_receive+0x5f2>
      inseg.dataptr = p->payload;
  80c89b:	8b 43 04             	mov    0x4(%ebx),%eax
  80c89e:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c8a3:	8b 57 24             	mov    0x24(%edi),%edx
  80c8a6:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c8ad:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80c8b4:	29 d0                	sub    %edx,%eax
  80c8b6:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c8bc:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80c8c2:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c8c7:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c8ca:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c8d0:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c8d3:	39 da                	cmp    %ebx,%edx
  80c8d5:	0f 88 e9 fe ff ff    	js     80c7c4 <tcp_receive+0x491>
  80c8db:	e9 cf fe ff ff       	jmp    80c7af <tcp_receive+0x47c>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c8e0:	83 ec 04             	sub    $0x4,%esp
  80c8e3:	68 cb 31 81 00       	push   $0x8131cb
  80c8e8:	68 e5 03 00 00       	push   $0x3e5
  80c8ed:	68 b4 31 81 00       	push   $0x8131b4
  80c8f2:	e8 79 1c 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c8f7:	83 ec 04             	sub    $0x4,%esp
  80c8fa:	68 db 31 81 00       	push   $0x8131db
  80c8ff:	68 e6 03 00 00       	push   $0x3e6
  80c904:	68 b4 31 81 00       	push   $0x8131b4
  80c909:	e8 62 1c 00 00       	call   80e570 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c90e:	83 ec 04             	sub    $0x4,%esp
  80c911:	68 ea 31 81 00       	push   $0x8131ea
  80c916:	68 e8 03 00 00       	push   $0x3e8
  80c91b:	68 b4 31 81 00       	push   $0x8131b4
  80c920:	e8 4b 1c 00 00       	call   80e570 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80c925:	83 ec 04             	sub    $0x4,%esp
  80c928:	68 fa 31 81 00       	push   $0x8131fa
  80c92d:	68 f5 03 00 00       	push   $0x3f5
  80c932:	68 b4 31 81 00       	push   $0x8131b4
  80c937:	e8 34 1c 00 00       	call   80e570 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c93c:	83 ec 08             	sub    $0x8,%esp
  80c93f:	f7 d9                	neg    %ecx
  80c941:	0f bf c1             	movswl %cx,%eax
  80c944:	50                   	push   %eax
  80c945:	53                   	push   %ebx
  80c946:	e8 cb 7d ff ff       	call   804716 <pbuf_header>
  80c94b:	83 c4 10             	add    $0x10,%esp
  80c94e:	84 c0                	test   %al,%al
  80c950:	0f 84 45 ff ff ff    	je     80c89b <tcp_receive+0x568>
          LWIP_ASSERT("pbuf_header failed", 0);
  80c956:	83 ec 04             	sub    $0x4,%esp
  80c959:	68 fa 31 81 00       	push   $0x8131fa
  80c95e:	68 fa 03 00 00       	push   $0x3fa
  80c963:	68 b4 31 81 00       	push   $0x8131b4
  80c968:	e8 03 1c 00 00       	call   80e570 <_panic>
        tcp_ack_now(pcb);
  80c96d:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c971:	83 ec 0c             	sub    $0xc,%esp
  80c974:	57                   	push   %edi
  80c975:	e8 ac b6 ff ff       	call   808026 <tcp_output>
  80c97a:	83 c4 10             	add    $0x10,%esp
  80c97d:	e9 48 ff ff ff       	jmp    80c8ca <tcp_receive+0x597>
      if (pcb->rcv_nxt == seqno) {
  80c982:	39 da                	cmp    %ebx,%edx
  80c984:	0f 85 d2 03 00 00    	jne    80cd5c <tcp_receive+0xa29>
        if (pcb->ooseq != NULL &&
  80c98a:	8b 47 7c             	mov    0x7c(%edi),%eax
  80c98d:	85 c0                	test   %eax,%eax
  80c98f:	74 1d                	je     80c9ae <tcp_receive+0x67b>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80c991:	8b 48 10             	mov    0x10(%eax),%ecx
  80c994:	8b 59 04             	mov    0x4(%ecx),%ebx
  80c997:	0f b7 0d c0 b1 b3 00 	movzwl 0xb3b1c0,%ecx
  80c99e:	89 de                	mov    %ebx,%esi
  80c9a0:	29 ce                	sub    %ecx,%esi
  80c9a2:	89 f1                	mov    %esi,%ecx
  80c9a4:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80c9a6:	85 c9                	test   %ecx,%ecx
  80c9a8:	0f 8e b0 00 00 00    	jle    80ca5e <tcp_receive+0x72b>
        tcplen = TCP_TCPLEN(&inseg);
  80c9ae:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80c9b5:	83 ec 0c             	sub    $0xc,%esp
  80c9b8:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c9bd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9c1:	50                   	push   %eax
  80c9c2:	e8 0b ad ff ff       	call   8076d2 <ntohs>
  80c9c7:	83 c4 10             	add    $0x10,%esp
  80c9ca:	ba 01 00 00 00       	mov    $0x1,%edx
  80c9cf:	a8 01                	test   $0x1,%al
  80c9d1:	0f 84 00 01 00 00    	je     80cad7 <tcp_receive+0x7a4>
  80c9d7:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80c9da:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
        if (pcb->state != CLOSE_WAIT) {
  80c9e0:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80c9e4:	74 06                	je     80c9ec <tcp_receive+0x6b9>
          pcb->rcv_nxt += tcplen;
  80c9e6:	0f b7 d0             	movzwl %ax,%edx
  80c9e9:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80c9ec:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80c9f0:	89 ca                	mov    %ecx,%edx
  80c9f2:	29 c2                	sub    %eax,%edx
  80c9f4:	66 39 c8             	cmp    %cx,%ax
  80c9f7:	b9 00 00 00 00       	mov    $0x0,%ecx
  80c9fc:	0f 47 d1             	cmova  %ecx,%edx
  80c9ff:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80ca03:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80ca07:	89 ca                	mov    %ecx,%edx
  80ca09:	29 c2                	sub    %eax,%edx
  80ca0b:	66 39 c8             	cmp    %cx,%ax
  80ca0e:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca13:	0f 46 c2             	cmovbe %edx,%eax
  80ca16:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80ca1a:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80ca1f:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ca24:	74 0f                	je     80ca35 <tcp_receive+0x702>
          recv_data = inseg.p;
  80ca26:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          inseg.p = NULL;
  80ca2b:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80ca32:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80ca35:	83 ec 0c             	sub    $0xc,%esp
  80ca38:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ca3d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca41:	50                   	push   %eax
  80ca42:	e8 8b ac ff ff       	call   8076d2 <ntohs>
  80ca47:	83 c4 10             	add    $0x10,%esp
  80ca4a:	a8 01                	test   $0x1,%al
  80ca4c:	0f 84 e4 01 00 00    	je     80cc36 <tcp_receive+0x903>
          recv_flags = TF_GOT_FIN;
  80ca52:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80ca59:	e9 d8 01 00 00       	jmp    80cc36 <tcp_receive+0x903>
          if (pcb->ooseq->len > 0) {
  80ca5e:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80ca63:	74 23                	je     80ca88 <tcp_receive+0x755>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80ca65:	29 d3                	sub    %edx,%ebx
  80ca67:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80ca6e:	83 ec 08             	sub    $0x8,%esp
  80ca71:	0f b7 db             	movzwl %bx,%ebx
  80ca74:	53                   	push   %ebx
  80ca75:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80ca7b:	e8 9b 80 ff ff       	call   804b1b <pbuf_realloc>
  80ca80:	83 c4 10             	add    $0x10,%esp
  80ca83:	e9 26 ff ff ff       	jmp    80c9ae <tcp_receive+0x67b>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80ca88:	83 ec 0c             	sub    $0xc,%esp
  80ca8b:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ca90:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca94:	50                   	push   %eax
  80ca95:	e8 38 ac ff ff       	call   8076d2 <ntohs>
  80ca9a:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80ca9c:	8b 47 7c             	mov    0x7c(%edi),%eax
  80ca9f:	8b 40 10             	mov    0x10(%eax),%eax
  80caa2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80caa6:	89 04 24             	mov    %eax,(%esp)
  80caa9:	e8 24 ac ff ff       	call   8076d2 <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80caae:	31 c3                	xor    %eax,%ebx
  80cab0:	83 c4 10             	add    $0x10,%esp
  80cab3:	f6 c3 03             	test   $0x3,%bl
  80cab6:	0f 85 f2 fe ff ff    	jne    80c9ae <tcp_receive+0x67b>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80cabc:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80cabf:	8b 10                	mov    (%eax),%edx
  80cac1:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80cac4:	83 ec 08             	sub    $0x8,%esp
  80cac7:	50                   	push   %eax
  80cac8:	6a 04                	push   $0x4
  80caca:	e8 c4 79 ff ff       	call   804493 <memp_free>
  80cacf:	83 c4 10             	add    $0x10,%esp
  80cad2:	e9 d7 fe ff ff       	jmp    80c9ae <tcp_receive+0x67b>
        tcplen = TCP_TCPLEN(&inseg);
  80cad7:	83 ec 0c             	sub    $0xc,%esp
  80cada:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cadf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cae3:	50                   	push   %eax
  80cae4:	e8 e9 ab ff ff       	call   8076d2 <ntohs>
  80cae9:	66 d1 e8             	shr    %ax
  80caec:	89 c2                	mov    %eax,%edx
  80caee:	83 e2 01             	and    $0x1,%edx
  80caf1:	83 c4 10             	add    $0x10,%esp
  80caf4:	e9 de fe ff ff       	jmp    80c9d7 <tcp_receive+0x6a4>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80caf9:	83 ec 0c             	sub    $0xc,%esp
  80cafc:	8b 43 10             	mov    0x10(%ebx),%eax
  80caff:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb03:	50                   	push   %eax
  80cb04:	e8 c9 ab ff ff       	call   8076d2 <ntohs>
  80cb09:	66 d1 e8             	shr    %ax
  80cb0c:	89 c2                	mov    %eax,%edx
  80cb0e:	83 e2 01             	and    $0x1,%edx
  80cb11:	83 c4 10             	add    $0x10,%esp
  80cb14:	e9 5d 01 00 00       	jmp    80cc76 <tcp_receive+0x943>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cb19:	83 ec 0c             	sub    $0xc,%esp
  80cb1c:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb1f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb23:	50                   	push   %eax
  80cb24:	e8 a9 ab ff ff       	call   8076d2 <ntohs>
  80cb29:	66 d1 e8             	shr    %ax
  80cb2c:	89 c2                	mov    %eax,%edx
  80cb2e:	83 e2 01             	and    $0x1,%edx
  80cb31:	83 c4 10             	add    $0x10,%esp
  80cb34:	e9 6d 01 00 00       	jmp    80cca6 <tcp_receive+0x973>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80cb39:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cb3d:	83 ec 0c             	sub    $0xc,%esp
  80cb40:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb43:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb47:	50                   	push   %eax
  80cb48:	e8 85 ab ff ff       	call   8076d2 <ntohs>
  80cb4d:	83 c4 10             	add    $0x10,%esp
  80cb50:	ba 01 00 00 00       	mov    $0x1,%edx
  80cb55:	a8 01                	test   $0x1,%al
  80cb57:	74 0b                	je     80cb64 <tcp_receive+0x831>
  80cb59:	01 d6                	add    %edx,%esi
  80cb5b:	66 29 77 28          	sub    %si,0x28(%edi)
  80cb5f:	e9 53 01 00 00       	jmp    80ccb7 <tcp_receive+0x984>
  80cb64:	83 ec 0c             	sub    $0xc,%esp
  80cb67:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb6a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb6e:	50                   	push   %eax
  80cb6f:	e8 5e ab ff ff       	call   8076d2 <ntohs>
  80cb74:	66 d1 e8             	shr    %ax
  80cb77:	89 c2                	mov    %eax,%edx
  80cb79:	83 e2 01             	and    $0x1,%edx
  80cb7c:	83 c4 10             	add    $0x10,%esp
  80cb7f:	eb d8                	jmp    80cb59 <tcp_receive+0x826>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cb81:	83 ec 0c             	sub    $0xc,%esp
  80cb84:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb87:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb8b:	50                   	push   %eax
  80cb8c:	e8 41 ab ff ff       	call   8076d2 <ntohs>
  80cb91:	66 d1 e8             	shr    %ax
  80cb94:	89 c2                	mov    %eax,%edx
  80cb96:	83 e2 01             	and    $0x1,%edx
  80cb99:	83 c4 10             	add    $0x10,%esp
  80cb9c:	e9 41 01 00 00       	jmp    80cce2 <tcp_receive+0x9af>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cba1:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cba5:	83 ec 0c             	sub    $0xc,%esp
  80cba8:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbab:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbaf:	50                   	push   %eax
  80cbb0:	e8 1d ab ff ff       	call   8076d2 <ntohs>
  80cbb5:	83 c4 10             	add    $0x10,%esp
  80cbb8:	ba 01 00 00 00       	mov    $0x1,%edx
  80cbbd:	a8 01                	test   $0x1,%al
  80cbbf:	74 0b                	je     80cbcc <tcp_receive+0x899>
  80cbc1:	01 d6                	add    %edx,%esi
  80cbc3:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80cbc7:	e9 27 01 00 00       	jmp    80ccf3 <tcp_receive+0x9c0>
  80cbcc:	83 ec 0c             	sub    $0xc,%esp
  80cbcf:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbd2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbd6:	50                   	push   %eax
  80cbd7:	e8 f6 aa ff ff       	call   8076d2 <ntohs>
  80cbdc:	66 d1 e8             	shr    %ax
  80cbdf:	89 c2                	mov    %eax,%edx
  80cbe1:	83 e2 01             	and    $0x1,%edx
  80cbe4:	83 c4 10             	add    $0x10,%esp
  80cbe7:	eb d8                	jmp    80cbc1 <tcp_receive+0x88e>
              pbuf_cat(recv_data, cseg->p);
  80cbe9:	83 ec 08             	sub    $0x8,%esp
  80cbec:	50                   	push   %eax
  80cbed:	52                   	push   %edx
  80cbee:	e8 63 80 ff ff       	call   804c56 <pbuf_cat>
  80cbf3:	83 c4 10             	add    $0x10,%esp
            cseg->p = NULL;
  80cbf6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cbfd:	83 ec 0c             	sub    $0xc,%esp
  80cc00:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc03:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc07:	50                   	push   %eax
  80cc08:	e8 c5 aa ff ff       	call   8076d2 <ntohs>
  80cc0d:	83 c4 10             	add    $0x10,%esp
  80cc10:	a8 01                	test   $0x1,%al
  80cc12:	74 11                	je     80cc25 <tcp_receive+0x8f2>
            recv_flags = TF_GOT_FIN;
  80cc14:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cc1b:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cc1f:	0f 84 f4 00 00 00    	je     80cd19 <tcp_receive+0x9e6>
          pcb->ooseq = cseg->next;
  80cc25:	8b 03                	mov    (%ebx),%eax
  80cc27:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cc2a:	83 ec 0c             	sub    $0xc,%esp
  80cc2d:	53                   	push   %ebx
  80cc2e:	e8 d1 8a ff ff       	call   805704 <tcp_seg_free>
  80cc33:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80cc36:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cc39:	85 db                	test   %ebx,%ebx
  80cc3b:	0f 84 e4 00 00 00    	je     80cd25 <tcp_receive+0x9f2>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cc41:	8b 53 10             	mov    0x10(%ebx),%edx
  80cc44:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80cc47:	3b 47 24             	cmp    0x24(%edi),%eax
  80cc4a:	0f 85 d5 00 00 00    	jne    80cd25 <tcp_receive+0x9f2>
          seqno = pcb->ooseq->tcphdr->seqno;
  80cc50:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cc55:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cc59:	83 ec 0c             	sub    $0xc,%esp
  80cc5c:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80cc60:	50                   	push   %eax
  80cc61:	e8 6c aa ff ff       	call   8076d2 <ntohs>
  80cc66:	83 c4 10             	add    $0x10,%esp
  80cc69:	ba 01 00 00 00       	mov    $0x1,%edx
  80cc6e:	a8 01                	test   $0x1,%al
  80cc70:	0f 84 83 fe ff ff    	je     80caf9 <tcp_receive+0x7c6>
  80cc76:	01 d6                	add    %edx,%esi
  80cc78:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cc7b:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cc7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cc82:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cc86:	83 ec 0c             	sub    $0xc,%esp
  80cc89:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc8c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc90:	50                   	push   %eax
  80cc91:	e8 3c aa ff ff       	call   8076d2 <ntohs>
  80cc96:	83 c4 10             	add    $0x10,%esp
  80cc99:	ba 01 00 00 00       	mov    $0x1,%edx
  80cc9e:	a8 01                	test   $0x1,%al
  80cca0:	0f 84 73 fe ff ff    	je     80cb19 <tcp_receive+0x7e6>
  80cca6:	01 d6                	add    %edx,%esi
  80cca8:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80ccab:	0f 8d 88 fe ff ff    	jge    80cb39 <tcp_receive+0x806>
            pcb->rcv_wnd = 0;
  80ccb1:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80ccb7:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80ccbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ccbe:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ccc2:	83 ec 0c             	sub    $0xc,%esp
  80ccc5:	8b 43 10             	mov    0x10(%ebx),%eax
  80ccc8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cccc:	50                   	push   %eax
  80cccd:	e8 00 aa ff ff       	call   8076d2 <ntohs>
  80ccd2:	83 c4 10             	add    $0x10,%esp
  80ccd5:	ba 01 00 00 00       	mov    $0x1,%edx
  80ccda:	a8 01                	test   $0x1,%al
  80ccdc:	0f 84 9f fe ff ff    	je     80cb81 <tcp_receive+0x84e>
  80cce2:	01 d6                	add    %edx,%esi
  80cce4:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cce7:	0f 8d b4 fe ff ff    	jge    80cba1 <tcp_receive+0x86e>
            pcb->rcv_ann_wnd = 0;
  80cced:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80ccf3:	8b 43 04             	mov    0x4(%ebx),%eax
  80ccf6:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ccfb:	0f 84 fc fe ff ff    	je     80cbfd <tcp_receive+0x8ca>
            if (recv_data) {
  80cd01:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80cd07:	85 d2                	test   %edx,%edx
  80cd09:	0f 85 da fe ff ff    	jne    80cbe9 <tcp_receive+0x8b6>
              recv_data = cseg->p;
  80cd0f:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
  80cd14:	e9 dd fe ff ff       	jmp    80cbf6 <tcp_receive+0x8c3>
              pcb->state = CLOSE_WAIT;
  80cd19:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80cd20:	e9 00 ff ff ff       	jmp    80cc25 <tcp_receive+0x8f2>
        tcp_ack(pcb);
  80cd25:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cd29:	a8 01                	test   $0x1,%al
  80cd2b:	75 10                	jne    80cd3d <tcp_receive+0xa0a>
  80cd2d:	83 c8 01             	or     $0x1,%eax
  80cd30:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80cd33:	b8 01 00 00 00       	mov    $0x1,%eax
  80cd38:	e9 ea 02 00 00       	jmp    80d027 <tcp_receive+0xcf4>
        tcp_ack(pcb);
  80cd3d:	83 e0 fe             	and    $0xfffffffe,%eax
  80cd40:	83 c8 02             	or     $0x2,%eax
  80cd43:	88 47 20             	mov    %al,0x20(%edi)
  80cd46:	83 ec 0c             	sub    $0xc,%esp
  80cd49:	57                   	push   %edi
  80cd4a:	e8 d7 b2 ff ff       	call   808026 <tcp_output>
  80cd4f:	83 c4 10             	add    $0x10,%esp
        accepted_inseq = 1; 
  80cd52:	b8 01 00 00 00       	mov    $0x1,%eax
  80cd57:	e9 cb 02 00 00       	jmp    80d027 <tcp_receive+0xcf4>
        tcp_ack_now(pcb);
  80cd5c:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cd60:	83 ec 0c             	sub    $0xc,%esp
  80cd63:	57                   	push   %edi
  80cd64:	e8 bd b2 ff ff       	call   808026 <tcp_output>
        if (pcb->ooseq == NULL) {
  80cd69:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cd6c:	83 c4 10             	add    $0x10,%esp
  80cd6f:	85 db                	test   %ebx,%ebx
  80cd71:	74 1e                	je     80cd91 <tcp_receive+0xa5e>
            if (seqno == next->tcphdr->seqno) {
  80cd73:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80cd79:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cd7c:	8d 51 01             	lea    0x1(%ecx),%edx
  80cd7f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80cd82:	be 00 00 00 00       	mov    $0x0,%esi
  80cd87:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cd8a:	89 c7                	mov    %eax,%edi
  80cd8c:	e9 e1 00 00 00       	jmp    80ce72 <tcp_receive+0xb3f>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cd91:	83 ec 0c             	sub    $0xc,%esp
  80cd94:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cd99:	e8 df 89 ff ff       	call   80577d <tcp_seg_copy>
  80cd9e:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cda1:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cda4:	b8 00 00 00 00       	mov    $0x0,%eax
  80cda9:	e9 79 02 00 00       	jmp    80d027 <tcp_receive+0xcf4>
  80cdae:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80cdb1:	b8 00 00 00 00       	mov    $0x0,%eax
              if (inseg.len > next->len) {
  80cdb6:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cdba:	66 39 0d c0 b1 b3 00 	cmp    %cx,0xb3b1c0
  80cdc1:	0f 86 60 02 00 00    	jbe    80d027 <tcp_receive+0xcf4>
                cseg = tcp_seg_copy(&inseg);
  80cdc7:	83 ec 0c             	sub    $0xc,%esp
  80cdca:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cdcf:	e8 a9 89 ff ff       	call   80577d <tcp_seg_copy>
  80cdd4:	89 c1                	mov    %eax,%ecx
  80cdd6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80cdd9:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cddc:	b8 00 00 00 00       	mov    $0x0,%eax
                if (cseg != NULL) {
  80cde1:	85 c9                	test   %ecx,%ecx
  80cde3:	0f 84 3e 02 00 00    	je     80d027 <tcp_receive+0xcf4>
                  cseg->next = next->next;
  80cde9:	8b 03                	mov    (%ebx),%eax
  80cdeb:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cded:	85 f6                	test   %esi,%esi
  80cdef:	74 63                	je     80ce54 <tcp_receive+0xb21>
                    prev->next = cseg;
  80cdf1:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80cdf3:	83 ec 0c             	sub    $0xc,%esp
  80cdf6:	53                   	push   %ebx
  80cdf7:	e8 08 89 ff ff       	call   805704 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cdfc:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80cdff:	8b 16                	mov    (%esi),%edx
  80ce01:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce04:	b8 00 00 00 00       	mov    $0x0,%eax
                  if (cseg->next != NULL) {
  80ce09:	85 d2                	test   %edx,%edx
  80ce0b:	0f 84 16 02 00 00    	je     80d027 <tcp_receive+0xcf4>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80ce11:	8b 1d a8 b1 b3 00    	mov    0xb3b1a8,%ebx
  80ce17:	8b 42 10             	mov    0x10(%edx),%eax
  80ce1a:	8b 50 04             	mov    0x4(%eax),%edx
  80ce1d:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80ce21:	01 d9                	add    %ebx,%ecx
  80ce23:	29 d1                	sub    %edx,%ecx
  u8_t accepted_inseq = 0;
  80ce25:	b8 00 00 00 00       	mov    $0x0,%eax
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80ce2a:	85 c9                	test   %ecx,%ecx
  80ce2c:	0f 8e f5 01 00 00    	jle    80d027 <tcp_receive+0xcf4>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80ce32:	29 da                	sub    %ebx,%edx
  80ce34:	66 89 56 0c          	mov    %dx,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80ce38:	83 ec 08             	sub    $0x8,%esp
  80ce3b:	0f b7 d2             	movzwl %dx,%edx
  80ce3e:	52                   	push   %edx
  80ce3f:	ff 76 04             	pushl  0x4(%esi)
  80ce42:	e8 d4 7c ff ff       	call   804b1b <pbuf_realloc>
  80ce47:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce4a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce4f:	e9 d3 01 00 00       	jmp    80d027 <tcp_receive+0xcf4>
                    pcb->ooseq = cseg;
  80ce54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ce57:	89 47 7c             	mov    %eax,0x7c(%edi)
  80ce5a:	eb 97                	jmp    80cdf3 <tcp_receive+0xac0>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80ce5c:	39 c1                	cmp    %eax,%ecx
  80ce5e:	0f 88 aa 00 00 00    	js     80cf0e <tcp_receive+0xbdb>
              if (next->next == NULL &&
  80ce64:	8b 13                	mov    (%ebx),%edx
  80ce66:	89 de                	mov    %ebx,%esi
  80ce68:	85 d2                	test   %edx,%edx
  80ce6a:	0f 84 1a 01 00 00    	je     80cf8a <tcp_receive+0xc57>
  80ce70:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80ce72:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce75:	8b 40 04             	mov    0x4(%eax),%eax
  80ce78:	39 c8                	cmp    %ecx,%eax
  80ce7a:	0f 84 2e ff ff ff    	je     80cdae <tcp_receive+0xa7b>
              if (prev == NULL) {
  80ce80:	85 f6                	test   %esi,%esi
  80ce82:	74 d8                	je     80ce5c <tcp_receive+0xb29>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80ce84:	8b 56 10             	mov    0x10(%esi),%edx
  80ce87:	3b 7a 04             	cmp    0x4(%edx),%edi
  80ce8a:	78 d8                	js     80ce64 <tcp_receive+0xb31>
  80ce8c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80ce8f:	29 c2                	sub    %eax,%edx
  80ce91:	85 d2                	test   %edx,%edx
  80ce93:	7f cf                	jg     80ce64 <tcp_receive+0xb31>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80ce95:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80ce9c:	01 ca                	add    %ecx,%edx
  80ce9e:	29 c2                	sub    %eax,%edx
  80cea0:	85 d2                	test   %edx,%edx
  80cea2:	0f 8f c0 00 00 00    	jg     80cf68 <tcp_receive+0xc35>
                cseg = tcp_seg_copy(&inseg);
  80cea8:	83 ec 0c             	sub    $0xc,%esp
  80ceab:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80ceb0:	e8 c8 88 ff ff       	call   80577d <tcp_seg_copy>
  80ceb5:	89 c2                	mov    %eax,%edx
                if (cseg != NULL) {
  80ceb7:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ceba:	b8 00 00 00 00       	mov    $0x0,%eax
                if (cseg != NULL) {
  80cebf:	85 d2                	test   %edx,%edx
  80cec1:	0f 84 60 01 00 00    	je     80d027 <tcp_receive+0xcf4>
                  cseg->next = next;
  80cec7:	89 1a                	mov    %ebx,(%edx)
                  prev->next = cseg;
  80cec9:	89 16                	mov    %edx,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cecb:	8b 46 10             	mov    0x10(%esi),%eax
  80cece:	8b 58 04             	mov    0x4(%eax),%ebx
  80ced1:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80ced7:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cedb:	01 d9                	add    %ebx,%ecx
  80cedd:	29 d1                	sub    %edx,%ecx
  u8_t accepted_inseq = 0;
  80cedf:	b8 00 00 00 00       	mov    $0x0,%eax
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cee4:	85 c9                	test   %ecx,%ecx
  80cee6:	0f 8e 3b 01 00 00    	jle    80d027 <tcp_receive+0xcf4>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80ceec:	29 da                	sub    %ebx,%edx
  80ceee:	66 89 56 0c          	mov    %dx,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cef2:	83 ec 08             	sub    $0x8,%esp
  80cef5:	0f b7 d2             	movzwl %dx,%edx
  80cef8:	52                   	push   %edx
  80cef9:	ff 76 04             	pushl  0x4(%esi)
  80cefc:	e8 1a 7c ff ff       	call   804b1b <pbuf_realloc>
  80cf01:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf04:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf09:	e9 19 01 00 00       	jmp    80d027 <tcp_receive+0xcf4>
  80cf0e:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cf11:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cf18:	01 ca                	add    %ecx,%edx
  80cf1a:	29 c2                	sub    %eax,%edx
  80cf1c:	85 d2                	test   %edx,%edx
  80cf1e:	7f 29                	jg     80cf49 <tcp_receive+0xc16>
                  cseg = tcp_seg_copy(&inseg);
  80cf20:	83 ec 0c             	sub    $0xc,%esp
  80cf23:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cf28:	e8 50 88 ff ff       	call   80577d <tcp_seg_copy>
  80cf2d:	89 c2                	mov    %eax,%edx
                  if (cseg != NULL) {
  80cf2f:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf32:	b8 00 00 00 00       	mov    $0x0,%eax
                  if (cseg != NULL) {
  80cf37:	85 d2                	test   %edx,%edx
  80cf39:	0f 84 e8 00 00 00    	je     80d027 <tcp_receive+0xcf4>
                    cseg->next = next;
  80cf3f:	89 1a                	mov    %ebx,(%edx)
                    pcb->ooseq = cseg;
  80cf41:	89 57 7c             	mov    %edx,0x7c(%edi)
  80cf44:	e9 de 00 00 00       	jmp    80d027 <tcp_receive+0xcf4>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf49:	29 c8                	sub    %ecx,%eax
  80cf4b:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80cf51:	83 ec 08             	sub    $0x8,%esp
  80cf54:	0f b7 c0             	movzwl %ax,%eax
  80cf57:	50                   	push   %eax
  80cf58:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cf5e:	e8 b8 7b ff ff       	call   804b1b <pbuf_realloc>
  80cf63:	83 c4 10             	add    $0x10,%esp
  80cf66:	eb b8                	jmp    80cf20 <tcp_receive+0xbed>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf68:	29 c8                	sub    %ecx,%eax
  80cf6a:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80cf70:	83 ec 08             	sub    $0x8,%esp
  80cf73:	0f b7 c0             	movzwl %ax,%eax
  80cf76:	50                   	push   %eax
  80cf77:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cf7d:	e8 99 7b ff ff       	call   804b1b <pbuf_realloc>
  80cf82:	83 c4 10             	add    $0x10,%esp
  80cf85:	e9 1e ff ff ff       	jmp    80cea8 <tcp_receive+0xb75>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80cf8a:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80cf8c:	b8 00 00 00 00       	mov    $0x0,%eax
              if (next->next == NULL &&
  80cf91:	85 c9                	test   %ecx,%ecx
  80cf93:	0f 8e 8e 00 00 00    	jle    80d027 <tcp_receive+0xcf4>
                next->next = tcp_seg_copy(&inseg);
  80cf99:	83 ec 0c             	sub    $0xc,%esp
  80cf9c:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cfa1:	e8 d7 87 ff ff       	call   80577d <tcp_seg_copy>
  80cfa6:	89 c2                	mov    %eax,%edx
  80cfa8:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80cfaa:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfad:	b8 00 00 00 00       	mov    $0x0,%eax
                if (next->next != NULL) {
  80cfb2:	85 d2                	test   %edx,%edx
  80cfb4:	74 71                	je     80d027 <tcp_receive+0xcf4>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cfb6:	8b 43 10             	mov    0x10(%ebx),%eax
  80cfb9:	8b 70 04             	mov    0x4(%eax),%esi
  80cfbc:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cfc2:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cfc6:	01 f1                	add    %esi,%ecx
  80cfc8:	29 d1                	sub    %edx,%ecx
  u8_t accepted_inseq = 0;
  80cfca:	b8 00 00 00 00       	mov    $0x0,%eax
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cfcf:	85 c9                	test   %ecx,%ecx
  80cfd1:	7e 54                	jle    80d027 <tcp_receive+0xcf4>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80cfd3:	29 f2                	sub    %esi,%edx
  80cfd5:	66 89 53 0c          	mov    %dx,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80cfd9:	83 ec 08             	sub    $0x8,%esp
  80cfdc:	0f b7 d2             	movzwl %dx,%edx
  80cfdf:	52                   	push   %edx
  80cfe0:	ff 73 04             	pushl  0x4(%ebx)
  80cfe3:	e8 33 7b ff ff       	call   804b1b <pbuf_realloc>
  80cfe8:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfeb:	b8 00 00 00 00       	mov    $0x0,%eax
  80cff0:	eb 35                	jmp    80d027 <tcp_receive+0xcf4>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80cff2:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80cff7:	8b 4f 24             	mov    0x24(%edi),%ecx
  80cffa:	39 c8                	cmp    %ecx,%eax
  80cffc:	78 14                	js     80d012 <tcp_receive+0xcdf>
  80cffe:	8d 50 01             	lea    0x1(%eax),%edx
  80d001:	29 ca                	sub    %ecx,%edx
  80d003:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80d007:	29 c2                	sub    %eax,%edx
  u8_t accepted_inseq = 0;
  80d009:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d00e:	85 d2                	test   %edx,%edx
  80d010:	7e 15                	jle    80d027 <tcp_receive+0xcf4>
      tcp_ack_now(pcb);
  80d012:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d016:	83 ec 0c             	sub    $0xc,%esp
  80d019:	57                   	push   %edi
  80d01a:	e8 07 b0 ff ff       	call   808026 <tcp_output>
  80d01f:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d022:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d027:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d02a:	5b                   	pop    %ebx
  80d02b:	5e                   	pop    %esi
  80d02c:	5f                   	pop    %edi
  80d02d:	5d                   	pop    %ebp
  80d02e:	c3                   	ret    

0080d02f <tcp_input>:
{
  80d02f:	55                   	push   %ebp
  80d030:	89 e5                	mov    %esp,%ebp
  80d032:	57                   	push   %edi
  80d033:	56                   	push   %esi
  80d034:	53                   	push   %ebx
  80d035:	83 ec 38             	sub    $0x38,%esp
  80d038:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d03b:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d03e:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d044:	0f b7 03             	movzwl (%ebx),%eax
  80d047:	50                   	push   %eax
  80d048:	e8 85 a6 ff ff       	call   8076d2 <ntohs>
  80d04d:	66 c1 e8 08          	shr    $0x8,%ax
  80d051:	83 e0 0f             	and    $0xf,%eax
  80d054:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d057:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d05c:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d061:	0f b7 00             	movzwl (%eax),%eax
  80d064:	89 04 24             	mov    %eax,(%esp)
  80d067:	e8 66 a6 ff ff       	call   8076d2 <ntohs>
  80d06c:	83 c4 08             	add    $0x8,%esp
  80d06f:	66 c1 e8 06          	shr    $0x6,%ax
  80d073:	83 e0 3c             	and    $0x3c,%eax
  80d076:	f7 d8                	neg    %eax
  80d078:	98                   	cwtl   
  80d079:	50                   	push   %eax
  80d07a:	56                   	push   %esi
  80d07b:	e8 96 76 ff ff       	call   804716 <pbuf_header>
  80d080:	83 c4 10             	add    $0x10,%esp
  80d083:	84 c0                	test   %al,%al
  80d085:	75 07                	jne    80d08e <tcp_input+0x5f>
  80d087:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d08c:	77 14                	ja     80d0a2 <tcp_input+0x73>
    pbuf_free(p);
  80d08e:	83 ec 0c             	sub    $0xc,%esp
  80d091:	56                   	push   %esi
  80d092:	e8 4c 77 ff ff       	call   8047e3 <pbuf_free>
    return;
  80d097:	83 c4 10             	add    $0x10,%esp
}
  80d09a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d09d:	5b                   	pop    %ebx
  80d09e:	5e                   	pop    %esi
  80d09f:	5f                   	pop    %edi
  80d0a0:	5d                   	pop    %ebp
  80d0a1:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d0a2:	83 ec 08             	sub    $0x8,%esp
  80d0a5:	ff 75 0c             	pushl  0xc(%ebp)
  80d0a8:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d0ad:	83 c0 10             	add    $0x10,%eax
  80d0b0:	50                   	push   %eax
  80d0b1:	e8 ab 93 ff ff       	call   806461 <ip_addr_isbroadcast>
  80d0b6:	83 c4 10             	add    $0x10,%esp
  80d0b9:	84 c0                	test   %al,%al
  80d0bb:	0f 85 54 01 00 00    	jne    80d215 <tcp_input+0x1e6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d0c1:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d0c6:	8b 58 10             	mov    0x10(%eax),%ebx
  80d0c9:	83 ec 0c             	sub    $0xc,%esp
  80d0cc:	68 00 00 00 f0       	push   $0xf0000000
  80d0d1:	e8 20 a8 ff ff       	call   8078f6 <ntohl>
  80d0d6:	21 c3                	and    %eax,%ebx
  80d0d8:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d0df:	e8 12 a8 ff ff       	call   8078f6 <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d0e4:	83 c4 10             	add    $0x10,%esp
  80d0e7:	39 c3                	cmp    %eax,%ebx
  80d0e9:	0f 84 26 01 00 00    	je     80d215 <tcp_input+0x1e6>
      (struct ip_addr *)&(iphdr->dest),
  80d0ef:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d0f4:	83 ec 0c             	sub    $0xc,%esp
  80d0f7:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d0fb:	52                   	push   %edx
  80d0fc:	6a 06                	push   $0x6
  80d0fe:	8d 50 10             	lea    0x10(%eax),%edx
  80d101:	52                   	push   %edx
  80d102:	83 c0 0c             	add    $0xc,%eax
  80d105:	50                   	push   %eax
  80d106:	56                   	push   %esi
  80d107:	e8 95 a2 ff ff       	call   8073a1 <inet_chksum_pseudo>
  80d10c:	83 c4 20             	add    $0x20,%esp
  80d10f:	66 85 c0             	test   %ax,%ax
  80d112:	0f 85 0e 01 00 00    	jne    80d226 <tcp_input+0x1f7>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d118:	83 ec 0c             	sub    $0xc,%esp
  80d11b:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d120:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d124:	50                   	push   %eax
  80d125:	e8 a8 a5 ff ff       	call   8076d2 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d12a:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d12d:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d131:	f7 d8                	neg    %eax
  80d133:	c1 e0 02             	shl    $0x2,%eax
  80d136:	98                   	cwtl   
  80d137:	50                   	push   %eax
  80d138:	56                   	push   %esi
  80d139:	e8 d8 75 ff ff       	call   804716 <pbuf_header>
  80d13e:	83 c4 10             	add    $0x10,%esp
  80d141:	84 c0                	test   %al,%al
  80d143:	0f 85 ee 00 00 00    	jne    80d237 <tcp_input+0x208>
  tcphdr->src = ntohs(tcphdr->src);
  80d149:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d14f:	83 ec 0c             	sub    $0xc,%esp
  80d152:	0f b7 03             	movzwl (%ebx),%eax
  80d155:	50                   	push   %eax
  80d156:	e8 77 a5 ff ff       	call   8076d2 <ntohs>
  80d15b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d15e:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d164:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d168:	89 04 24             	mov    %eax,(%esp)
  80d16b:	e8 62 a5 ff ff       	call   8076d2 <ntohs>
  80d170:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d174:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d17a:	83 c4 04             	add    $0x4,%esp
  80d17d:	ff 73 04             	pushl  0x4(%ebx)
  80d180:	e8 71 a7 ff ff       	call   8078f6 <ntohl>
  80d185:	89 43 04             	mov    %eax,0x4(%ebx)
  80d188:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d18d:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d193:	83 c4 04             	add    $0x4,%esp
  80d196:	ff 73 08             	pushl  0x8(%ebx)
  80d199:	e8 58 a7 ff ff       	call   8078f6 <ntohl>
  80d19e:	89 43 08             	mov    %eax,0x8(%ebx)
  80d1a1:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d1a6:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d1ac:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d1b0:	89 04 24             	mov    %eax,(%esp)
  80d1b3:	e8 1a a5 ff ff       	call   8076d2 <ntohs>
  80d1b8:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d1bc:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d1c1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d1c5:	89 04 24             	mov    %eax,(%esp)
  80d1c8:	e8 05 a5 ff ff       	call   8076d2 <ntohs>
  80d1cd:	89 c1                	mov    %eax,%ecx
  80d1cf:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d1d3:	83 e0 3f             	and    $0x3f,%eax
  80d1d6:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d1db:	83 c4 10             	add    $0x10,%esp
  80d1de:	f6 c1 03             	test   $0x3,%cl
  80d1e1:	0f 95 c0             	setne  %al
  80d1e4:	0f b6 c0             	movzbl %al,%eax
  80d1e7:	66 03 46 08          	add    0x8(%esi),%ax
  80d1eb:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d1ef:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1f5:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d1fa:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d1fd:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d203:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d209:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d20b:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d210:	e9 ab 00 00 00       	jmp    80d2c0 <tcp_input+0x291>
    pbuf_free(p);
  80d215:	83 ec 0c             	sub    $0xc,%esp
  80d218:	56                   	push   %esi
  80d219:	e8 c5 75 ff ff       	call   8047e3 <pbuf_free>
    return;
  80d21e:	83 c4 10             	add    $0x10,%esp
  80d221:	e9 74 fe ff ff       	jmp    80d09a <tcp_input+0x6b>
    pbuf_free(p);
  80d226:	83 ec 0c             	sub    $0xc,%esp
  80d229:	56                   	push   %esi
  80d22a:	e8 b4 75 ff ff       	call   8047e3 <pbuf_free>
    return;
  80d22f:	83 c4 10             	add    $0x10,%esp
  80d232:	e9 63 fe ff ff       	jmp    80d09a <tcp_input+0x6b>
    pbuf_free(p);
  80d237:	83 ec 0c             	sub    $0xc,%esp
  80d23a:	56                   	push   %esi
  80d23b:	e8 a3 75 ff ff       	call   8047e3 <pbuf_free>
    return;
  80d240:	83 c4 10             	add    $0x10,%esp
  80d243:	e9 52 fe ff ff       	jmp    80d09a <tcp_input+0x6b>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d248:	83 ec 04             	sub    $0x4,%esp
  80d24b:	68 90 30 81 00       	push   $0x813090
  80d250:	68 b5 00 00 00       	push   $0xb5
  80d255:	68 b4 31 81 00       	push   $0x8131b4
  80d25a:	e8 11 13 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d25f:	83 ec 04             	sub    $0x4,%esp
  80d262:	68 b8 30 81 00       	push   $0x8130b8
  80d267:	68 b6 00 00 00       	push   $0xb6
  80d26c:	68 b4 31 81 00       	push   $0x8131b4
  80d271:	e8 fa 12 00 00       	call   80e570 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d276:	83 ec 04             	sub    $0x4,%esp
  80d279:	68 e4 30 81 00       	push   $0x8130e4
  80d27e:	68 b7 00 00 00       	push   $0xb7
  80d283:	68 b4 31 81 00       	push   $0x8131b4
  80d288:	e8 e3 12 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d28d:	83 ec 04             	sub    $0x4,%esp
  80d290:	68 0c 31 81 00       	push   $0x81310c
  80d295:	68 c0 00 00 00       	push   $0xc0
  80d29a:	68 b4 31 81 00       	push   $0x8131b4
  80d29f:	e8 cc 12 00 00       	call   80e570 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d2a4:	83 ec 04             	sub    $0x4,%esp
  80d2a7:	68 38 31 81 00       	push   $0x813138
  80d2ac:	68 c6 00 00 00       	push   $0xc6
  80d2b1:	68 b4 31 81 00       	push   $0x8131b4
  80d2b6:	e8 b5 12 00 00       	call   80e570 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d2bb:	89 df                	mov    %ebx,%edi
  80d2bd:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d2c0:	85 db                	test   %ebx,%ebx
  80d2c2:	0f 84 b3 0a 00 00    	je     80dd7b <tcp_input+0xd4c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d2c8:	8b 43 10             	mov    0x10(%ebx),%eax
  80d2cb:	85 c0                	test   %eax,%eax
  80d2cd:	0f 84 75 ff ff ff    	je     80d248 <tcp_input+0x219>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d2d3:	83 f8 0a             	cmp    $0xa,%eax
  80d2d6:	74 87                	je     80d25f <tcp_input+0x230>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d2d8:	83 f8 01             	cmp    $0x1,%eax
  80d2db:	74 99                	je     80d276 <tcp_input+0x247>
    if (pcb->remote_port == tcphdr->src &&
  80d2dd:	0f b7 02             	movzwl (%edx),%eax
  80d2e0:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d2e4:	75 d5                	jne    80d2bb <tcp_input+0x28c>
  80d2e6:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d2ea:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d2ee:	75 cb                	jne    80d2bb <tcp_input+0x28c>
       pcb->local_port == tcphdr->dest &&
  80d2f0:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d2f3:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d2f6:	75 c3                	jne    80d2bb <tcp_input+0x28c>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d2f8:	8b 41 10             	mov    0x10(%ecx),%eax
  80d2fb:	39 03                	cmp    %eax,(%ebx)
  80d2fd:	75 bc                	jne    80d2bb <tcp_input+0x28c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d2ff:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d302:	39 c3                	cmp    %eax,%ebx
  80d304:	74 87                	je     80d28d <tcp_input+0x25e>
      if (prev != NULL) {
  80d306:	85 ff                	test   %edi,%edi
  80d308:	74 13                	je     80d31d <tcp_input+0x2ee>
        prev->next = pcb->next;
  80d30a:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d30d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d310:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d313:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d319:	39 c3                	cmp    %eax,%ebx
  80d31b:	74 87                	je     80d2a4 <tcp_input+0x275>
    inseg.next = NULL;
  80d31d:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d324:	00 00 00 
    inseg.len = p->tot_len;
  80d327:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d32b:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d331:	8b 46 04             	mov    0x4(%esi),%eax
  80d334:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d339:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d33f:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4
    recv_data = NULL;
  80d345:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d34c:	00 00 00 
    recv_flags = 0;
  80d34f:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c
    if (pcb->refused_data != NULL) {
  80d356:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d35c:	85 c0                	test   %eax,%eax
  80d35e:	74 2c                	je     80d38c <tcp_input+0x35d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d360:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d366:	85 d2                	test   %edx,%edx
  80d368:	0f 84 07 03 00 00    	je     80d675 <tcp_input+0x646>
  80d36e:	6a 00                	push   $0x0
  80d370:	50                   	push   %eax
  80d371:	53                   	push   %ebx
  80d372:	ff 73 18             	pushl  0x18(%ebx)
  80d375:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d377:	83 c4 10             	add    $0x10,%esp
  80d37a:	84 c0                	test   %al,%al
  80d37c:	0f 85 04 03 00 00    	jne    80d686 <tcp_input+0x657>
        pcb->refused_data = NULL;
  80d382:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d389:	00 00 00 
    tcp_input_pcb = pcb;
  80d38c:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  if (flags & TCP_RST) {
  80d392:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d399:	a8 04                	test   $0x4,%al
  80d39b:	0f 84 20 03 00 00    	je     80d6c1 <tcp_input+0x692>
    if (pcb->state == SYN_SENT) {
  80d3a1:	8b 53 10             	mov    0x10(%ebx),%edx
  80d3a4:	83 fa 02             	cmp    $0x2,%edx
  80d3a7:	0f 84 ea 02 00 00    	je     80d697 <tcp_input+0x668>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d3ad:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d3b2:	2b 43 24             	sub    0x24(%ebx),%eax
  80d3b5:	78 1d                	js     80d3d4 <tcp_input+0x3a5>
  80d3b7:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d3bb:	29 c8                	sub    %ecx,%eax
  80d3bd:	85 c0                	test   %eax,%eax
  80d3bf:	7f 13                	jg     80d3d4 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d3c1:	85 d2                	test   %edx,%edx
  80d3c3:	0f 84 e1 02 00 00    	je     80d6aa <tcp_input+0x67b>
      recv_flags = TF_RESET;
  80d3c9:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d3d0:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d3d4:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d3db:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d3de:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d3e5:	a8 08                	test   $0x8,%al
  80d3e7:	0f 84 37 08 00 00    	je     80dc24 <tcp_input+0xbf5>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d3ed:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d3f3:	85 c0                	test   %eax,%eax
  80d3f5:	74 0d                	je     80d404 <tcp_input+0x3d5>
  80d3f7:	83 ec 08             	sub    $0x8,%esp
  80d3fa:	6a fa                	push   $0xfffffffa
  80d3fc:	ff 73 18             	pushl  0x18(%ebx)
  80d3ff:	ff d0                	call   *%eax
  80d401:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d404:	83 ec 08             	sub    $0x8,%esp
  80d407:	53                   	push   %ebx
  80d408:	68 3c b2 b3 00       	push   $0xb3b23c
  80d40d:	e8 88 84 ff ff       	call   80589a <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d412:	83 c4 08             	add    $0x8,%esp
  80d415:	53                   	push   %ebx
  80d416:	6a 02                	push   $0x2
  80d418:	e8 76 70 ff ff       	call   804493 <memp_free>
  80d41d:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d420:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d425:	85 c0                	test   %eax,%eax
  80d427:	0f 84 6d fc ff ff    	je     80d09a <tcp_input+0x6b>
      pbuf_free(inseg.p);
  80d42d:	83 ec 0c             	sub    $0xc,%esp
  80d430:	50                   	push   %eax
  80d431:	e8 ad 73 ff ff       	call   8047e3 <pbuf_free>
      inseg.p = NULL;
  80d436:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80d43d:	00 00 00 
  80d440:	83 c4 10             	add    $0x10,%esp
  80d443:	e9 52 fc ff ff       	jmp    80d09a <tcp_input+0x6b>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d448:	83 ec 04             	sub    $0x4,%esp
  80d44b:	68 64 31 81 00       	push   $0x813164
  80d450:	68 d0 00 00 00       	push   $0xd0
  80d455:	68 b4 31 81 00       	push   $0x8131b4
  80d45a:	e8 11 11 00 00       	call   80e570 <_panic>
    tcp_ack_now(pcb);
  80d45f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d463:	83 ec 0c             	sub    $0xc,%esp
  80d466:	53                   	push   %ebx
  80d467:	e8 ba ab ff ff       	call   808026 <tcp_output>
  80d46c:	83 c4 10             	add    $0x10,%esp
  80d46f:	eb 4c                	jmp    80d4bd <tcp_input+0x48e>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d471:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d474:	85 db                	test   %ebx,%ebx
  80d476:	74 5e                	je     80d4d6 <tcp_input+0x4a7>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d478:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d47c:	75 ca                	jne    80d448 <tcp_input+0x419>
      if (pcb->remote_port == tcphdr->src &&
  80d47e:	0f b7 02             	movzwl (%edx),%eax
  80d481:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d485:	75 ea                	jne    80d471 <tcp_input+0x442>
  80d487:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d48b:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d48f:	75 e0                	jne    80d471 <tcp_input+0x442>
         pcb->local_port == tcphdr->dest &&
  80d491:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d494:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d497:	75 d8                	jne    80d471 <tcp_input+0x442>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d499:	8b 41 10             	mov    0x10(%ecx),%eax
  80d49c:	39 03                	cmp    %eax,(%ebx)
  80d49e:	75 d1                	jne    80d471 <tcp_input+0x442>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d4a0:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d4a4:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d4aa:	89 c2                	mov    %eax,%edx
  80d4ac:	2b 53 24             	sub    0x24(%ebx),%edx
  80d4af:	85 d2                	test   %edx,%edx
  80d4b1:	7e 03                	jle    80d4b6 <tcp_input+0x487>
    pcb->rcv_nxt = seqno + tcplen;
  80d4b3:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d4b6:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d4bb:	75 a2                	jne    80d45f <tcp_input+0x430>
  return tcp_output(pcb);
  80d4bd:	83 ec 0c             	sub    $0xc,%esp
  80d4c0:	53                   	push   %ebx
  80d4c1:	e8 60 ab ff ff       	call   808026 <tcp_output>
        pbuf_free(p);
  80d4c6:	89 34 24             	mov    %esi,(%esp)
  80d4c9:	e8 15 73 ff ff       	call   8047e3 <pbuf_free>
        return;
  80d4ce:	83 c4 10             	add    $0x10,%esp
  80d4d1:	e9 c4 fb ff ff       	jmp    80d09a <tcp_input+0x6b>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d4d6:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d4db:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d4de:	89 c7                	mov    %eax,%edi
  80d4e0:	eb 0f                	jmp    80d4f1 <tcp_input+0x4c2>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d4e2:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d4e6:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d4ea:	74 1a                	je     80d506 <tcp_input+0x4d7>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d4ec:	89 fb                	mov    %edi,%ebx
  80d4ee:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d4f1:	85 ff                	test   %edi,%edi
  80d4f3:	0f 84 5d 08 00 00    	je     80dd56 <tcp_input+0xd27>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d4f9:	8b 07                	mov    (%edi),%eax
  80d4fb:	85 c0                	test   %eax,%eax
  80d4fd:	74 e3                	je     80d4e2 <tcp_input+0x4b3>
  80d4ff:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d502:	75 e8                	jne    80d4ec <tcp_input+0x4bd>
  80d504:	eb dc                	jmp    80d4e2 <tcp_input+0x4b3>
        if (prev != NULL) {
  80d506:	85 db                	test   %ebx,%ebx
  80d508:	74 12                	je     80d51c <tcp_input+0x4ed>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d50a:	8b 47 0c             	mov    0xc(%edi),%eax
  80d50d:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d510:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d513:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d516:	89 3d 44 b2 b3 00    	mov    %edi,0xb3b244
  if (flags & TCP_ACK) {
  80d51c:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d520:	75 17                	jne    80d539 <tcp_input+0x50a>
  } else if (flags & TCP_SYN) {
  80d522:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d526:	75 43                	jne    80d56b <tcp_input+0x53c>
        pbuf_free(p);
  80d528:	83 ec 0c             	sub    $0xc,%esp
  80d52b:	56                   	push   %esi
  80d52c:	e8 b2 72 ff ff       	call   8047e3 <pbuf_free>
        return;
  80d531:	83 c4 10             	add    $0x10,%esp
  80d534:	e9 61 fb ff ff       	jmp    80d09a <tcp_input+0x6b>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d539:	83 ec 08             	sub    $0x8,%esp
  80d53c:	0f b7 02             	movzwl (%edx),%eax
  80d53f:	50                   	push   %eax
  80d540:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d544:	50                   	push   %eax
  80d545:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d548:	50                   	push   %eax
  80d549:	83 c1 10             	add    $0x10,%ecx
  80d54c:	51                   	push   %ecx
  80d54d:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d551:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d557:	50                   	push   %eax
  80d558:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d55d:	83 c0 01             	add    $0x1,%eax
  80d560:	50                   	push   %eax
  80d561:	e8 60 af ff ff       	call   8084c6 <tcp_rst>
  80d566:	83 c4 20             	add    $0x20,%esp
  80d569:	eb bd                	jmp    80d528 <tcp_input+0x4f9>
    npcb = tcp_alloc(pcb->prio);
  80d56b:	83 ec 0c             	sub    $0xc,%esp
  80d56e:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d572:	50                   	push   %eax
  80d573:	e8 80 8b ff ff       	call   8060f8 <tcp_alloc>
  80d578:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d57a:	83 c4 10             	add    $0x10,%esp
  80d57d:	85 c0                	test   %eax,%eax
  80d57f:	74 a7                	je     80d528 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d581:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d586:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d589:	0f 84 c5 00 00 00    	je     80d654 <tcp_input+0x625>
  80d58f:	8b 50 10             	mov    0x10(%eax),%edx
  80d592:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d594:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d598:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d59c:	8b 50 0c             	mov    0xc(%eax),%edx
  80d59f:	89 53 04             	mov    %edx,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d5a2:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d5a8:	0f b7 02             	movzwl (%edx),%eax
  80d5ab:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d5af:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d5b6:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d5bb:	8d 48 01             	lea    0x1(%eax),%ecx
  80d5be:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d5c1:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d5c5:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d5c9:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d5cd:	83 e8 01             	sub    $0x1,%eax
  80d5d0:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d5d3:	8b 47 18             	mov    0x18(%edi),%eax
  80d5d6:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d5d9:	8b 47 20             	mov    0x20(%edi),%eax
  80d5dc:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d5e2:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d5e6:	66 25 99 01          	and    $0x199,%ax
  80d5ea:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d5ee:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d5f3:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d5f6:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  80d5fc:	e8 b0 4b ff ff       	call   8021b1 <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d601:	89 d8                	mov    %ebx,%eax
  80d603:	e8 77 ec ff ff       	call   80c27f <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d608:	83 ec 08             	sub    $0x8,%esp
  80d60b:	8d 43 04             	lea    0x4(%ebx),%eax
  80d60e:	50                   	push   %eax
  80d60f:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d613:	50                   	push   %eax
  80d614:	e8 7d 8c ff ff       	call   806296 <tcp_eff_send_mss>
  80d619:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80d61d:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d624:	e8 b6 a0 ff ff       	call   8076df <htonl>
  80d629:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d62c:	83 c4 0c             	add    $0xc,%esp
  80d62f:	6a 04                	push   $0x4
  80d631:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d634:	50                   	push   %eax
  80d635:	6a 00                	push   $0x0
  80d637:	6a 12                	push   $0x12
  80d639:	6a 00                	push   $0x0
  80d63b:	6a 00                	push   $0x0
  80d63d:	53                   	push   %ebx
  80d63e:	e8 c6 a2 ff ff       	call   807909 <tcp_enqueue>
    return tcp_output(npcb);
  80d643:	83 c4 14             	add    $0x14,%esp
  80d646:	53                   	push   %ebx
  80d647:	e8 da a9 ff ff       	call   808026 <tcp_output>
  80d64c:	83 c4 10             	add    $0x10,%esp
  80d64f:	e9 d4 fe ff ff       	jmp    80d528 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d654:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    npcb->local_port = pcb->local_port;
  80d65a:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d65e:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d662:	ba 00 00 00 00       	mov    $0x0,%edx
  80d667:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d66a:	0f 84 2f ff ff ff    	je     80d59f <tcp_input+0x570>
  80d670:	e9 27 ff ff ff       	jmp    80d59c <tcp_input+0x56d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d675:	83 ec 0c             	sub    $0xc,%esp
  80d678:	50                   	push   %eax
  80d679:	e8 65 71 ff ff       	call   8047e3 <pbuf_free>
  80d67e:	83 c4 10             	add    $0x10,%esp
  80d681:	e9 fc fc ff ff       	jmp    80d382 <tcp_input+0x353>
        pbuf_free(p);
  80d686:	83 ec 0c             	sub    $0xc,%esp
  80d689:	56                   	push   %esi
  80d68a:	e8 54 71 ff ff       	call   8047e3 <pbuf_free>
        return;
  80d68f:	83 c4 10             	add    $0x10,%esp
  80d692:	e9 03 fa ff ff       	jmp    80d09a <tcp_input+0x6b>
      if (ackno == pcb->snd_nxt) {
  80d697:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d69c:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d69f:	0f 84 24 fd ff ff    	je     80d3c9 <tcp_input+0x39a>
  80d6a5:	e9 2a fd ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d6aa:	83 ec 04             	sub    $0x4,%esp
  80d6ad:	68 94 31 81 00       	push   $0x813194
  80d6b2:	68 09 02 00 00       	push   $0x209
  80d6b7:	68 b4 31 81 00       	push   $0x8131b4
  80d6bc:	e8 af 0e 00 00       	call   80e570 <_panic>
  pcb->tmr = tcp_ticks;
  80d6c1:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d6c7:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d6ca:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  switch (pcb->state) {
  80d6d1:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d6d5:	0f 87 3a 05 00 00    	ja     80dc15 <tcp_input+0xbe6>
  80d6db:	8b 53 10             	mov    0x10(%ebx),%edx
  80d6de:	ff 24 95 38 32 81 00 	jmp    *0x813238(,%edx,4)
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d6e5:	83 e0 12             	and    $0x12,%eax
  80d6e8:	3c 12                	cmp    $0x12,%al
  80d6ea:	74 4d                	je     80d739 <tcp_input+0x70a>
    else if (flags & TCP_ACK) {
  80d6ec:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d6f3:	0f 84 db fc ff ff    	je     80d3d4 <tcp_input+0x3a5>
        tcphdr->dest, tcphdr->src);
  80d6f9:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d6ff:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d704:	83 ec 08             	sub    $0x8,%esp
  80d707:	0f b7 0a             	movzwl (%edx),%ecx
  80d70a:	51                   	push   %ecx
  80d70b:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d70f:	52                   	push   %edx
  80d710:	8d 50 0c             	lea    0xc(%eax),%edx
  80d713:	52                   	push   %edx
  80d714:	83 c0 10             	add    $0x10,%eax
  80d717:	50                   	push   %eax
  80d718:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d71f:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d725:	50                   	push   %eax
  80d726:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d72c:	e8 95 ad ff ff       	call   8084c6 <tcp_rst>
  80d731:	83 c4 20             	add    $0x20,%esp
  80d734:	e9 9b fc ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d739:	83 ec 0c             	sub    $0xc,%esp
  80d73c:	8b 43 78             	mov    0x78(%ebx),%eax
  80d73f:	8b 40 10             	mov    0x10(%eax),%eax
  80d742:	ff 70 04             	pushl  0x4(%eax)
  80d745:	e8 ac a1 ff ff       	call   8078f6 <ntohl>
  80d74a:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d750:	83 c0 01             	add    $0x1,%eax
  80d753:	83 c4 10             	add    $0x10,%esp
  80d756:	39 d0                	cmp    %edx,%eax
  80d758:	75 92                	jne    80d6ec <tcp_input+0x6bd>
      pcb->snd_buf++;
  80d75a:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d75f:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d764:	8d 48 01             	lea    0x1(%eax),%ecx
  80d767:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d76a:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d76d:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d773:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d777:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d77b:	83 e8 01             	sub    $0x1,%eax
  80d77e:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d781:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80d788:	89 d8                	mov    %ebx,%eax
  80d78a:	e8 f0 ea ff ff       	call   80c27f <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d78f:	83 ec 08             	sub    $0x8,%esp
  80d792:	8d 43 04             	lea    0x4(%ebx),%eax
  80d795:	50                   	push   %eax
  80d796:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d79a:	50                   	push   %eax
  80d79b:	e8 f6 8a ff ff       	call   806296 <tcp_eff_send_mss>
  80d7a0:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80d7a4:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d7a7:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d7ab:	83 c4 10             	add    $0x10,%esp
  80d7ae:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d7b3:	74 63                	je     80d818 <tcp_input+0x7e9>
  80d7b5:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d7b9:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d7bd:	66 85 c0             	test   %ax,%ax
  80d7c0:	74 5a                	je     80d81c <tcp_input+0x7ed>
      --pcb->snd_queuelen;
  80d7c2:	83 e8 01             	sub    $0x1,%eax
  80d7c5:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80d7c9:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d7cc:	8b 10                	mov    (%eax),%edx
  80d7ce:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80d7d1:	85 d2                	test   %edx,%edx
  80d7d3:	74 5e                	je     80d833 <tcp_input+0x804>
        pcb->rtime = 0;
  80d7d5:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d7db:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80d7df:	83 ec 0c             	sub    $0xc,%esp
  80d7e2:	50                   	push   %eax
  80d7e3:	e8 1c 7f ff ff       	call   805704 <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d7e8:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d7ee:	83 c4 10             	add    $0x10,%esp
  80d7f1:	85 c0                	test   %eax,%eax
  80d7f3:	74 0e                	je     80d803 <tcp_input+0x7d4>
  80d7f5:	83 ec 04             	sub    $0x4,%esp
  80d7f8:	6a 00                	push   $0x0
  80d7fa:	53                   	push   %ebx
  80d7fb:	ff 73 18             	pushl  0x18(%ebx)
  80d7fe:	ff d0                	call   *%eax
  80d800:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d803:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d807:	83 ec 0c             	sub    $0xc,%esp
  80d80a:	53                   	push   %ebx
  80d80b:	e8 16 a8 ff ff       	call   808026 <tcp_output>
  80d810:	83 c4 10             	add    $0x10,%esp
  80d813:	e9 bc fb ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d818:	01 c0                	add    %eax,%eax
  80d81a:	eb 99                	jmp    80d7b5 <tcp_input+0x786>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d81c:	83 ec 04             	sub    $0x4,%esp
  80d81f:	68 0d 32 81 00       	push   $0x81320d
  80d824:	68 35 02 00 00       	push   $0x235
  80d829:	68 b4 31 81 00       	push   $0x8131b4
  80d82e:	e8 3d 0d 00 00       	call   80e570 <_panic>
        pcb->rtime = -1;
  80d833:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d839:	eb a4                	jmp    80d7df <tcp_input+0x7b0>
    if (flags & TCP_ACK &&
  80d83b:	83 e0 14             	and    $0x14,%eax
  80d83e:	3c 10                	cmp    $0x10,%al
  80d840:	0f 85 8e fb ff ff    	jne    80d3d4 <tcp_input+0x3a5>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d846:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d84c:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d84f:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d852:	78 09                	js     80d85d <tcp_input+0x82e>
  80d854:	89 d0                	mov    %edx,%eax
  80d856:	2b 43 54             	sub    0x54(%ebx),%eax
  80d859:	85 c0                	test   %eax,%eax
  80d85b:	7e 3b                	jle    80d898 <tcp_input+0x869>
                tcphdr->dest, tcphdr->src);
  80d85d:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d863:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d868:	83 ec 08             	sub    $0x8,%esp
  80d86b:	0f b7 31             	movzwl (%ecx),%esi
  80d86e:	56                   	push   %esi
  80d86f:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d873:	51                   	push   %ecx
  80d874:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d877:	51                   	push   %ecx
  80d878:	83 c0 10             	add    $0x10,%eax
  80d87b:	50                   	push   %eax
  80d87c:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d883:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d889:	50                   	push   %eax
  80d88a:	52                   	push   %edx
  80d88b:	e8 36 ac ff ff       	call   8084c6 <tcp_rst>
  80d890:	83 c4 20             	add    $0x20,%esp
  80d893:	e9 3c fb ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
        pcb->state = ESTABLISHED;
  80d898:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d89f:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d8a5:	85 c0                	test   %eax,%eax
  80d8a7:	74 5c                	je     80d905 <tcp_input+0x8d6>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d8a9:	83 ec 04             	sub    $0x4,%esp
  80d8ac:	6a 00                	push   $0x0
  80d8ae:	53                   	push   %ebx
  80d8af:	ff 73 18             	pushl  0x18(%ebx)
  80d8b2:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d8b4:	83 c4 10             	add    $0x10,%esp
  80d8b7:	84 c0                	test   %al,%al
  80d8b9:	75 61                	jne    80d91c <tcp_input+0x8ed>
        old_cwnd = pcb->cwnd;
  80d8bb:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80d8bf:	89 d8                	mov    %ebx,%eax
  80d8c1:	e8 6d ea ff ff       	call   80c333 <tcp_receive>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d8c6:	66 83 fe 01          	cmp    $0x1,%si
  80d8ca:	74 6b                	je     80d937 <tcp_input+0x908>
  80d8cc:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d8d0:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80d8d4:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d8db:	0f 84 f3 fa ff ff    	je     80d3d4 <tcp_input+0x3a5>
  80d8e1:	84 c0                	test   %al,%al
  80d8e3:	0f 84 eb fa ff ff    	je     80d3d4 <tcp_input+0x3a5>
          tcp_ack_now(pcb);
  80d8e9:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d8ed:	83 ec 0c             	sub    $0xc,%esp
  80d8f0:	53                   	push   %ebx
  80d8f1:	e8 30 a7 ff ff       	call   808026 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d8f6:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d8fd:	83 c4 10             	add    $0x10,%esp
  80d900:	e9 cf fa ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d905:	83 ec 04             	sub    $0x4,%esp
  80d908:	68 23 32 81 00       	push   $0x813223
  80d90d:	68 5b 02 00 00       	push   $0x25b
  80d912:	68 b4 31 81 00       	push   $0x8131b4
  80d917:	e8 54 0c 00 00       	call   80e570 <_panic>
          tcp_abort(pcb);
  80d91c:	83 ec 0c             	sub    $0xc,%esp
  80d91f:	53                   	push   %ebx
  80d920:	e8 2b 82 ff ff       	call   805b50 <tcp_abort>
    tcp_input_pcb = NULL;
  80d925:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d92c:	00 00 00 
  80d92f:	83 c4 10             	add    $0x10,%esp
  80d932:	e9 e9 fa ff ff       	jmp    80d420 <tcp_input+0x3f1>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d937:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80d93b:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d93e:	eb 90                	jmp    80d8d0 <tcp_input+0x8a1>
    accepted_inseq = tcp_receive(pcb);
  80d940:	89 d8                	mov    %ebx,%eax
  80d942:	e8 ec e9 ff ff       	call   80c333 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d947:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d94e:	0f 84 80 fa ff ff    	je     80d3d4 <tcp_input+0x3a5>
  80d954:	84 c0                	test   %al,%al
  80d956:	0f 84 78 fa ff ff    	je     80d3d4 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80d95c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d960:	83 ec 0c             	sub    $0xc,%esp
  80d963:	53                   	push   %ebx
  80d964:	e8 bd a6 ff ff       	call   808026 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d969:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d970:	83 c4 10             	add    $0x10,%esp
  80d973:	e9 5c fa ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80d978:	89 d8                	mov    %ebx,%eax
  80d97a:	e8 b4 e9 ff ff       	call   80c333 <tcp_receive>
    if (flags & TCP_FIN) {
  80d97f:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d986:	a8 01                	test   $0x1,%al
  80d988:	0f 84 c7 00 00 00    	je     80da55 <tcp_input+0xa26>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d98e:	a8 10                	test   $0x10,%al
  80d990:	74 0a                	je     80d99c <tcp_input+0x96d>
  80d992:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d997:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d99a:	74 1c                	je     80d9b8 <tcp_input+0x989>
        tcp_ack_now(pcb);
  80d99c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d9a0:	83 ec 0c             	sub    $0xc,%esp
  80d9a3:	53                   	push   %ebx
  80d9a4:	e8 7d a6 ff ff       	call   808026 <tcp_output>
        pcb->state = CLOSING;
  80d9a9:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80d9b0:	83 c4 10             	add    $0x10,%esp
  80d9b3:	e9 1c fa ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
        tcp_ack_now(pcb);
  80d9b8:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d9bc:	83 ec 0c             	sub    $0xc,%esp
  80d9bf:	53                   	push   %ebx
  80d9c0:	e8 61 a6 ff ff       	call   808026 <tcp_output>
        tcp_pcb_purge(pcb);
  80d9c5:	89 1c 24             	mov    %ebx,(%esp)
  80d9c8:	e8 50 7e ff ff       	call   80581d <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d9cd:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d9d2:	83 c4 10             	add    $0x10,%esp
  80d9d5:	39 c3                	cmp    %eax,%ebx
  80d9d7:	74 2c                	je     80da05 <tcp_input+0x9d6>
  80d9d9:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d9de:	ba 00 00 00 00       	mov    $0x0,%edx
  80d9e3:	89 de                	mov    %ebx,%esi
  80d9e5:	89 d7                	mov    %edx,%edi
  80d9e7:	85 c0                	test   %eax,%eax
  80d9e9:	74 56                	je     80da41 <tcp_input+0xa12>
  80d9eb:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d9ee:	39 ce                	cmp    %ecx,%esi
  80d9f0:	0f 94 c3             	sete   %bl
  80d9f3:	85 c9                	test   %ecx,%ecx
  80d9f5:	0f 95 c2             	setne  %dl
  80d9f8:	84 d3                	test   %dl,%bl
  80d9fa:	75 30                	jne    80da2c <tcp_input+0x9fd>
  80d9fc:	bf 01 00 00 00       	mov    $0x1,%edi
  80da01:	89 c8                	mov    %ecx,%eax
  80da03:	eb e2                	jmp    80d9e7 <tcp_input+0x9b8>
  80da05:	8b 40 0c             	mov    0xc(%eax),%eax
  80da08:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
        pcb->state = TIME_WAIT;
  80da0d:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80da14:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80da19:	89 43 0c             	mov    %eax,0xc(%ebx)
  80da1c:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80da22:	e8 8a 47 ff ff       	call   8021b1 <tcp_timer_needed>
  80da27:	e9 a8 f9 ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
  80da2c:	89 f3                	mov    %esi,%ebx
  80da2e:	89 fa                	mov    %edi,%edx
  80da30:	84 d2                	test   %dl,%dl
  80da32:	74 05                	je     80da39 <tcp_input+0xa0a>
  80da34:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
        TCP_RMV(&tcp_active_pcbs, pcb);
  80da39:	8b 53 0c             	mov    0xc(%ebx),%edx
  80da3c:	89 50 0c             	mov    %edx,0xc(%eax)
  80da3f:	eb cc                	jmp    80da0d <tcp_input+0x9de>
  80da41:	89 f3                	mov    %esi,%ebx
  80da43:	89 fa                	mov    %edi,%edx
  80da45:	84 d2                	test   %dl,%dl
  80da47:	74 c4                	je     80da0d <tcp_input+0x9de>
  80da49:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80da50:	00 00 00 
  80da53:	eb b8                	jmp    80da0d <tcp_input+0x9de>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80da55:	a8 10                	test   $0x10,%al
  80da57:	0f 84 77 f9 ff ff    	je     80d3d4 <tcp_input+0x3a5>
  80da5d:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80da62:	39 43 54             	cmp    %eax,0x54(%ebx)
  80da65:	0f 85 69 f9 ff ff    	jne    80d3d4 <tcp_input+0x3a5>
      pcb->state = FIN_WAIT_2;
  80da6b:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80da72:	e9 5d f9 ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80da77:	89 d8                	mov    %ebx,%eax
  80da79:	e8 b5 e8 ff ff       	call   80c333 <tcp_receive>
    if (flags & TCP_FIN) {
  80da7e:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80da85:	0f 84 49 f9 ff ff    	je     80d3d4 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80da8b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80da8f:	83 ec 0c             	sub    $0xc,%esp
  80da92:	53                   	push   %ebx
  80da93:	e8 8e a5 ff ff       	call   808026 <tcp_output>
      tcp_pcb_purge(pcb);
  80da98:	89 1c 24             	mov    %ebx,(%esp)
  80da9b:	e8 7d 7d ff ff       	call   80581d <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80daa0:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80daa5:	83 c4 10             	add    $0x10,%esp
  80daa8:	39 c3                	cmp    %eax,%ebx
  80daaa:	74 2c                	je     80dad8 <tcp_input+0xaa9>
  80daac:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dab1:	b9 00 00 00 00       	mov    $0x0,%ecx
  80dab6:	89 de                	mov    %ebx,%esi
  80dab8:	89 cf                	mov    %ecx,%edi
  80daba:	85 c0                	test   %eax,%eax
  80dabc:	74 56                	je     80db14 <tcp_input+0xae5>
  80dabe:	8b 50 0c             	mov    0xc(%eax),%edx
  80dac1:	85 d2                	test   %edx,%edx
  80dac3:	0f 95 c3             	setne  %bl
  80dac6:	39 d6                	cmp    %edx,%esi
  80dac8:	0f 94 c1             	sete   %cl
  80dacb:	84 cb                	test   %cl,%bl
  80dacd:	75 30                	jne    80daff <tcp_input+0xad0>
  80dacf:	bf 01 00 00 00       	mov    $0x1,%edi
  80dad4:	89 d0                	mov    %edx,%eax
  80dad6:	eb e2                	jmp    80daba <tcp_input+0xa8b>
  80dad8:	8b 40 0c             	mov    0xc(%eax),%eax
  80dadb:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80dae0:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dae7:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80daec:	89 43 0c             	mov    %eax,0xc(%ebx)
  80daef:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80daf5:	e8 b7 46 ff ff       	call   8021b1 <tcp_timer_needed>
  80dafa:	e9 d5 f8 ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
  80daff:	89 f3                	mov    %esi,%ebx
  80db01:	89 f9                	mov    %edi,%ecx
  80db03:	84 c9                	test   %cl,%cl
  80db05:	74 05                	je     80db0c <tcp_input+0xadd>
  80db07:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80db0c:	8b 53 0c             	mov    0xc(%ebx),%edx
  80db0f:	89 50 0c             	mov    %edx,0xc(%eax)
  80db12:	eb cc                	jmp    80dae0 <tcp_input+0xab1>
  80db14:	89 f3                	mov    %esi,%ebx
  80db16:	89 f9                	mov    %edi,%ecx
  80db18:	84 c9                	test   %cl,%cl
  80db1a:	74 c4                	je     80dae0 <tcp_input+0xab1>
  80db1c:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80db23:	00 00 00 
  80db26:	eb b8                	jmp    80dae0 <tcp_input+0xab1>
    tcp_receive(pcb);
  80db28:	89 d8                	mov    %ebx,%eax
  80db2a:	e8 04 e8 ff ff       	call   80c333 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80db2f:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80db36:	0f 84 98 f8 ff ff    	je     80d3d4 <tcp_input+0x3a5>
  80db3c:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80db41:	39 43 54             	cmp    %eax,0x54(%ebx)
  80db44:	0f 85 8a f8 ff ff    	jne    80d3d4 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80db4a:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80db4e:	83 ec 0c             	sub    $0xc,%esp
  80db51:	53                   	push   %ebx
  80db52:	e8 cf a4 ff ff       	call   808026 <tcp_output>
      tcp_pcb_purge(pcb);
  80db57:	89 1c 24             	mov    %ebx,(%esp)
  80db5a:	e8 be 7c ff ff       	call   80581d <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80db5f:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80db64:	83 c4 10             	add    $0x10,%esp
  80db67:	39 c3                	cmp    %eax,%ebx
  80db69:	74 2c                	je     80db97 <tcp_input+0xb68>
  80db6b:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80db70:	ba 00 00 00 00       	mov    $0x0,%edx
  80db75:	89 de                	mov    %ebx,%esi
  80db77:	89 d7                	mov    %edx,%edi
  80db79:	85 c0                	test   %eax,%eax
  80db7b:	74 56                	je     80dbd3 <tcp_input+0xba4>
  80db7d:	8b 48 0c             	mov    0xc(%eax),%ecx
  80db80:	85 c9                	test   %ecx,%ecx
  80db82:	0f 95 c3             	setne  %bl
  80db85:	39 ce                	cmp    %ecx,%esi
  80db87:	0f 94 c2             	sete   %dl
  80db8a:	84 d3                	test   %dl,%bl
  80db8c:	75 30                	jne    80dbbe <tcp_input+0xb8f>
  80db8e:	bf 01 00 00 00       	mov    $0x1,%edi
  80db93:	89 c8                	mov    %ecx,%eax
  80db95:	eb e2                	jmp    80db79 <tcp_input+0xb4a>
  80db97:	8b 40 0c             	mov    0xc(%eax),%eax
  80db9a:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80db9f:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dba6:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80dbab:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dbae:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80dbb4:	e8 f8 45 ff ff       	call   8021b1 <tcp_timer_needed>
  80dbb9:	e9 16 f8 ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
  80dbbe:	89 f3                	mov    %esi,%ebx
  80dbc0:	89 fa                	mov    %edi,%edx
  80dbc2:	84 d2                	test   %dl,%dl
  80dbc4:	74 05                	je     80dbcb <tcp_input+0xb9c>
  80dbc6:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dbcb:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dbce:	89 50 0c             	mov    %edx,0xc(%eax)
  80dbd1:	eb cc                	jmp    80db9f <tcp_input+0xb70>
  80dbd3:	89 f3                	mov    %esi,%ebx
  80dbd5:	89 fa                	mov    %edi,%edx
  80dbd7:	84 d2                	test   %dl,%dl
  80dbd9:	74 c4                	je     80db9f <tcp_input+0xb70>
  80dbdb:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dbe2:	00 00 00 
  80dbe5:	eb b8                	jmp    80db9f <tcp_input+0xb70>
    tcp_receive(pcb);
  80dbe7:	89 d8                	mov    %ebx,%eax
  80dbe9:	e8 45 e7 ff ff       	call   80c333 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dbee:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80dbf5:	0f 84 d9 f7 ff ff    	je     80d3d4 <tcp_input+0x3a5>
  80dbfb:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dc00:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dc03:	0f 85 cb f7 ff ff    	jne    80d3d4 <tcp_input+0x3a5>
      recv_flags = TF_CLOSED;
  80dc09:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80dc10:	e9 bf f7 ff ff       	jmp    80d3d4 <tcp_input+0x3a5>
    tcp_input_pcb = NULL;
  80dc15:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dc1c:	00 00 00 
  80dc1f:	e9 ba f7 ff ff       	jmp    80d3de <tcp_input+0x3af>
      } else if (recv_flags & TF_CLOSED) {
  80dc24:	a8 10                	test   $0x10,%al
  80dc26:	0f 85 96 00 00 00    	jne    80dcc2 <tcp_input+0xc93>
        if (pcb->acked > 0) {
  80dc2c:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80dc30:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80dc35:	66 85 d2             	test   %dx,%dx
  80dc38:	74 1a                	je     80dc54 <tcp_input+0xc25>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dc3a:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dc40:	85 c9                	test   %ecx,%ecx
  80dc42:	74 10                	je     80dc54 <tcp_input+0xc25>
  80dc44:	83 ec 04             	sub    $0x4,%esp
  80dc47:	0f b7 d2             	movzwl %dx,%edx
  80dc4a:	52                   	push   %edx
  80dc4b:	53                   	push   %ebx
  80dc4c:	ff 73 18             	pushl  0x18(%ebx)
  80dc4f:	ff d1                	call   *%ecx
  80dc51:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80dc54:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80dc5a:	85 d2                	test   %edx,%edx
  80dc5c:	0f 84 a9 00 00 00    	je     80dd0b <tcp_input+0xcdc>
          if(flags & TCP_PSH) {
  80dc62:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80dc69:	74 04                	je     80dc6f <tcp_input+0xc40>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80dc6b:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dc6f:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dc75:	85 c0                	test   %eax,%eax
  80dc77:	74 6a                	je     80dce3 <tcp_input+0xcb4>
  80dc79:	6a 00                	push   $0x0
  80dc7b:	52                   	push   %edx
  80dc7c:	53                   	push   %ebx
  80dc7d:	ff 73 18             	pushl  0x18(%ebx)
  80dc80:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80dc82:	83 c4 10             	add    $0x10,%esp
  80dc85:	84 c0                	test   %al,%al
  80dc87:	75 68                	jne    80dcf1 <tcp_input+0xcc2>
        if (recv_flags & TF_GOT_FIN) {
  80dc89:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dc90:	74 1f                	je     80dcb1 <tcp_input+0xc82>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80dc92:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dc98:	85 c0                	test   %eax,%eax
  80dc9a:	74 15                	je     80dcb1 <tcp_input+0xc82>
  80dc9c:	6a 00                	push   $0x0
  80dc9e:	6a 00                	push   $0x0
  80dca0:	53                   	push   %ebx
  80dca1:	ff 73 18             	pushl  0x18(%ebx)
  80dca4:	ff d0                	call   *%eax
  80dca6:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80dca9:	84 c0                	test   %al,%al
  80dcab:	0f 85 6f f7 ff ff    	jne    80d420 <tcp_input+0x3f1>
          tcp_output(pcb);
  80dcb1:	83 ec 0c             	sub    $0xc,%esp
  80dcb4:	53                   	push   %ebx
  80dcb5:	e8 6c a3 ff ff       	call   808026 <tcp_output>
  80dcba:	83 c4 10             	add    $0x10,%esp
  80dcbd:	e9 5e f7 ff ff       	jmp    80d420 <tcp_input+0x3f1>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80dcc2:	83 ec 08             	sub    $0x8,%esp
  80dcc5:	53                   	push   %ebx
  80dcc6:	68 3c b2 b3 00       	push   $0xb3b23c
  80dccb:	e8 ca 7b ff ff       	call   80589a <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80dcd0:	83 c4 08             	add    $0x8,%esp
  80dcd3:	53                   	push   %ebx
  80dcd4:	6a 02                	push   $0x2
  80dcd6:	e8 b8 67 ff ff       	call   804493 <memp_free>
  80dcdb:	83 c4 10             	add    $0x10,%esp
  80dcde:	e9 3d f7 ff ff       	jmp    80d420 <tcp_input+0x3f1>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dce3:	83 ec 0c             	sub    $0xc,%esp
  80dce6:	52                   	push   %edx
  80dce7:	e8 f7 6a ff ff       	call   8047e3 <pbuf_free>
  80dcec:	83 c4 10             	add    $0x10,%esp
  80dcef:	eb 98                	jmp    80dc89 <tcp_input+0xc5a>
            pcb->refused_data = recv_data;
  80dcf1:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80dcf6:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80dcfc:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dd03:	0f 84 17 f7 ff ff    	je     80d420 <tcp_input+0x3f1>
  80dd09:	eb 87                	jmp    80dc92 <tcp_input+0xc63>
  80dd0b:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dd12:	74 95                	je     80dca9 <tcp_input+0xc7a>
  80dd14:	e9 79 ff ff ff       	jmp    80dc92 <tcp_input+0xc63>
        tcphdr->dest, tcphdr->src);
  80dd19:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80dd1f:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80dd24:	83 ec 08             	sub    $0x8,%esp
  80dd27:	0f b7 0a             	movzwl (%edx),%ecx
  80dd2a:	51                   	push   %ecx
  80dd2b:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dd2f:	52                   	push   %edx
  80dd30:	8d 50 0c             	lea    0xc(%eax),%edx
  80dd33:	52                   	push   %edx
  80dd34:	83 c0 10             	add    $0x10,%eax
  80dd37:	50                   	push   %eax
  80dd38:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80dd3f:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80dd45:	50                   	push   %eax
  80dd46:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80dd4c:	e8 75 a7 ff ff       	call   8084c6 <tcp_rst>
  80dd51:	83 c4 20             	add    $0x20,%esp
  80dd54:	eb 14                	jmp    80dd6a <tcp_input+0xd3b>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80dd56:	83 ec 0c             	sub    $0xc,%esp
  80dd59:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80dd5d:	50                   	push   %eax
  80dd5e:	e8 6f 99 ff ff       	call   8076d2 <ntohs>
  80dd63:	83 c4 10             	add    $0x10,%esp
  80dd66:	a8 04                	test   $0x4,%al
  80dd68:	74 af                	je     80dd19 <tcp_input+0xcea>
    pbuf_free(p);
  80dd6a:	83 ec 0c             	sub    $0xc,%esp
  80dd6d:	56                   	push   %esi
  80dd6e:	e8 70 6a ff ff       	call   8047e3 <pbuf_free>
  80dd73:	83 c4 10             	add    $0x10,%esp
  80dd76:	e9 1f f3 ff ff       	jmp    80d09a <tcp_input+0x6b>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd7b:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80dd81:	e9 ee f6 ff ff       	jmp    80d474 <tcp_input+0x445>

0080dd86 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80dd86:	55                   	push   %ebp
  80dd87:	89 e5                	mov    %esp,%ebp
  80dd89:	57                   	push   %edi
  80dd8a:	56                   	push   %esi
  80dd8b:	53                   	push   %ebx
  80dd8c:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80dd8f:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd92:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80dd95:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80dd99:	50                   	push   %eax
  80dd9a:	e8 33 99 ff ff       	call   8076d2 <ntohs>
  80dd9f:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80dda1:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dda7:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80ddaa:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80ddaf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80ddb6:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80ddb9:	eb 12                	jmp    80ddcd <raw_input+0x47>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80ddbb:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80ddc0:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80ddc7:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80ddca:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80ddcd:	84 c0                	test   %al,%al
  80ddcf:	75 55                	jne    80de26 <raw_input+0xa0>
  80ddd1:	85 db                	test   %ebx,%ebx
  80ddd3:	74 51                	je     80de26 <raw_input+0xa0>
    if (pcb->protocol == proto) {
  80ddd5:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80ddd9:	b8 00 00 00 00       	mov    $0x0,%eax
  80ddde:	39 f2                	cmp    %esi,%edx
  80dde0:	75 e5                	jne    80ddc7 <raw_input+0x41>
      if (pcb->recv != NULL) {
  80dde2:	8b 53 14             	mov    0x14(%ebx),%edx
  80dde5:	85 d2                	test   %edx,%edx
  80dde7:	74 de                	je     80ddc7 <raw_input+0x41>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dde9:	8d 47 0c             	lea    0xc(%edi),%eax
  80ddec:	50                   	push   %eax
  80dded:	ff 75 08             	pushl  0x8(%ebp)
  80ddf0:	53                   	push   %ebx
  80ddf1:	ff 73 18             	pushl  0x18(%ebx)
  80ddf4:	ff d2                	call   *%edx
  80ddf6:	83 c4 10             	add    $0x10,%esp
  80ddf9:	84 c0                	test   %al,%al
  80ddfb:	74 ca                	je     80ddc7 <raw_input+0x41>
          if (prev != NULL) {
  80ddfd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80de00:	85 c9                	test   %ecx,%ecx
  80de02:	74 b7                	je     80ddbb <raw_input+0x35>
            prev->next = pcb->next;
  80de04:	8b 43 0c             	mov    0xc(%ebx),%eax
  80de07:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80de0a:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80de0f:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80de12:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
          eaten = 1;
  80de18:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80de1d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80de24:	eb a1                	jmp    80ddc7 <raw_input+0x41>
  }
  return eaten;
}
  80de26:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80de29:	5b                   	pop    %ebx
  80de2a:	5e                   	pop    %esi
  80de2b:	5f                   	pop    %edi
  80de2c:	5d                   	pop    %ebp
  80de2d:	c3                   	ret    

0080de2e <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80de2e:	55                   	push   %ebp
  80de2f:	89 e5                	mov    %esp,%ebp
  80de31:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80de34:	b8 00 00 00 00       	mov    $0x0,%eax
  80de39:	85 d2                	test   %edx,%edx
  80de3b:	74 02                	je     80de3f <raw_bind+0x11>
  80de3d:	8b 02                	mov    (%edx),%eax
  80de3f:	8b 55 08             	mov    0x8(%ebp),%edx
  80de42:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80de44:	b8 00 00 00 00       	mov    $0x0,%eax
  80de49:	5d                   	pop    %ebp
  80de4a:	c3                   	ret    

0080de4b <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80de4b:	55                   	push   %ebp
  80de4c:	89 e5                	mov    %esp,%ebp
  80de4e:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80de51:	b8 00 00 00 00       	mov    $0x0,%eax
  80de56:	85 d2                	test   %edx,%edx
  80de58:	74 02                	je     80de5c <raw_connect+0x11>
  80de5a:	8b 02                	mov    (%edx),%eax
  80de5c:	8b 55 08             	mov    0x8(%ebp),%edx
  80de5f:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80de62:	b8 00 00 00 00       	mov    $0x0,%eax
  80de67:	5d                   	pop    %ebp
  80de68:	c3                   	ret    

0080de69 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80de69:	55                   	push   %ebp
  80de6a:	89 e5                	mov    %esp,%ebp
  80de6c:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80de6f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80de72:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80de75:	8b 55 10             	mov    0x10(%ebp),%edx
  80de78:	89 50 18             	mov    %edx,0x18(%eax)
}
  80de7b:	5d                   	pop    %ebp
  80de7c:	c3                   	ret    

0080de7d <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80de7d:	55                   	push   %ebp
  80de7e:	89 e5                	mov    %esp,%ebp
  80de80:	57                   	push   %edi
  80de81:	56                   	push   %esi
  80de82:	53                   	push   %ebx
  80de83:	83 ec 14             	sub    $0x14,%esp
  80de86:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80de89:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80de8c:	6a 14                	push   $0x14
  80de8e:	57                   	push   %edi
  80de8f:	e8 82 68 ff ff       	call   804716 <pbuf_header>
  80de94:	83 c4 10             	add    $0x10,%esp
  80de97:	84 c0                	test   %al,%al
  80de99:	74 52                	je     80deed <raw_sendto+0x70>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80de9b:	83 ec 04             	sub    $0x4,%esp
  80de9e:	6a 00                	push   $0x0
  80dea0:	6a 00                	push   $0x0
  80dea2:	6a 01                	push   $0x1
  80dea4:	e8 00 6a ff ff       	call   8048a9 <pbuf_alloc>
  80dea9:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80deab:	83 c4 10             	add    $0x10,%esp
  80deae:	85 c0                	test   %eax,%eax
  80deb0:	0f 84 be 00 00 00    	je     80df74 <raw_sendto+0xf7>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80deb6:	83 ec 08             	sub    $0x8,%esp
  80deb9:	57                   	push   %edi
  80deba:	50                   	push   %eax
  80debb:	e8 04 6e ff ff       	call   804cc4 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dec0:	83 c4 04             	add    $0x4,%esp
  80dec3:	ff 75 10             	pushl  0x10(%ebp)
  80dec6:	e8 d6 85 ff ff       	call   8064a1 <ip_route>
  80decb:	83 c4 10             	add    $0x10,%esp
  80dece:	85 c0                	test   %eax,%eax
  80ded0:	75 41                	jne    80df13 <raw_sendto+0x96>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80ded2:	39 f7                	cmp    %esi,%edi
  80ded4:	0f 84 a1 00 00 00    	je     80df7b <raw_sendto+0xfe>
      pbuf_free(q);
  80deda:	83 ec 0c             	sub    $0xc,%esp
  80dedd:	56                   	push   %esi
  80dede:	e8 00 69 ff ff       	call   8047e3 <pbuf_free>
  80dee3:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80dee6:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80deeb:	eb 66                	jmp    80df53 <raw_sendto+0xd6>
    if(pbuf_header(q, -IP_HLEN)) {
  80deed:	83 ec 08             	sub    $0x8,%esp
  80def0:	6a ec                	push   $0xffffffec
  80def2:	57                   	push   %edi
  80def3:	e8 1e 68 ff ff       	call   804716 <pbuf_header>
  80def8:	83 c4 10             	add    $0x10,%esp
  80defb:	84 c0                	test   %al,%al
  80defd:	75 5e                	jne    80df5d <raw_sendto+0xe0>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80deff:	83 ec 0c             	sub    $0xc,%esp
  80df02:	ff 75 10             	pushl  0x10(%ebp)
  80df05:	e8 97 85 ff ff       	call   8064a1 <ip_route>
  80df0a:	83 c4 10             	add    $0x10,%esp
  80df0d:	85 c0                	test   %eax,%eax
  80df0f:	74 71                	je     80df82 <raw_sendto+0x105>
    q = p;
  80df11:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80df13:	89 da                	mov    %ebx,%edx
  80df15:	85 db                	test   %ebx,%ebx
  80df17:	74 05                	je     80df1e <raw_sendto+0xa1>
  80df19:	83 3b 00             	cmpl   $0x0,(%ebx)
  80df1c:	75 03                	jne    80df21 <raw_sendto+0xa4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80df1e:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80df21:	83 ec 04             	sub    $0x4,%esp
  80df24:	50                   	push   %eax
  80df25:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80df29:	50                   	push   %eax
  80df2a:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80df2e:	50                   	push   %eax
  80df2f:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80df33:	50                   	push   %eax
  80df34:	ff 75 10             	pushl  0x10(%ebp)
  80df37:	52                   	push   %edx
  80df38:	56                   	push   %esi
  80df39:	e8 e6 88 ff ff       	call   806824 <ip_output_if>
  80df3e:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80df40:	83 c4 20             	add    $0x20,%esp
  80df43:	39 f7                	cmp    %esi,%edi
  80df45:	74 0c                	je     80df53 <raw_sendto+0xd6>
    /* free the header */
    pbuf_free(q);
  80df47:	83 ec 0c             	sub    $0xc,%esp
  80df4a:	56                   	push   %esi
  80df4b:	e8 93 68 ff ff       	call   8047e3 <pbuf_free>
  80df50:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80df53:	89 d8                	mov    %ebx,%eax
  80df55:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80df58:	5b                   	pop    %ebx
  80df59:	5e                   	pop    %esi
  80df5a:	5f                   	pop    %edi
  80df5b:	5d                   	pop    %ebp
  80df5c:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80df5d:	83 ec 04             	sub    $0x4,%esp
  80df60:	68 60 32 81 00       	push   $0x813260
  80df65:	68 e3 00 00 00       	push   $0xe3
  80df6a:	68 86 32 81 00       	push   $0x813286
  80df6f:	e8 fc 05 00 00       	call   80e570 <_panic>
      return ERR_MEM;
  80df74:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80df79:	eb d8                	jmp    80df53 <raw_sendto+0xd6>
    return ERR_RTE;
  80df7b:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80df80:	eb d1                	jmp    80df53 <raw_sendto+0xd6>
  80df82:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80df87:	eb ca                	jmp    80df53 <raw_sendto+0xd6>

0080df89 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80df89:	55                   	push   %ebp
  80df8a:	89 e5                	mov    %esp,%ebp
  80df8c:	83 ec 0c             	sub    $0xc,%esp
  80df8f:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80df92:	8d 50 04             	lea    0x4(%eax),%edx
  80df95:	52                   	push   %edx
  80df96:	ff 75 0c             	pushl  0xc(%ebp)
  80df99:	50                   	push   %eax
  80df9a:	e8 de fe ff ff       	call   80de7d <raw_sendto>
}
  80df9f:	c9                   	leave  
  80dfa0:	c3                   	ret    

0080dfa1 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80dfa1:	55                   	push   %ebp
  80dfa2:	89 e5                	mov    %esp,%ebp
  80dfa4:	83 ec 08             	sub    $0x8,%esp
  80dfa7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80dfaa:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80dfaf:	39 c8                	cmp    %ecx,%eax
  80dfb1:	75 1b                	jne    80dfce <raw_remove+0x2d>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80dfb3:	8b 41 0c             	mov    0xc(%ecx),%eax
  80dfb6:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80dfbb:	83 ec 08             	sub    $0x8,%esp
  80dfbe:	51                   	push   %ecx
  80dfbf:	6a 00                	push   $0x0
  80dfc1:	e8 cd 64 ff ff       	call   804493 <memp_free>
}
  80dfc6:	83 c4 10             	add    $0x10,%esp
  80dfc9:	c9                   	leave  
  80dfca:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80dfcb:	8b 40 0c             	mov    0xc(%eax),%eax
  80dfce:	85 c0                	test   %eax,%eax
  80dfd0:	74 e9                	je     80dfbb <raw_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80dfd2:	8b 50 0c             	mov    0xc(%eax),%edx
  80dfd5:	39 ca                	cmp    %ecx,%edx
  80dfd7:	75 f2                	jne    80dfcb <raw_remove+0x2a>
  80dfd9:	85 d2                	test   %edx,%edx
  80dfdb:	74 ee                	je     80dfcb <raw_remove+0x2a>
        pcb2->next = pcb->next;
  80dfdd:	8b 51 0c             	mov    0xc(%ecx),%edx
  80dfe0:	89 50 0c             	mov    %edx,0xc(%eax)
  80dfe3:	eb e6                	jmp    80dfcb <raw_remove+0x2a>

0080dfe5 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80dfe5:	55                   	push   %ebp
  80dfe6:	89 e5                	mov    %esp,%ebp
  80dfe8:	56                   	push   %esi
  80dfe9:	53                   	push   %ebx
  80dfea:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80dfed:	83 ec 0c             	sub    $0xc,%esp
  80dff0:	6a 00                	push   $0x0
  80dff2:	e8 46 64 ff ff       	call   80443d <memp_malloc>
  80dff7:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80dff9:	83 c4 10             	add    $0x10,%esp
  80dffc:	85 c0                	test   %eax,%eax
  80dffe:	74 27                	je     80e027 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e000:	83 ec 04             	sub    $0x4,%esp
  80e003:	6a 1c                	push   $0x1c
  80e005:	6a 00                	push   $0x0
  80e007:	50                   	push   %eax
  80e008:	e8 60 0d 00 00       	call   80ed6d <memset>
    pcb->protocol = proto;
  80e00d:	89 f0                	mov    %esi,%eax
  80e00f:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e012:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e016:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e01b:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e01e:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80e024:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e027:	89 d8                	mov    %ebx,%eax
  80e029:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e02c:	5b                   	pop    %ebx
  80e02d:	5e                   	pop    %esi
  80e02e:	5d                   	pop    %ebp
  80e02f:	c3                   	ret    

0080e030 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e030:	55                   	push   %ebp
  80e031:	89 e5                	mov    %esp,%ebp
  80e033:	57                   	push   %edi
  80e034:	56                   	push   %esi
  80e035:	53                   	push   %ebx
  80e036:	83 ec 28             	sub    $0x28,%esp
  80e039:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e03c:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e03f:	0f b7 07             	movzwl (%edi),%eax
  80e042:	50                   	push   %eax
  80e043:	e8 8a 96 ff ff       	call   8076d2 <ntohs>
  80e048:	66 c1 e8 06          	shr    $0x6,%ax
  80e04c:	83 e0 3c             	and    $0x3c,%eax
  80e04f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e053:	89 c6                	mov    %eax,%esi
  80e055:	f7 de                	neg    %esi
  80e057:	0f bf f6             	movswl %si,%esi
  80e05a:	83 c4 08             	add    $0x8,%esp
  80e05d:	56                   	push   %esi
  80e05e:	53                   	push   %ebx
  80e05f:	e8 b2 66 ff ff       	call   804716 <pbuf_header>
  80e064:	83 c4 10             	add    $0x10,%esp
  80e067:	84 c0                	test   %al,%al
  80e069:	75 67                	jne    80e0d2 <icmp_input+0xa2>
  80e06b:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e070:	76 60                	jbe    80e0d2 <icmp_input+0xa2>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e072:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e075:	80 38 08             	cmpb   $0x8,(%eax)
  80e078:	74 0e                	je     80e088 <icmp_input+0x58>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e07a:	83 ec 0c             	sub    $0xc,%esp
  80e07d:	53                   	push   %ebx
  80e07e:	e8 60 67 ff ff       	call   8047e3 <pbuf_free>
  return;
  80e083:	83 c4 10             	add    $0x10,%esp
  80e086:	eb 56                	jmp    80e0de <icmp_input+0xae>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e088:	83 ec 08             	sub    $0x8,%esp
  80e08b:	ff 75 0c             	pushl  0xc(%ebp)
  80e08e:	8d 47 10             	lea    0x10(%edi),%eax
  80e091:	50                   	push   %eax
  80e092:	e8 ca 83 ff ff       	call   806461 <ip_addr_isbroadcast>
  80e097:	83 c4 10             	add    $0x10,%esp
  80e09a:	84 c0                	test   %al,%al
  80e09c:	75 48                	jne    80e0e6 <icmp_input+0xb6>
  80e09e:	8b 47 10             	mov    0x10(%edi),%eax
  80e0a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e0a4:	83 ec 0c             	sub    $0xc,%esp
  80e0a7:	68 00 00 00 f0       	push   $0xf0000000
  80e0ac:	e8 45 98 ff ff       	call   8078f6 <ntohl>
  80e0b1:	23 45 e0             	and    -0x20(%ebp),%eax
  80e0b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e0b7:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e0be:	e8 33 98 ff ff       	call   8078f6 <ntohl>
  80e0c3:	83 c4 10             	add    $0x10,%esp
  80e0c6:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e0c9:	74 1b                	je     80e0e6 <icmp_input+0xb6>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e0cb:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e0d0:	77 22                	ja     80e0f4 <icmp_input+0xc4>
lenerr:
  pbuf_free(p);
  80e0d2:	83 ec 0c             	sub    $0xc,%esp
  80e0d5:	53                   	push   %ebx
  80e0d6:	e8 08 67 ff ff       	call   8047e3 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e0db:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e0de:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e0e1:	5b                   	pop    %ebx
  80e0e2:	5e                   	pop    %esi
  80e0e3:	5f                   	pop    %edi
  80e0e4:	5d                   	pop    %ebp
  80e0e5:	c3                   	ret    
      pbuf_free(p);
  80e0e6:	83 ec 0c             	sub    $0xc,%esp
  80e0e9:	53                   	push   %ebx
  80e0ea:	e8 f4 66 ff ff       	call   8047e3 <pbuf_free>
      return;
  80e0ef:	83 c4 10             	add    $0x10,%esp
  80e0f2:	eb ea                	jmp    80e0de <icmp_input+0xae>
    if (inet_chksum_pbuf(p) != 0) {
  80e0f4:	83 ec 0c             	sub    $0xc,%esp
  80e0f7:	53                   	push   %ebx
  80e0f8:	e8 b0 94 ff ff       	call   8075ad <inet_chksum_pbuf>
  80e0fd:	83 c4 10             	add    $0x10,%esp
  80e100:	66 85 c0             	test   %ax,%ax
  80e103:	0f 85 96 00 00 00    	jne    80e19f <icmp_input+0x16f>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e109:	83 ec 08             	sub    $0x8,%esp
  80e10c:	6a 22                	push   $0x22
  80e10e:	53                   	push   %ebx
  80e10f:	e8 02 66 ff ff       	call   804716 <pbuf_header>
  80e114:	83 c4 10             	add    $0x10,%esp
  80e117:	84 c0                	test   %al,%al
  80e119:	0f 84 fb 00 00 00    	je     80e21a <icmp_input+0x1ea>
      if (pbuf_header(p, hlen)) {
  80e11f:	83 ec 08             	sub    $0x8,%esp
  80e122:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e126:	50                   	push   %eax
  80e127:	53                   	push   %ebx
  80e128:	e8 e9 65 ff ff       	call   804716 <pbuf_header>
  80e12d:	83 c4 10             	add    $0x10,%esp
  80e130:	84 c0                	test   %al,%al
  80e132:	75 7c                	jne    80e1b0 <icmp_input+0x180>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e134:	83 ec 04             	sub    $0x4,%esp
  80e137:	6a 00                	push   $0x0
  80e139:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e13d:	50                   	push   %eax
  80e13e:	6a 02                	push   $0x2
  80e140:	e8 64 67 ff ff       	call   8048a9 <pbuf_alloc>
  80e145:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e148:	83 c4 10             	add    $0x10,%esp
  80e14b:	85 c0                	test   %eax,%eax
  80e14d:	74 75                	je     80e1c4 <icmp_input+0x194>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e14f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e152:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e156:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e15a:	83 c0 08             	add    $0x8,%eax
  80e15d:	39 c2                	cmp    %eax,%edx
  80e15f:	72 74                	jb     80e1d5 <icmp_input+0x1a5>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e161:	83 ec 08             	sub    $0x8,%esp
  80e164:	53                   	push   %ebx
  80e165:	ff 75 e0             	pushl  -0x20(%ebp)
  80e168:	e8 1e 6c ff ff       	call   804d8b <pbuf_copy>
  80e16d:	83 c4 10             	add    $0x10,%esp
  80e170:	84 c0                	test   %al,%al
  80e172:	75 78                	jne    80e1ec <icmp_input+0x1bc>
      iphdr = r->payload;
  80e174:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e177:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e17a:	83 ec 08             	sub    $0x8,%esp
  80e17d:	56                   	push   %esi
  80e17e:	50                   	push   %eax
  80e17f:	e8 92 65 ff ff       	call   804716 <pbuf_header>
  80e184:	83 c4 10             	add    $0x10,%esp
  80e187:	84 c0                	test   %al,%al
  80e189:	75 78                	jne    80e203 <icmp_input+0x1d3>
      pbuf_free(p);
  80e18b:	83 ec 0c             	sub    $0xc,%esp
  80e18e:	53                   	push   %ebx
  80e18f:	e8 4f 66 ff ff       	call   8047e3 <pbuf_free>
  80e194:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e197:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e19a:	e9 91 00 00 00       	jmp    80e230 <icmp_input+0x200>
      pbuf_free(p);
  80e19f:	83 ec 0c             	sub    $0xc,%esp
  80e1a2:	53                   	push   %ebx
  80e1a3:	e8 3b 66 ff ff       	call   8047e3 <pbuf_free>
      return;
  80e1a8:	83 c4 10             	add    $0x10,%esp
  80e1ab:	e9 2e ff ff ff       	jmp    80e0de <icmp_input+0xae>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e1b0:	83 ec 04             	sub    $0x4,%esp
  80e1b3:	68 9c 32 81 00       	push   $0x81329c
  80e1b8:	6a 7b                	push   $0x7b
  80e1ba:	68 90 33 81 00       	push   $0x813390
  80e1bf:	e8 ac 03 00 00       	call   80e570 <_panic>
  pbuf_free(p);
  80e1c4:	83 ec 0c             	sub    $0xc,%esp
  80e1c7:	53                   	push   %ebx
  80e1c8:	e8 16 66 ff ff       	call   8047e3 <pbuf_free>
  return;
  80e1cd:	83 c4 10             	add    $0x10,%esp
  80e1d0:	e9 09 ff ff ff       	jmp    80e0de <icmp_input+0xae>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e1d5:	83 ec 04             	sub    $0x4,%esp
  80e1d8:	68 d0 32 81 00       	push   $0x8132d0
  80e1dd:	68 85 00 00 00       	push   $0x85
  80e1e2:	68 90 33 81 00       	push   $0x813390
  80e1e7:	e8 84 03 00 00       	call   80e570 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e1ec:	83 ec 04             	sub    $0x4,%esp
  80e1ef:	68 08 33 81 00       	push   $0x813308
  80e1f4:	68 88 00 00 00       	push   $0x88
  80e1f9:	68 90 33 81 00       	push   $0x813390
  80e1fe:	e8 6d 03 00 00       	call   80e570 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e203:	83 ec 04             	sub    $0x4,%esp
  80e206:	68 30 33 81 00       	push   $0x813330
  80e20b:	68 8e 00 00 00       	push   $0x8e
  80e210:	68 90 33 81 00       	push   $0x813390
  80e215:	e8 56 03 00 00       	call   80e570 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e21a:	83 ec 08             	sub    $0x8,%esp
  80e21d:	6a de                	push   $0xffffffde
  80e21f:	53                   	push   %ebx
  80e220:	e8 f1 64 ff ff       	call   804716 <pbuf_header>
  80e225:	83 c4 10             	add    $0x10,%esp
  80e228:	84 c0                	test   %al,%al
  80e22a:	0f 85 d3 00 00 00    	jne    80e303 <icmp_input+0x2d3>
    iecho = p->payload;
  80e230:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e233:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e236:	8b 57 10             	mov    0x10(%edi),%edx
  80e239:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e23c:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e23f:	83 ec 0c             	sub    $0xc,%esp
  80e242:	0f b7 06             	movzwl (%esi),%eax
  80e245:	50                   	push   %eax
  80e246:	e8 87 94 ff ff       	call   8076d2 <ntohs>
  80e24b:	0f b6 c0             	movzbl %al,%eax
  80e24e:	89 04 24             	mov    %eax,(%esp)
  80e251:	e8 6f 94 ff ff       	call   8076c5 <htons>
  80e256:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e259:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e25d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e261:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e268:	e8 58 94 ff ff       	call   8076c5 <htons>
  80e26d:	83 c4 10             	add    $0x10,%esp
  80e270:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e274:	0f 82 a0 00 00 00    	jb     80e31a <icmp_input+0x2ea>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e27a:	83 ec 0c             	sub    $0xc,%esp
  80e27d:	68 00 08 00 00       	push   $0x800
  80e282:	e8 3e 94 ff ff       	call   8076c5 <htons>
  80e287:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e28b:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  80e28f:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e293:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e296:	83 ec 0c             	sub    $0xc,%esp
  80e299:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e29d:	50                   	push   %eax
  80e29e:	e8 2f 94 ff ff       	call   8076d2 <ntohs>
  80e2a3:	66 0d 00 ff          	or     $0xff00,%ax
  80e2a7:	0f b7 c0             	movzwl %ax,%eax
  80e2aa:	89 04 24             	mov    %eax,(%esp)
  80e2ad:	e8 13 94 ff ff       	call   8076c5 <htons>
  80e2b2:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e2b6:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e2bc:	83 c4 08             	add    $0x8,%esp
  80e2bf:	6a 14                	push   $0x14
  80e2c1:	57                   	push   %edi
  80e2c2:	e8 d0 92 ff ff       	call   807597 <inet_chksum>
  80e2c7:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e2cb:	83 c4 08             	add    $0x8,%esp
  80e2ce:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e2d2:	50                   	push   %eax
  80e2d3:	53                   	push   %ebx
  80e2d4:	e8 3d 64 ff ff       	call   804716 <pbuf_header>
  80e2d9:	83 c4 10             	add    $0x10,%esp
  80e2dc:	84 c0                	test   %al,%al
  80e2de:	75 53                	jne    80e333 <icmp_input+0x303>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e2e0:	83 ec 04             	sub    $0x4,%esp
  80e2e3:	ff 75 0c             	pushl  0xc(%ebp)
  80e2e6:	6a 01                	push   $0x1
  80e2e8:	6a 00                	push   $0x0
  80e2ea:	68 ff 00 00 00       	push   $0xff
  80e2ef:	6a 00                	push   $0x0
  80e2f1:	83 c7 0c             	add    $0xc,%edi
  80e2f4:	57                   	push   %edi
  80e2f5:	53                   	push   %ebx
  80e2f6:	e8 29 85 ff ff       	call   806824 <ip_output_if>
  80e2fb:	83 c4 20             	add    $0x20,%esp
  80e2fe:	e9 77 fd ff ff       	jmp    80e07a <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e303:	83 ec 04             	sub    $0x4,%esp
  80e306:	68 30 33 81 00       	push   $0x813330
  80e30b:	68 98 00 00 00       	push   $0x98
  80e310:	68 90 33 81 00       	push   $0x813390
  80e315:	e8 56 02 00 00       	call   80e570 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e31a:	83 ec 0c             	sub    $0xc,%esp
  80e31d:	68 00 08 00 00       	push   $0x800
  80e322:	e8 9e 93 ff ff       	call   8076c5 <htons>
  80e327:	66 01 46 02          	add    %ax,0x2(%esi)
  80e32b:	83 c4 10             	add    $0x10,%esp
  80e32e:	e9 63 ff ff ff       	jmp    80e296 <icmp_input+0x266>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e333:	83 ec 04             	sub    $0x4,%esp
  80e336:	68 f8 23 81 00       	push   $0x8123f8
  80e33b:	68 b9 00 00 00       	push   $0xb9
  80e340:	68 90 33 81 00       	push   $0x813390
  80e345:	e8 26 02 00 00       	call   80e570 <_panic>

0080e34a <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e34a:	55                   	push   %ebp
  80e34b:	89 e5                	mov    %esp,%ebp
  80e34d:	57                   	push   %edi
  80e34e:	56                   	push   %esi
  80e34f:	53                   	push   %ebx
  80e350:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e353:	6a 00                	push   $0x0
  80e355:	6a 24                	push   $0x24
  80e357:	6a 01                	push   $0x1
  80e359:	e8 4b 65 ff ff       	call   8048a9 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e35e:	83 c4 10             	add    $0x10,%esp
  80e361:	85 c0                	test   %eax,%eax
  80e363:	0f 84 a5 00 00 00    	je     80e40e <icmp_dest_unreach+0xc4>
  80e369:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e36b:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e370:	0f 86 a0 00 00 00    	jbe    80e416 <icmp_dest_unreach+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e376:	8b 45 08             	mov    0x8(%ebp),%eax
  80e379:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e37c:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e37f:	83 ec 0c             	sub    $0xc,%esp
  80e382:	0f b7 06             	movzwl (%esi),%eax
  80e385:	50                   	push   %eax
  80e386:	e8 47 93 ff ff       	call   8076d2 <ntohs>
  80e38b:	0f b6 c0             	movzbl %al,%eax
  80e38e:	80 cc 03             	or     $0x3,%ah
  80e391:	89 04 24             	mov    %eax,(%esp)
  80e394:	e8 2c 93 ff ff       	call   8076c5 <htons>
  80e399:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e39c:	0f b7 c0             	movzwl %ax,%eax
  80e39f:	89 04 24             	mov    %eax,(%esp)
  80e3a2:	e8 2b 93 ff ff       	call   8076d2 <ntohs>
  80e3a7:	b0 00                	mov    $0x0,%al
  80e3a9:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e3ad:	0f b7 c0             	movzwl %ax,%eax
  80e3b0:	89 04 24             	mov    %eax,(%esp)
  80e3b3:	e8 0d 93 ff ff       	call   8076c5 <htons>
  80e3b8:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e3bb:	83 c4 0c             	add    $0xc,%esp
  80e3be:	6a 1c                	push   $0x1c
  80e3c0:	8b 45 08             	mov    0x8(%ebp),%eax
  80e3c3:	ff 70 04             	pushl  0x4(%eax)
  80e3c6:	8b 43 04             	mov    0x4(%ebx),%eax
  80e3c9:	83 c0 08             	add    $0x8,%eax
  80e3cc:	50                   	push   %eax
  80e3cd:	e8 45 0a 00 00       	call   80ee17 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e3d2:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e3d8:	83 c4 08             	add    $0x8,%esp
  80e3db:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e3df:	50                   	push   %eax
  80e3e0:	56                   	push   %esi
  80e3e1:	e8 b1 91 ff ff       	call   807597 <inet_chksum>
  80e3e6:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e3ea:	83 c4 08             	add    $0x8,%esp
  80e3ed:	6a 01                	push   $0x1
  80e3ef:	6a 00                	push   $0x0
  80e3f1:	68 ff 00 00 00       	push   $0xff
  80e3f6:	83 c7 0c             	add    $0xc,%edi
  80e3f9:	57                   	push   %edi
  80e3fa:	6a 00                	push   $0x0
  80e3fc:	53                   	push   %ebx
  80e3fd:	e8 af 85 ff ff       	call   8069b1 <ip_output>
  pbuf_free(q);
  80e402:	83 c4 14             	add    $0x14,%esp
  80e405:	53                   	push   %ebx
  80e406:	e8 d8 63 ff ff       	call   8047e3 <pbuf_free>
  80e40b:	83 c4 10             	add    $0x10,%esp
}
  80e40e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e411:	5b                   	pop    %ebx
  80e412:	5e                   	pop    %esi
  80e413:	5f                   	pop    %edi
  80e414:	5d                   	pop    %ebp
  80e415:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e416:	83 ec 04             	sub    $0x4,%esp
  80e419:	68 64 33 81 00       	push   $0x813364
  80e41e:	68 ef 00 00 00       	push   $0xef
  80e423:	68 90 33 81 00       	push   $0x813390
  80e428:	e8 43 01 00 00       	call   80e570 <_panic>

0080e42d <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e42d:	55                   	push   %ebp
  80e42e:	89 e5                	mov    %esp,%ebp
  80e430:	57                   	push   %edi
  80e431:	56                   	push   %esi
  80e432:	53                   	push   %ebx
  80e433:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e436:	6a 00                	push   $0x0
  80e438:	6a 24                	push   $0x24
  80e43a:	6a 01                	push   $0x1
  80e43c:	e8 68 64 ff ff       	call   8048a9 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e441:	83 c4 10             	add    $0x10,%esp
  80e444:	85 c0                	test   %eax,%eax
  80e446:	0f 84 a5 00 00 00    	je     80e4f1 <icmp_time_exceeded+0xc4>
  80e44c:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e44e:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e453:	0f 86 a0 00 00 00    	jbe    80e4f9 <icmp_time_exceeded+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e459:	8b 45 08             	mov    0x8(%ebp),%eax
  80e45c:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e45f:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e462:	83 ec 0c             	sub    $0xc,%esp
  80e465:	0f b7 06             	movzwl (%esi),%eax
  80e468:	50                   	push   %eax
  80e469:	e8 64 92 ff ff       	call   8076d2 <ntohs>
  80e46e:	0f b6 c0             	movzbl %al,%eax
  80e471:	80 cc 0b             	or     $0xb,%ah
  80e474:	89 04 24             	mov    %eax,(%esp)
  80e477:	e8 49 92 ff ff       	call   8076c5 <htons>
  80e47c:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e47f:	0f b7 c0             	movzwl %ax,%eax
  80e482:	89 04 24             	mov    %eax,(%esp)
  80e485:	e8 48 92 ff ff       	call   8076d2 <ntohs>
  80e48a:	b0 00                	mov    $0x0,%al
  80e48c:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e490:	0f b7 c0             	movzwl %ax,%eax
  80e493:	89 04 24             	mov    %eax,(%esp)
  80e496:	e8 2a 92 ff ff       	call   8076c5 <htons>
  80e49b:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e49e:	83 c4 0c             	add    $0xc,%esp
  80e4a1:	6a 1c                	push   $0x1c
  80e4a3:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4a6:	ff 70 04             	pushl  0x4(%eax)
  80e4a9:	8b 43 04             	mov    0x4(%ebx),%eax
  80e4ac:	83 c0 08             	add    $0x8,%eax
  80e4af:	50                   	push   %eax
  80e4b0:	e8 62 09 00 00       	call   80ee17 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e4b5:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e4bb:	83 c4 08             	add    $0x8,%esp
  80e4be:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e4c2:	50                   	push   %eax
  80e4c3:	56                   	push   %esi
  80e4c4:	e8 ce 90 ff ff       	call   807597 <inet_chksum>
  80e4c9:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e4cd:	83 c4 08             	add    $0x8,%esp
  80e4d0:	6a 01                	push   $0x1
  80e4d2:	6a 00                	push   $0x0
  80e4d4:	68 ff 00 00 00       	push   $0xff
  80e4d9:	83 c7 0c             	add    $0xc,%edi
  80e4dc:	57                   	push   %edi
  80e4dd:	6a 00                	push   $0x0
  80e4df:	53                   	push   %ebx
  80e4e0:	e8 cc 84 ff ff       	call   8069b1 <ip_output>
  pbuf_free(q);
  80e4e5:	83 c4 14             	add    $0x14,%esp
  80e4e8:	53                   	push   %ebx
  80e4e9:	e8 f5 62 ff ff       	call   8047e3 <pbuf_free>
  80e4ee:	83 c4 10             	add    $0x10,%esp
}
  80e4f1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e4f4:	5b                   	pop    %ebx
  80e4f5:	5e                   	pop    %esi
  80e4f6:	5f                   	pop    %edi
  80e4f7:	5d                   	pop    %ebp
  80e4f8:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e4f9:	83 ec 04             	sub    $0x4,%esp
  80e4fc:	68 64 33 81 00       	push   $0x813364
  80e501:	68 1e 01 00 00       	push   $0x11e
  80e506:	68 90 33 81 00       	push   $0x813390
  80e50b:	e8 60 00 00 00       	call   80e570 <_panic>

0080e510 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e510:	55                   	push   %ebp
  80e511:	89 e5                	mov    %esp,%ebp
  80e513:	56                   	push   %esi
  80e514:	53                   	push   %ebx
  80e515:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e518:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80e51b:	e8 bb 0a 00 00       	call   80efdb <sys_getenvid>
  80e520:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e525:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e528:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e52d:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e532:	85 db                	test   %ebx,%ebx
  80e534:	7e 07                	jle    80e53d <libmain+0x2d>
		binaryname = argv[0];
  80e536:	8b 06                	mov    (%esi),%eax
  80e538:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e53d:	83 ec 08             	sub    $0x8,%esp
  80e540:	56                   	push   %esi
  80e541:	53                   	push   %ebx
  80e542:	e8 35 20 ff ff       	call   80057c <umain>

	// exit gracefully
	exit();
  80e547:	e8 0a 00 00 00       	call   80e556 <exit>
}
  80e54c:	83 c4 10             	add    $0x10,%esp
  80e54f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e552:	5b                   	pop    %ebx
  80e553:	5e                   	pop    %esi
  80e554:	5d                   	pop    %ebp
  80e555:	c3                   	ret    

0080e556 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e556:	55                   	push   %ebp
  80e557:	89 e5                	mov    %esp,%ebp
  80e559:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e55c:	e8 5d 13 00 00       	call   80f8be <close_all>
	sys_env_destroy(0);
  80e561:	83 ec 0c             	sub    $0xc,%esp
  80e564:	6a 00                	push   $0x0
  80e566:	e8 2f 0a 00 00       	call   80ef9a <sys_env_destroy>
}
  80e56b:	83 c4 10             	add    $0x10,%esp
  80e56e:	c9                   	leave  
  80e56f:	c3                   	ret    

0080e570 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e570:	55                   	push   %ebp
  80e571:	89 e5                	mov    %esp,%ebp
  80e573:	56                   	push   %esi
  80e574:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e575:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e578:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e57e:	e8 58 0a 00 00       	call   80efdb <sys_getenvid>
  80e583:	83 ec 0c             	sub    $0xc,%esp
  80e586:	ff 75 0c             	pushl  0xc(%ebp)
  80e589:	ff 75 08             	pushl  0x8(%ebp)
  80e58c:	56                   	push   %esi
  80e58d:	50                   	push   %eax
  80e58e:	68 b4 33 81 00       	push   $0x8133b4
  80e593:	e8 b3 00 00 00       	call   80e64b <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e598:	83 c4 18             	add    $0x18,%esp
  80e59b:	53                   	push   %ebx
  80e59c:	ff 75 10             	pushl  0x10(%ebp)
  80e59f:	e8 56 00 00 00       	call   80e5fa <vcprintf>
	cprintf("\n");
  80e5a4:	c7 04 24 a8 0f 81 00 	movl   $0x810fa8,(%esp)
  80e5ab:	e8 9b 00 00 00       	call   80e64b <cprintf>
  80e5b0:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e5b3:	cc                   	int3   
  80e5b4:	eb fd                	jmp    80e5b3 <_panic+0x43>

0080e5b6 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e5b6:	55                   	push   %ebp
  80e5b7:	89 e5                	mov    %esp,%ebp
  80e5b9:	53                   	push   %ebx
  80e5ba:	83 ec 04             	sub    $0x4,%esp
  80e5bd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e5c0:	8b 13                	mov    (%ebx),%edx
  80e5c2:	8d 42 01             	lea    0x1(%edx),%eax
  80e5c5:	89 03                	mov    %eax,(%ebx)
  80e5c7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e5ca:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e5ce:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e5d3:	74 09                	je     80e5de <putch+0x28>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e5d5:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e5d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e5dc:	c9                   	leave  
  80e5dd:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e5de:	83 ec 08             	sub    $0x8,%esp
  80e5e1:	68 ff 00 00 00       	push   $0xff
  80e5e6:	8d 43 08             	lea    0x8(%ebx),%eax
  80e5e9:	50                   	push   %eax
  80e5ea:	e8 6e 09 00 00       	call   80ef5d <sys_cputs>
		b->idx = 0;
  80e5ef:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e5f5:	83 c4 10             	add    $0x10,%esp
  80e5f8:	eb db                	jmp    80e5d5 <putch+0x1f>

0080e5fa <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e5fa:	55                   	push   %ebp
  80e5fb:	89 e5                	mov    %esp,%ebp
  80e5fd:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e603:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e60a:	00 00 00 
	b.cnt = 0;
  80e60d:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e614:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e617:	ff 75 0c             	pushl  0xc(%ebp)
  80e61a:	ff 75 08             	pushl  0x8(%ebp)
  80e61d:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e623:	50                   	push   %eax
  80e624:	68 b6 e5 80 00       	push   $0x80e5b6
  80e629:	e8 19 01 00 00       	call   80e747 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e62e:	83 c4 08             	add    $0x8,%esp
  80e631:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e637:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e63d:	50                   	push   %eax
  80e63e:	e8 1a 09 00 00       	call   80ef5d <sys_cputs>

	return b.cnt;
}
  80e643:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e649:	c9                   	leave  
  80e64a:	c3                   	ret    

0080e64b <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e64b:	55                   	push   %ebp
  80e64c:	89 e5                	mov    %esp,%ebp
  80e64e:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e651:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e654:	50                   	push   %eax
  80e655:	ff 75 08             	pushl  0x8(%ebp)
  80e658:	e8 9d ff ff ff       	call   80e5fa <vcprintf>
	va_end(ap);

	return cnt;
}
  80e65d:	c9                   	leave  
  80e65e:	c3                   	ret    

0080e65f <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e65f:	55                   	push   %ebp
  80e660:	89 e5                	mov    %esp,%ebp
  80e662:	57                   	push   %edi
  80e663:	56                   	push   %esi
  80e664:	53                   	push   %ebx
  80e665:	83 ec 1c             	sub    $0x1c,%esp
  80e668:	89 c7                	mov    %eax,%edi
  80e66a:	89 d6                	mov    %edx,%esi
  80e66c:	8b 45 08             	mov    0x8(%ebp),%eax
  80e66f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e672:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e675:	89 55 dc             	mov    %edx,-0x24(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e678:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80e67b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80e680:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e683:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e686:	3b 45 10             	cmp    0x10(%ebp),%eax
  80e689:	89 d0                	mov    %edx,%eax
  80e68b:	1b 45 e4             	sbb    -0x1c(%ebp),%eax
  80e68e:	8b 5d 14             	mov    0x14(%ebp),%ebx
  80e691:	73 15                	jae    80e6a8 <printnum+0x49>
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80e693:	83 eb 01             	sub    $0x1,%ebx
  80e696:	85 db                	test   %ebx,%ebx
  80e698:	7e 43                	jle    80e6dd <printnum+0x7e>
			putch(padc, putdat);
  80e69a:	83 ec 08             	sub    $0x8,%esp
  80e69d:	56                   	push   %esi
  80e69e:	ff 75 18             	pushl  0x18(%ebp)
  80e6a1:	ff d7                	call   *%edi
  80e6a3:	83 c4 10             	add    $0x10,%esp
  80e6a6:	eb eb                	jmp    80e693 <printnum+0x34>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e6a8:	83 ec 0c             	sub    $0xc,%esp
  80e6ab:	ff 75 18             	pushl  0x18(%ebp)
  80e6ae:	8b 45 14             	mov    0x14(%ebp),%eax
  80e6b1:	8d 58 ff             	lea    -0x1(%eax),%ebx
  80e6b4:	53                   	push   %ebx
  80e6b5:	ff 75 10             	pushl  0x10(%ebp)
  80e6b8:	83 ec 08             	sub    $0x8,%esp
  80e6bb:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e6be:	ff 75 e0             	pushl  -0x20(%ebp)
  80e6c1:	ff 75 dc             	pushl  -0x24(%ebp)
  80e6c4:	ff 75 d8             	pushl  -0x28(%ebp)
  80e6c7:	e8 f4 24 00 00       	call   810bc0 <__udivdi3>
  80e6cc:	83 c4 18             	add    $0x18,%esp
  80e6cf:	52                   	push   %edx
  80e6d0:	50                   	push   %eax
  80e6d1:	89 f2                	mov    %esi,%edx
  80e6d3:	89 f8                	mov    %edi,%eax
  80e6d5:	e8 85 ff ff ff       	call   80e65f <printnum>
  80e6da:	83 c4 20             	add    $0x20,%esp
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e6dd:	83 ec 08             	sub    $0x8,%esp
  80e6e0:	56                   	push   %esi
  80e6e1:	83 ec 04             	sub    $0x4,%esp
  80e6e4:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e6e7:	ff 75 e0             	pushl  -0x20(%ebp)
  80e6ea:	ff 75 dc             	pushl  -0x24(%ebp)
  80e6ed:	ff 75 d8             	pushl  -0x28(%ebp)
  80e6f0:	e8 db 25 00 00       	call   810cd0 <__umoddi3>
  80e6f5:	83 c4 14             	add    $0x14,%esp
  80e6f8:	0f be 80 d7 33 81 00 	movsbl 0x8133d7(%eax),%eax
  80e6ff:	50                   	push   %eax
  80e700:	ff d7                	call   *%edi
}
  80e702:	83 c4 10             	add    $0x10,%esp
  80e705:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e708:	5b                   	pop    %ebx
  80e709:	5e                   	pop    %esi
  80e70a:	5f                   	pop    %edi
  80e70b:	5d                   	pop    %ebp
  80e70c:	c3                   	ret    

0080e70d <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e70d:	55                   	push   %ebp
  80e70e:	89 e5                	mov    %esp,%ebp
  80e710:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e713:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e717:	8b 10                	mov    (%eax),%edx
  80e719:	3b 50 04             	cmp    0x4(%eax),%edx
  80e71c:	73 0a                	jae    80e728 <sprintputch+0x1b>
		*b->buf++ = ch;
  80e71e:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e721:	89 08                	mov    %ecx,(%eax)
  80e723:	8b 45 08             	mov    0x8(%ebp),%eax
  80e726:	88 02                	mov    %al,(%edx)
}
  80e728:	5d                   	pop    %ebp
  80e729:	c3                   	ret    

0080e72a <printfmt>:
{
  80e72a:	55                   	push   %ebp
  80e72b:	89 e5                	mov    %esp,%ebp
  80e72d:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80e730:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e733:	50                   	push   %eax
  80e734:	ff 75 10             	pushl  0x10(%ebp)
  80e737:	ff 75 0c             	pushl  0xc(%ebp)
  80e73a:	ff 75 08             	pushl  0x8(%ebp)
  80e73d:	e8 05 00 00 00       	call   80e747 <vprintfmt>
}
  80e742:	83 c4 10             	add    $0x10,%esp
  80e745:	c9                   	leave  
  80e746:	c3                   	ret    

0080e747 <vprintfmt>:
{
  80e747:	55                   	push   %ebp
  80e748:	89 e5                	mov    %esp,%ebp
  80e74a:	57                   	push   %edi
  80e74b:	56                   	push   %esi
  80e74c:	53                   	push   %ebx
  80e74d:	83 ec 3c             	sub    $0x3c,%esp
  80e750:	8b 75 08             	mov    0x8(%ebp),%esi
  80e753:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e756:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e759:	eb 0a                	jmp    80e765 <vprintfmt+0x1e>
			putch(ch, putdat);
  80e75b:	83 ec 08             	sub    $0x8,%esp
  80e75e:	53                   	push   %ebx
  80e75f:	50                   	push   %eax
  80e760:	ff d6                	call   *%esi
  80e762:	83 c4 10             	add    $0x10,%esp
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80e765:	83 c7 01             	add    $0x1,%edi
  80e768:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e76c:	83 f8 25             	cmp    $0x25,%eax
  80e76f:	74 0c                	je     80e77d <vprintfmt+0x36>
			if (ch == '\0')
  80e771:	85 c0                	test   %eax,%eax
  80e773:	75 e6                	jne    80e75b <vprintfmt+0x14>
}
  80e775:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e778:	5b                   	pop    %ebx
  80e779:	5e                   	pop    %esi
  80e77a:	5f                   	pop    %edi
  80e77b:	5d                   	pop    %ebp
  80e77c:	c3                   	ret    
		padc = ' ';
  80e77d:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
		altflag = 0;
  80e781:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		precision = -1;
  80e788:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80e78f:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80e796:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e79b:	8d 47 01             	lea    0x1(%edi),%eax
  80e79e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e7a1:	0f b6 17             	movzbl (%edi),%edx
  80e7a4:	8d 42 dd             	lea    -0x23(%edx),%eax
  80e7a7:	3c 55                	cmp    $0x55,%al
  80e7a9:	0f 87 ba 03 00 00    	ja     80eb69 <vprintfmt+0x422>
  80e7af:	0f b6 c0             	movzbl %al,%eax
  80e7b2:	ff 24 85 20 35 81 00 	jmp    *0x813520(,%eax,4)
  80e7b9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80e7bc:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%ebp)
  80e7c0:	eb d9                	jmp    80e79b <vprintfmt+0x54>
		switch (ch = *(unsigned char *) fmt++) {
  80e7c2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '0';
  80e7c5:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
  80e7c9:	eb d0                	jmp    80e79b <vprintfmt+0x54>
		switch (ch = *(unsigned char *) fmt++) {
  80e7cb:	0f b6 d2             	movzbl %dl,%edx
  80e7ce:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80e7d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80e7d6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
				precision = precision * 10 + ch - '0';
  80e7d9:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e7dc:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80e7e0:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80e7e3:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80e7e6:	83 f9 09             	cmp    $0x9,%ecx
  80e7e9:	77 55                	ja     80e840 <vprintfmt+0xf9>
			for (precision = 0; ; ++fmt) {
  80e7eb:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80e7ee:	eb e9                	jmp    80e7d9 <vprintfmt+0x92>
			precision = va_arg(ap, int);
  80e7f0:	8b 45 14             	mov    0x14(%ebp),%eax
  80e7f3:	8b 00                	mov    (%eax),%eax
  80e7f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e7f8:	8b 45 14             	mov    0x14(%ebp),%eax
  80e7fb:	8d 40 04             	lea    0x4(%eax),%eax
  80e7fe:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e801:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80e804:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e808:	79 91                	jns    80e79b <vprintfmt+0x54>
				width = precision, precision = -1;
  80e80a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e80d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e810:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80e817:	eb 82                	jmp    80e79b <vprintfmt+0x54>
  80e819:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e81c:	85 c0                	test   %eax,%eax
  80e81e:	ba 00 00 00 00       	mov    $0x0,%edx
  80e823:	0f 49 d0             	cmovns %eax,%edx
  80e826:	89 55 e0             	mov    %edx,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e829:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e82c:	e9 6a ff ff ff       	jmp    80e79b <vprintfmt+0x54>
  80e831:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80e834:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
			goto reswitch;
  80e83b:	e9 5b ff ff ff       	jmp    80e79b <vprintfmt+0x54>
  80e840:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e843:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e846:	eb bc                	jmp    80e804 <vprintfmt+0xbd>
			lflag++;
  80e848:	83 c1 01             	add    $0x1,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e84b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80e84e:	e9 48 ff ff ff       	jmp    80e79b <vprintfmt+0x54>
			putch(va_arg(ap, int), putdat);
  80e853:	8b 45 14             	mov    0x14(%ebp),%eax
  80e856:	8d 78 04             	lea    0x4(%eax),%edi
  80e859:	83 ec 08             	sub    $0x8,%esp
  80e85c:	53                   	push   %ebx
  80e85d:	ff 30                	pushl  (%eax)
  80e85f:	ff d6                	call   *%esi
			break;
  80e861:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80e864:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80e867:	e9 9c 02 00 00       	jmp    80eb08 <vprintfmt+0x3c1>
			err = va_arg(ap, int);
  80e86c:	8b 45 14             	mov    0x14(%ebp),%eax
  80e86f:	8d 78 04             	lea    0x4(%eax),%edi
  80e872:	8b 00                	mov    (%eax),%eax
  80e874:	99                   	cltd   
  80e875:	31 d0                	xor    %edx,%eax
  80e877:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e879:	83 f8 0f             	cmp    $0xf,%eax
  80e87c:	7f 23                	jg     80e8a1 <vprintfmt+0x15a>
  80e87e:	8b 14 85 80 36 81 00 	mov    0x813680(,%eax,4),%edx
  80e885:	85 d2                	test   %edx,%edx
  80e887:	74 18                	je     80e8a1 <vprintfmt+0x15a>
				printfmt(putch, putdat, "%s", p);
  80e889:	52                   	push   %edx
  80e88a:	68 bd 25 81 00       	push   $0x8125bd
  80e88f:	53                   	push   %ebx
  80e890:	56                   	push   %esi
  80e891:	e8 94 fe ff ff       	call   80e72a <printfmt>
  80e896:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e899:	89 7d 14             	mov    %edi,0x14(%ebp)
  80e89c:	e9 67 02 00 00       	jmp    80eb08 <vprintfmt+0x3c1>
				printfmt(putch, putdat, "error %d", err);
  80e8a1:	50                   	push   %eax
  80e8a2:	68 ef 33 81 00       	push   $0x8133ef
  80e8a7:	53                   	push   %ebx
  80e8a8:	56                   	push   %esi
  80e8a9:	e8 7c fe ff ff       	call   80e72a <printfmt>
  80e8ae:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e8b1:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80e8b4:	e9 4f 02 00 00       	jmp    80eb08 <vprintfmt+0x3c1>
			if ((p = va_arg(ap, char *)) == NULL)
  80e8b9:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8bc:	83 c0 04             	add    $0x4,%eax
  80e8bf:	89 45 c8             	mov    %eax,-0x38(%ebp)
  80e8c2:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8c5:	8b 10                	mov    (%eax),%edx
				p = "(null)";
  80e8c7:	85 d2                	test   %edx,%edx
  80e8c9:	b8 e8 33 81 00       	mov    $0x8133e8,%eax
  80e8ce:	0f 45 c2             	cmovne %edx,%eax
  80e8d1:	89 45 cc             	mov    %eax,-0x34(%ebp)
			if (width > 0 && padc != '-')
  80e8d4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e8d8:	7e 06                	jle    80e8e0 <vprintfmt+0x199>
  80e8da:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%ebp)
  80e8de:	75 0d                	jne    80e8ed <vprintfmt+0x1a6>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e8e0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80e8e3:	89 c7                	mov    %eax,%edi
  80e8e5:	03 45 e0             	add    -0x20(%ebp),%eax
  80e8e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e8eb:	eb 3f                	jmp    80e92c <vprintfmt+0x1e5>
  80e8ed:	83 ec 08             	sub    $0x8,%esp
  80e8f0:	ff 75 d8             	pushl  -0x28(%ebp)
  80e8f3:	50                   	push   %eax
  80e8f4:	e8 0d 03 00 00       	call   80ec06 <strnlen>
  80e8f9:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e8fc:	29 c2                	sub    %eax,%edx
  80e8fe:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80e901:	83 c4 10             	add    $0x10,%esp
  80e904:	89 d7                	mov    %edx,%edi
					putch(padc, putdat);
  80e906:	0f be 45 d3          	movsbl -0x2d(%ebp),%eax
  80e90a:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80e90d:	85 ff                	test   %edi,%edi
  80e90f:	7e 58                	jle    80e969 <vprintfmt+0x222>
					putch(padc, putdat);
  80e911:	83 ec 08             	sub    $0x8,%esp
  80e914:	53                   	push   %ebx
  80e915:	ff 75 e0             	pushl  -0x20(%ebp)
  80e918:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80e91a:	83 ef 01             	sub    $0x1,%edi
  80e91d:	83 c4 10             	add    $0x10,%esp
  80e920:	eb eb                	jmp    80e90d <vprintfmt+0x1c6>
					putch(ch, putdat);
  80e922:	83 ec 08             	sub    $0x8,%esp
  80e925:	53                   	push   %ebx
  80e926:	52                   	push   %edx
  80e927:	ff d6                	call   *%esi
  80e929:	83 c4 10             	add    $0x10,%esp
  80e92c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e92f:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80e931:	83 c7 01             	add    $0x1,%edi
  80e934:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e938:	0f be d0             	movsbl %al,%edx
  80e93b:	85 d2                	test   %edx,%edx
  80e93d:	74 45                	je     80e984 <vprintfmt+0x23d>
  80e93f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80e943:	78 06                	js     80e94b <vprintfmt+0x204>
  80e945:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80e949:	78 35                	js     80e980 <vprintfmt+0x239>
				if (altflag && (ch < ' ' || ch > '~'))
  80e94b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80e94f:	74 d1                	je     80e922 <vprintfmt+0x1db>
  80e951:	0f be c0             	movsbl %al,%eax
  80e954:	83 e8 20             	sub    $0x20,%eax
  80e957:	83 f8 5e             	cmp    $0x5e,%eax
  80e95a:	76 c6                	jbe    80e922 <vprintfmt+0x1db>
					putch('?', putdat);
  80e95c:	83 ec 08             	sub    $0x8,%esp
  80e95f:	53                   	push   %ebx
  80e960:	6a 3f                	push   $0x3f
  80e962:	ff d6                	call   *%esi
  80e964:	83 c4 10             	add    $0x10,%esp
  80e967:	eb c3                	jmp    80e92c <vprintfmt+0x1e5>
  80e969:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  80e96c:	85 d2                	test   %edx,%edx
  80e96e:	b8 00 00 00 00       	mov    $0x0,%eax
  80e973:	0f 49 c2             	cmovns %edx,%eax
  80e976:	29 c2                	sub    %eax,%edx
  80e978:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80e97b:	e9 60 ff ff ff       	jmp    80e8e0 <vprintfmt+0x199>
  80e980:	89 cf                	mov    %ecx,%edi
  80e982:	eb 02                	jmp    80e986 <vprintfmt+0x23f>
  80e984:	89 cf                	mov    %ecx,%edi
			for (; width > 0; width--)
  80e986:	85 ff                	test   %edi,%edi
  80e988:	7e 10                	jle    80e99a <vprintfmt+0x253>
				putch(' ', putdat);
  80e98a:	83 ec 08             	sub    $0x8,%esp
  80e98d:	53                   	push   %ebx
  80e98e:	6a 20                	push   $0x20
  80e990:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80e992:	83 ef 01             	sub    $0x1,%edi
  80e995:	83 c4 10             	add    $0x10,%esp
  80e998:	eb ec                	jmp    80e986 <vprintfmt+0x23f>
			if ((p = va_arg(ap, char *)) == NULL)
  80e99a:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80e99d:	89 45 14             	mov    %eax,0x14(%ebp)
  80e9a0:	e9 63 01 00 00       	jmp    80eb08 <vprintfmt+0x3c1>
	if (lflag >= 2)
  80e9a5:	83 f9 01             	cmp    $0x1,%ecx
  80e9a8:	7f 1b                	jg     80e9c5 <vprintfmt+0x27e>
	else if (lflag)
  80e9aa:	85 c9                	test   %ecx,%ecx
  80e9ac:	74 63                	je     80ea11 <vprintfmt+0x2ca>
		return va_arg(*ap, long);
  80e9ae:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9b1:	8b 00                	mov    (%eax),%eax
  80e9b3:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e9b6:	99                   	cltd   
  80e9b7:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e9ba:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9bd:	8d 40 04             	lea    0x4(%eax),%eax
  80e9c0:	89 45 14             	mov    %eax,0x14(%ebp)
  80e9c3:	eb 17                	jmp    80e9dc <vprintfmt+0x295>
		return va_arg(*ap, long long);
  80e9c5:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9c8:	8b 50 04             	mov    0x4(%eax),%edx
  80e9cb:	8b 00                	mov    (%eax),%eax
  80e9cd:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e9d0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e9d3:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9d6:	8d 40 08             	lea    0x8(%eax),%eax
  80e9d9:	89 45 14             	mov    %eax,0x14(%ebp)
			if ((long long) num < 0) {
  80e9dc:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e9df:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			base = 10;
  80e9e2:	b8 0a 00 00 00       	mov    $0xa,%eax
			if ((long long) num < 0) {
  80e9e7:	85 c9                	test   %ecx,%ecx
  80e9e9:	0f 89 ff 00 00 00    	jns    80eaee <vprintfmt+0x3a7>
				putch('-', putdat);
  80e9ef:	83 ec 08             	sub    $0x8,%esp
  80e9f2:	53                   	push   %ebx
  80e9f3:	6a 2d                	push   $0x2d
  80e9f5:	ff d6                	call   *%esi
				num = -(long long) num;
  80e9f7:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e9fa:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80e9fd:	f7 da                	neg    %edx
  80e9ff:	83 d1 00             	adc    $0x0,%ecx
  80ea02:	f7 d9                	neg    %ecx
  80ea04:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ea07:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ea0c:	e9 dd 00 00 00       	jmp    80eaee <vprintfmt+0x3a7>
		return va_arg(*ap, int);
  80ea11:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea14:	8b 00                	mov    (%eax),%eax
  80ea16:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ea19:	99                   	cltd   
  80ea1a:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ea1d:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea20:	8d 40 04             	lea    0x4(%eax),%eax
  80ea23:	89 45 14             	mov    %eax,0x14(%ebp)
  80ea26:	eb b4                	jmp    80e9dc <vprintfmt+0x295>
	if (lflag >= 2)
  80ea28:	83 f9 01             	cmp    $0x1,%ecx
  80ea2b:	7f 1e                	jg     80ea4b <vprintfmt+0x304>
	else if (lflag)
  80ea2d:	85 c9                	test   %ecx,%ecx
  80ea2f:	74 32                	je     80ea63 <vprintfmt+0x31c>
		return va_arg(*ap, unsigned long);
  80ea31:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea34:	8b 10                	mov    (%eax),%edx
  80ea36:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ea3b:	8d 40 04             	lea    0x4(%eax),%eax
  80ea3e:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ea41:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ea46:	e9 a3 00 00 00       	jmp    80eaee <vprintfmt+0x3a7>
		return va_arg(*ap, unsigned long long);
  80ea4b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea4e:	8b 10                	mov    (%eax),%edx
  80ea50:	8b 48 04             	mov    0x4(%eax),%ecx
  80ea53:	8d 40 08             	lea    0x8(%eax),%eax
  80ea56:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ea59:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ea5e:	e9 8b 00 00 00       	jmp    80eaee <vprintfmt+0x3a7>
		return va_arg(*ap, unsigned int);
  80ea63:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea66:	8b 10                	mov    (%eax),%edx
  80ea68:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ea6d:	8d 40 04             	lea    0x4(%eax),%eax
  80ea70:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ea73:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ea78:	eb 74                	jmp    80eaee <vprintfmt+0x3a7>
	if (lflag >= 2)
  80ea7a:	83 f9 01             	cmp    $0x1,%ecx
  80ea7d:	7f 1b                	jg     80ea9a <vprintfmt+0x353>
	else if (lflag)
  80ea7f:	85 c9                	test   %ecx,%ecx
  80ea81:	74 2c                	je     80eaaf <vprintfmt+0x368>
		return va_arg(*ap, unsigned long);
  80ea83:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea86:	8b 10                	mov    (%eax),%edx
  80ea88:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ea8d:	8d 40 04             	lea    0x4(%eax),%eax
  80ea90:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ea93:	b8 08 00 00 00       	mov    $0x8,%eax
  80ea98:	eb 54                	jmp    80eaee <vprintfmt+0x3a7>
		return va_arg(*ap, unsigned long long);
  80ea9a:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea9d:	8b 10                	mov    (%eax),%edx
  80ea9f:	8b 48 04             	mov    0x4(%eax),%ecx
  80eaa2:	8d 40 08             	lea    0x8(%eax),%eax
  80eaa5:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80eaa8:	b8 08 00 00 00       	mov    $0x8,%eax
  80eaad:	eb 3f                	jmp    80eaee <vprintfmt+0x3a7>
		return va_arg(*ap, unsigned int);
  80eaaf:	8b 45 14             	mov    0x14(%ebp),%eax
  80eab2:	8b 10                	mov    (%eax),%edx
  80eab4:	b9 00 00 00 00       	mov    $0x0,%ecx
  80eab9:	8d 40 04             	lea    0x4(%eax),%eax
  80eabc:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80eabf:	b8 08 00 00 00       	mov    $0x8,%eax
  80eac4:	eb 28                	jmp    80eaee <vprintfmt+0x3a7>
			putch('0', putdat);
  80eac6:	83 ec 08             	sub    $0x8,%esp
  80eac9:	53                   	push   %ebx
  80eaca:	6a 30                	push   $0x30
  80eacc:	ff d6                	call   *%esi
			putch('x', putdat);
  80eace:	83 c4 08             	add    $0x8,%esp
  80ead1:	53                   	push   %ebx
  80ead2:	6a 78                	push   $0x78
  80ead4:	ff d6                	call   *%esi
			num = (unsigned long long)
  80ead6:	8b 45 14             	mov    0x14(%ebp),%eax
  80ead9:	8b 10                	mov    (%eax),%edx
  80eadb:	b9 00 00 00 00       	mov    $0x0,%ecx
			goto number;
  80eae0:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80eae3:	8d 40 04             	lea    0x4(%eax),%eax
  80eae6:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eae9:	b8 10 00 00 00       	mov    $0x10,%eax
			printnum(putch, putdat, num, base, width, padc);
  80eaee:	83 ec 0c             	sub    $0xc,%esp
  80eaf1:	0f be 7d d3          	movsbl -0x2d(%ebp),%edi
  80eaf5:	57                   	push   %edi
  80eaf6:	ff 75 e0             	pushl  -0x20(%ebp)
  80eaf9:	50                   	push   %eax
  80eafa:	51                   	push   %ecx
  80eafb:	52                   	push   %edx
  80eafc:	89 da                	mov    %ebx,%edx
  80eafe:	89 f0                	mov    %esi,%eax
  80eb00:	e8 5a fb ff ff       	call   80e65f <printnum>
			break;
  80eb05:	83 c4 20             	add    $0x20,%esp
			if ((p = va_arg(ap, char *)) == NULL)
  80eb08:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80eb0b:	e9 55 fc ff ff       	jmp    80e765 <vprintfmt+0x1e>
	if (lflag >= 2)
  80eb10:	83 f9 01             	cmp    $0x1,%ecx
  80eb13:	7f 1b                	jg     80eb30 <vprintfmt+0x3e9>
	else if (lflag)
  80eb15:	85 c9                	test   %ecx,%ecx
  80eb17:	74 2c                	je     80eb45 <vprintfmt+0x3fe>
		return va_arg(*ap, unsigned long);
  80eb19:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb1c:	8b 10                	mov    (%eax),%edx
  80eb1e:	b9 00 00 00 00       	mov    $0x0,%ecx
  80eb23:	8d 40 04             	lea    0x4(%eax),%eax
  80eb26:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eb29:	b8 10 00 00 00       	mov    $0x10,%eax
  80eb2e:	eb be                	jmp    80eaee <vprintfmt+0x3a7>
		return va_arg(*ap, unsigned long long);
  80eb30:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb33:	8b 10                	mov    (%eax),%edx
  80eb35:	8b 48 04             	mov    0x4(%eax),%ecx
  80eb38:	8d 40 08             	lea    0x8(%eax),%eax
  80eb3b:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eb3e:	b8 10 00 00 00       	mov    $0x10,%eax
  80eb43:	eb a9                	jmp    80eaee <vprintfmt+0x3a7>
		return va_arg(*ap, unsigned int);
  80eb45:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb48:	8b 10                	mov    (%eax),%edx
  80eb4a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80eb4f:	8d 40 04             	lea    0x4(%eax),%eax
  80eb52:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eb55:	b8 10 00 00 00       	mov    $0x10,%eax
  80eb5a:	eb 92                	jmp    80eaee <vprintfmt+0x3a7>
			putch(ch, putdat);
  80eb5c:	83 ec 08             	sub    $0x8,%esp
  80eb5f:	53                   	push   %ebx
  80eb60:	6a 25                	push   $0x25
  80eb62:	ff d6                	call   *%esi
			break;
  80eb64:	83 c4 10             	add    $0x10,%esp
  80eb67:	eb 9f                	jmp    80eb08 <vprintfmt+0x3c1>
			putch('%', putdat);
  80eb69:	83 ec 08             	sub    $0x8,%esp
  80eb6c:	53                   	push   %ebx
  80eb6d:	6a 25                	push   $0x25
  80eb6f:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80eb71:	83 c4 10             	add    $0x10,%esp
  80eb74:	89 f8                	mov    %edi,%eax
  80eb76:	eb 03                	jmp    80eb7b <vprintfmt+0x434>
  80eb78:	83 e8 01             	sub    $0x1,%eax
  80eb7b:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80eb7f:	75 f7                	jne    80eb78 <vprintfmt+0x431>
  80eb81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80eb84:	eb 82                	jmp    80eb08 <vprintfmt+0x3c1>

0080eb86 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80eb86:	55                   	push   %ebp
  80eb87:	89 e5                	mov    %esp,%ebp
  80eb89:	83 ec 18             	sub    $0x18,%esp
  80eb8c:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb8f:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80eb92:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80eb95:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80eb99:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80eb9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80eba3:	85 c0                	test   %eax,%eax
  80eba5:	74 26                	je     80ebcd <vsnprintf+0x47>
  80eba7:	85 d2                	test   %edx,%edx
  80eba9:	7e 22                	jle    80ebcd <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80ebab:	ff 75 14             	pushl  0x14(%ebp)
  80ebae:	ff 75 10             	pushl  0x10(%ebp)
  80ebb1:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80ebb4:	50                   	push   %eax
  80ebb5:	68 0d e7 80 00       	push   $0x80e70d
  80ebba:	e8 88 fb ff ff       	call   80e747 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80ebbf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80ebc2:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80ebc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ebc8:	83 c4 10             	add    $0x10,%esp
}
  80ebcb:	c9                   	leave  
  80ebcc:	c3                   	ret    
		return -E_INVAL;
  80ebcd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80ebd2:	eb f7                	jmp    80ebcb <vsnprintf+0x45>

0080ebd4 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80ebd4:	55                   	push   %ebp
  80ebd5:	89 e5                	mov    %esp,%ebp
  80ebd7:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80ebda:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80ebdd:	50                   	push   %eax
  80ebde:	ff 75 10             	pushl  0x10(%ebp)
  80ebe1:	ff 75 0c             	pushl  0xc(%ebp)
  80ebe4:	ff 75 08             	pushl  0x8(%ebp)
  80ebe7:	e8 9a ff ff ff       	call   80eb86 <vsnprintf>
	va_end(ap);

	return rc;
}
  80ebec:	c9                   	leave  
  80ebed:	c3                   	ret    

0080ebee <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80ebee:	55                   	push   %ebp
  80ebef:	89 e5                	mov    %esp,%ebp
  80ebf1:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80ebf4:	b8 00 00 00 00       	mov    $0x0,%eax
  80ebf9:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80ebfd:	74 05                	je     80ec04 <strlen+0x16>
		n++;
  80ebff:	83 c0 01             	add    $0x1,%eax
  80ec02:	eb f5                	jmp    80ebf9 <strlen+0xb>
	return n;
}
  80ec04:	5d                   	pop    %ebp
  80ec05:	c3                   	ret    

0080ec06 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80ec06:	55                   	push   %ebp
  80ec07:	89 e5                	mov    %esp,%ebp
  80ec09:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ec0c:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ec0f:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec14:	39 c2                	cmp    %eax,%edx
  80ec16:	74 0d                	je     80ec25 <strnlen+0x1f>
  80ec18:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80ec1c:	74 05                	je     80ec23 <strnlen+0x1d>
		n++;
  80ec1e:	83 c2 01             	add    $0x1,%edx
  80ec21:	eb f1                	jmp    80ec14 <strnlen+0xe>
  80ec23:	89 d0                	mov    %edx,%eax
	return n;
}
  80ec25:	5d                   	pop    %ebp
  80ec26:	c3                   	ret    

0080ec27 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80ec27:	55                   	push   %ebp
  80ec28:	89 e5                	mov    %esp,%ebp
  80ec2a:	53                   	push   %ebx
  80ec2b:	8b 45 08             	mov    0x8(%ebp),%eax
  80ec2e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80ec31:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec36:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80ec3a:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  80ec3d:	83 c2 01             	add    $0x1,%edx
  80ec40:	84 c9                	test   %cl,%cl
  80ec42:	75 f2                	jne    80ec36 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80ec44:	5b                   	pop    %ebx
  80ec45:	5d                   	pop    %ebp
  80ec46:	c3                   	ret    

0080ec47 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80ec47:	55                   	push   %ebp
  80ec48:	89 e5                	mov    %esp,%ebp
  80ec4a:	53                   	push   %ebx
  80ec4b:	83 ec 10             	sub    $0x10,%esp
  80ec4e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80ec51:	53                   	push   %ebx
  80ec52:	e8 97 ff ff ff       	call   80ebee <strlen>
  80ec57:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80ec5a:	ff 75 0c             	pushl  0xc(%ebp)
  80ec5d:	01 d8                	add    %ebx,%eax
  80ec5f:	50                   	push   %eax
  80ec60:	e8 c2 ff ff ff       	call   80ec27 <strcpy>
	return dst;
}
  80ec65:	89 d8                	mov    %ebx,%eax
  80ec67:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ec6a:	c9                   	leave  
  80ec6b:	c3                   	ret    

0080ec6c <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80ec6c:	55                   	push   %ebp
  80ec6d:	89 e5                	mov    %esp,%ebp
  80ec6f:	56                   	push   %esi
  80ec70:	53                   	push   %ebx
  80ec71:	8b 45 08             	mov    0x8(%ebp),%eax
  80ec74:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ec77:	89 c6                	mov    %eax,%esi
  80ec79:	03 75 10             	add    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ec7c:	89 c2                	mov    %eax,%edx
  80ec7e:	39 f2                	cmp    %esi,%edx
  80ec80:	74 11                	je     80ec93 <strncpy+0x27>
		*dst++ = *src;
  80ec82:	83 c2 01             	add    $0x1,%edx
  80ec85:	0f b6 19             	movzbl (%ecx),%ebx
  80ec88:	88 5a ff             	mov    %bl,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80ec8b:	80 fb 01             	cmp    $0x1,%bl
  80ec8e:	83 d9 ff             	sbb    $0xffffffff,%ecx
  80ec91:	eb eb                	jmp    80ec7e <strncpy+0x12>
	}
	return ret;
}
  80ec93:	5b                   	pop    %ebx
  80ec94:	5e                   	pop    %esi
  80ec95:	5d                   	pop    %ebp
  80ec96:	c3                   	ret    

0080ec97 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80ec97:	55                   	push   %ebp
  80ec98:	89 e5                	mov    %esp,%ebp
  80ec9a:	56                   	push   %esi
  80ec9b:	53                   	push   %ebx
  80ec9c:	8b 75 08             	mov    0x8(%ebp),%esi
  80ec9f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eca2:	8b 55 10             	mov    0x10(%ebp),%edx
  80eca5:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80eca7:	85 d2                	test   %edx,%edx
  80eca9:	74 21                	je     80eccc <strlcpy+0x35>
  80ecab:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80ecaf:	89 f2                	mov    %esi,%edx
		while (--size > 0 && *src != '\0')
  80ecb1:	39 c2                	cmp    %eax,%edx
  80ecb3:	74 14                	je     80ecc9 <strlcpy+0x32>
  80ecb5:	0f b6 19             	movzbl (%ecx),%ebx
  80ecb8:	84 db                	test   %bl,%bl
  80ecba:	74 0b                	je     80ecc7 <strlcpy+0x30>
			*dst++ = *src++;
  80ecbc:	83 c1 01             	add    $0x1,%ecx
  80ecbf:	83 c2 01             	add    $0x1,%edx
  80ecc2:	88 5a ff             	mov    %bl,-0x1(%edx)
  80ecc5:	eb ea                	jmp    80ecb1 <strlcpy+0x1a>
  80ecc7:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80ecc9:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80eccc:	29 f0                	sub    %esi,%eax
}
  80ecce:	5b                   	pop    %ebx
  80eccf:	5e                   	pop    %esi
  80ecd0:	5d                   	pop    %ebp
  80ecd1:	c3                   	ret    

0080ecd2 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80ecd2:	55                   	push   %ebp
  80ecd3:	89 e5                	mov    %esp,%ebp
  80ecd5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ecd8:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80ecdb:	0f b6 01             	movzbl (%ecx),%eax
  80ecde:	84 c0                	test   %al,%al
  80ece0:	74 0c                	je     80ecee <strcmp+0x1c>
  80ece2:	3a 02                	cmp    (%edx),%al
  80ece4:	75 08                	jne    80ecee <strcmp+0x1c>
		p++, q++;
  80ece6:	83 c1 01             	add    $0x1,%ecx
  80ece9:	83 c2 01             	add    $0x1,%edx
  80ecec:	eb ed                	jmp    80ecdb <strcmp+0x9>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80ecee:	0f b6 c0             	movzbl %al,%eax
  80ecf1:	0f b6 12             	movzbl (%edx),%edx
  80ecf4:	29 d0                	sub    %edx,%eax
}
  80ecf6:	5d                   	pop    %ebp
  80ecf7:	c3                   	ret    

0080ecf8 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80ecf8:	55                   	push   %ebp
  80ecf9:	89 e5                	mov    %esp,%ebp
  80ecfb:	53                   	push   %ebx
  80ecfc:	8b 45 08             	mov    0x8(%ebp),%eax
  80ecff:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ed02:	89 c3                	mov    %eax,%ebx
  80ed04:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80ed07:	eb 06                	jmp    80ed0f <strncmp+0x17>
		n--, p++, q++;
  80ed09:	83 c0 01             	add    $0x1,%eax
  80ed0c:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80ed0f:	39 d8                	cmp    %ebx,%eax
  80ed11:	74 16                	je     80ed29 <strncmp+0x31>
  80ed13:	0f b6 08             	movzbl (%eax),%ecx
  80ed16:	84 c9                	test   %cl,%cl
  80ed18:	74 04                	je     80ed1e <strncmp+0x26>
  80ed1a:	3a 0a                	cmp    (%edx),%cl
  80ed1c:	74 eb                	je     80ed09 <strncmp+0x11>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80ed1e:	0f b6 00             	movzbl (%eax),%eax
  80ed21:	0f b6 12             	movzbl (%edx),%edx
  80ed24:	29 d0                	sub    %edx,%eax
}
  80ed26:	5b                   	pop    %ebx
  80ed27:	5d                   	pop    %ebp
  80ed28:	c3                   	ret    
		return 0;
  80ed29:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed2e:	eb f6                	jmp    80ed26 <strncmp+0x2e>

0080ed30 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80ed30:	55                   	push   %ebp
  80ed31:	89 e5                	mov    %esp,%ebp
  80ed33:	8b 45 08             	mov    0x8(%ebp),%eax
  80ed36:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ed3a:	0f b6 10             	movzbl (%eax),%edx
  80ed3d:	84 d2                	test   %dl,%dl
  80ed3f:	74 09                	je     80ed4a <strchr+0x1a>
		if (*s == c)
  80ed41:	38 ca                	cmp    %cl,%dl
  80ed43:	74 0a                	je     80ed4f <strchr+0x1f>
	for (; *s; s++)
  80ed45:	83 c0 01             	add    $0x1,%eax
  80ed48:	eb f0                	jmp    80ed3a <strchr+0xa>
			return (char *) s;
	return 0;
  80ed4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ed4f:	5d                   	pop    %ebp
  80ed50:	c3                   	ret    

0080ed51 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80ed51:	55                   	push   %ebp
  80ed52:	89 e5                	mov    %esp,%ebp
  80ed54:	8b 45 08             	mov    0x8(%ebp),%eax
  80ed57:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ed5b:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80ed5e:	38 ca                	cmp    %cl,%dl
  80ed60:	74 09                	je     80ed6b <strfind+0x1a>
  80ed62:	84 d2                	test   %dl,%dl
  80ed64:	74 05                	je     80ed6b <strfind+0x1a>
	for (; *s; s++)
  80ed66:	83 c0 01             	add    $0x1,%eax
  80ed69:	eb f0                	jmp    80ed5b <strfind+0xa>
			break;
	return (char *) s;
}
  80ed6b:	5d                   	pop    %ebp
  80ed6c:	c3                   	ret    

0080ed6d <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80ed6d:	55                   	push   %ebp
  80ed6e:	89 e5                	mov    %esp,%ebp
  80ed70:	57                   	push   %edi
  80ed71:	56                   	push   %esi
  80ed72:	53                   	push   %ebx
  80ed73:	8b 7d 08             	mov    0x8(%ebp),%edi
  80ed76:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80ed79:	85 c9                	test   %ecx,%ecx
  80ed7b:	74 31                	je     80edae <memset+0x41>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80ed7d:	89 f8                	mov    %edi,%eax
  80ed7f:	09 c8                	or     %ecx,%eax
  80ed81:	a8 03                	test   $0x3,%al
  80ed83:	75 23                	jne    80eda8 <memset+0x3b>
		c &= 0xFF;
  80ed85:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80ed89:	89 d3                	mov    %edx,%ebx
  80ed8b:	c1 e3 08             	shl    $0x8,%ebx
  80ed8e:	89 d0                	mov    %edx,%eax
  80ed90:	c1 e0 18             	shl    $0x18,%eax
  80ed93:	89 d6                	mov    %edx,%esi
  80ed95:	c1 e6 10             	shl    $0x10,%esi
  80ed98:	09 f0                	or     %esi,%eax
  80ed9a:	09 c2                	or     %eax,%edx
  80ed9c:	09 da                	or     %ebx,%edx
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80ed9e:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80eda1:	89 d0                	mov    %edx,%eax
  80eda3:	fc                   	cld    
  80eda4:	f3 ab                	rep stos %eax,%es:(%edi)
  80eda6:	eb 06                	jmp    80edae <memset+0x41>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80eda8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80edab:	fc                   	cld    
  80edac:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80edae:	89 f8                	mov    %edi,%eax
  80edb0:	5b                   	pop    %ebx
  80edb1:	5e                   	pop    %esi
  80edb2:	5f                   	pop    %edi
  80edb3:	5d                   	pop    %ebp
  80edb4:	c3                   	ret    

0080edb5 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80edb5:	55                   	push   %ebp
  80edb6:	89 e5                	mov    %esp,%ebp
  80edb8:	57                   	push   %edi
  80edb9:	56                   	push   %esi
  80edba:	8b 45 08             	mov    0x8(%ebp),%eax
  80edbd:	8b 75 0c             	mov    0xc(%ebp),%esi
  80edc0:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80edc3:	39 c6                	cmp    %eax,%esi
  80edc5:	73 32                	jae    80edf9 <memmove+0x44>
  80edc7:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80edca:	39 c2                	cmp    %eax,%edx
  80edcc:	76 2b                	jbe    80edf9 <memmove+0x44>
		s += n;
		d += n;
  80edce:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80edd1:	89 fe                	mov    %edi,%esi
  80edd3:	09 ce                	or     %ecx,%esi
  80edd5:	09 d6                	or     %edx,%esi
  80edd7:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80eddd:	75 0e                	jne    80eded <memmove+0x38>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80eddf:	83 ef 04             	sub    $0x4,%edi
  80ede2:	8d 72 fc             	lea    -0x4(%edx),%esi
  80ede5:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80ede8:	fd                   	std    
  80ede9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80edeb:	eb 09                	jmp    80edf6 <memmove+0x41>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80eded:	83 ef 01             	sub    $0x1,%edi
  80edf0:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80edf3:	fd                   	std    
  80edf4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80edf6:	fc                   	cld    
  80edf7:	eb 1a                	jmp    80ee13 <memmove+0x5e>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80edf9:	89 c2                	mov    %eax,%edx
  80edfb:	09 ca                	or     %ecx,%edx
  80edfd:	09 f2                	or     %esi,%edx
  80edff:	f6 c2 03             	test   $0x3,%dl
  80ee02:	75 0a                	jne    80ee0e <memmove+0x59>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80ee04:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80ee07:	89 c7                	mov    %eax,%edi
  80ee09:	fc                   	cld    
  80ee0a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ee0c:	eb 05                	jmp    80ee13 <memmove+0x5e>
		else
			asm volatile("cld; rep movsb\n"
  80ee0e:	89 c7                	mov    %eax,%edi
  80ee10:	fc                   	cld    
  80ee11:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80ee13:	5e                   	pop    %esi
  80ee14:	5f                   	pop    %edi
  80ee15:	5d                   	pop    %ebp
  80ee16:	c3                   	ret    

0080ee17 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80ee17:	55                   	push   %ebp
  80ee18:	89 e5                	mov    %esp,%ebp
  80ee1a:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80ee1d:	ff 75 10             	pushl  0x10(%ebp)
  80ee20:	ff 75 0c             	pushl  0xc(%ebp)
  80ee23:	ff 75 08             	pushl  0x8(%ebp)
  80ee26:	e8 8a ff ff ff       	call   80edb5 <memmove>
}
  80ee2b:	c9                   	leave  
  80ee2c:	c3                   	ret    

0080ee2d <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80ee2d:	55                   	push   %ebp
  80ee2e:	89 e5                	mov    %esp,%ebp
  80ee30:	56                   	push   %esi
  80ee31:	53                   	push   %ebx
  80ee32:	8b 45 08             	mov    0x8(%ebp),%eax
  80ee35:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ee38:	89 c6                	mov    %eax,%esi
  80ee3a:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ee3d:	39 f0                	cmp    %esi,%eax
  80ee3f:	74 1c                	je     80ee5d <memcmp+0x30>
		if (*s1 != *s2)
  80ee41:	0f b6 08             	movzbl (%eax),%ecx
  80ee44:	0f b6 1a             	movzbl (%edx),%ebx
  80ee47:	38 d9                	cmp    %bl,%cl
  80ee49:	75 08                	jne    80ee53 <memcmp+0x26>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80ee4b:	83 c0 01             	add    $0x1,%eax
  80ee4e:	83 c2 01             	add    $0x1,%edx
  80ee51:	eb ea                	jmp    80ee3d <memcmp+0x10>
			return (int) *s1 - (int) *s2;
  80ee53:	0f b6 c1             	movzbl %cl,%eax
  80ee56:	0f b6 db             	movzbl %bl,%ebx
  80ee59:	29 d8                	sub    %ebx,%eax
  80ee5b:	eb 05                	jmp    80ee62 <memcmp+0x35>
	}

	return 0;
  80ee5d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ee62:	5b                   	pop    %ebx
  80ee63:	5e                   	pop    %esi
  80ee64:	5d                   	pop    %ebp
  80ee65:	c3                   	ret    

0080ee66 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80ee66:	55                   	push   %ebp
  80ee67:	89 e5                	mov    %esp,%ebp
  80ee69:	8b 45 08             	mov    0x8(%ebp),%eax
  80ee6c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80ee6f:	89 c2                	mov    %eax,%edx
  80ee71:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80ee74:	39 d0                	cmp    %edx,%eax
  80ee76:	73 09                	jae    80ee81 <memfind+0x1b>
		if (*(const unsigned char *) s == (unsigned char) c)
  80ee78:	38 08                	cmp    %cl,(%eax)
  80ee7a:	74 05                	je     80ee81 <memfind+0x1b>
	for (; s < ends; s++)
  80ee7c:	83 c0 01             	add    $0x1,%eax
  80ee7f:	eb f3                	jmp    80ee74 <memfind+0xe>
			break;
	return (void *) s;
}
  80ee81:	5d                   	pop    %ebp
  80ee82:	c3                   	ret    

0080ee83 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80ee83:	55                   	push   %ebp
  80ee84:	89 e5                	mov    %esp,%ebp
  80ee86:	57                   	push   %edi
  80ee87:	56                   	push   %esi
  80ee88:	53                   	push   %ebx
  80ee89:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ee8c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ee8f:	eb 03                	jmp    80ee94 <strtol+0x11>
		s++;
  80ee91:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80ee94:	0f b6 01             	movzbl (%ecx),%eax
  80ee97:	3c 20                	cmp    $0x20,%al
  80ee99:	74 f6                	je     80ee91 <strtol+0xe>
  80ee9b:	3c 09                	cmp    $0x9,%al
  80ee9d:	74 f2                	je     80ee91 <strtol+0xe>

	// plus/minus sign
	if (*s == '+')
  80ee9f:	3c 2b                	cmp    $0x2b,%al
  80eea1:	74 2a                	je     80eecd <strtol+0x4a>
	int neg = 0;
  80eea3:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80eea8:	3c 2d                	cmp    $0x2d,%al
  80eeaa:	74 2b                	je     80eed7 <strtol+0x54>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80eeac:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80eeb2:	75 0f                	jne    80eec3 <strtol+0x40>
  80eeb4:	80 39 30             	cmpb   $0x30,(%ecx)
  80eeb7:	74 28                	je     80eee1 <strtol+0x5e>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80eeb9:	85 db                	test   %ebx,%ebx
  80eebb:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eec0:	0f 44 d8             	cmove  %eax,%ebx
  80eec3:	b8 00 00 00 00       	mov    $0x0,%eax
  80eec8:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80eecb:	eb 50                	jmp    80ef1d <strtol+0x9a>
		s++;
  80eecd:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80eed0:	bf 00 00 00 00       	mov    $0x0,%edi
  80eed5:	eb d5                	jmp    80eeac <strtol+0x29>
		s++, neg = 1;
  80eed7:	83 c1 01             	add    $0x1,%ecx
  80eeda:	bf 01 00 00 00       	mov    $0x1,%edi
  80eedf:	eb cb                	jmp    80eeac <strtol+0x29>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80eee1:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80eee5:	74 0e                	je     80eef5 <strtol+0x72>
	else if (base == 0 && s[0] == '0')
  80eee7:	85 db                	test   %ebx,%ebx
  80eee9:	75 d8                	jne    80eec3 <strtol+0x40>
		s++, base = 8;
  80eeeb:	83 c1 01             	add    $0x1,%ecx
  80eeee:	bb 08 00 00 00       	mov    $0x8,%ebx
  80eef3:	eb ce                	jmp    80eec3 <strtol+0x40>
		s += 2, base = 16;
  80eef5:	83 c1 02             	add    $0x2,%ecx
  80eef8:	bb 10 00 00 00       	mov    $0x10,%ebx
  80eefd:	eb c4                	jmp    80eec3 <strtol+0x40>
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
  80eeff:	8d 72 9f             	lea    -0x61(%edx),%esi
  80ef02:	89 f3                	mov    %esi,%ebx
  80ef04:	80 fb 19             	cmp    $0x19,%bl
  80ef07:	77 29                	ja     80ef32 <strtol+0xaf>
			dig = *s - 'a' + 10;
  80ef09:	0f be d2             	movsbl %dl,%edx
  80ef0c:	83 ea 57             	sub    $0x57,%edx
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80ef0f:	3b 55 10             	cmp    0x10(%ebp),%edx
  80ef12:	7d 30                	jge    80ef44 <strtol+0xc1>
			break;
		s++, val = (val * base) + dig;
  80ef14:	83 c1 01             	add    $0x1,%ecx
  80ef17:	0f af 45 10          	imul   0x10(%ebp),%eax
  80ef1b:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80ef1d:	0f b6 11             	movzbl (%ecx),%edx
  80ef20:	8d 72 d0             	lea    -0x30(%edx),%esi
  80ef23:	89 f3                	mov    %esi,%ebx
  80ef25:	80 fb 09             	cmp    $0x9,%bl
  80ef28:	77 d5                	ja     80eeff <strtol+0x7c>
			dig = *s - '0';
  80ef2a:	0f be d2             	movsbl %dl,%edx
  80ef2d:	83 ea 30             	sub    $0x30,%edx
  80ef30:	eb dd                	jmp    80ef0f <strtol+0x8c>
		else if (*s >= 'A' && *s <= 'Z')
  80ef32:	8d 72 bf             	lea    -0x41(%edx),%esi
  80ef35:	89 f3                	mov    %esi,%ebx
  80ef37:	80 fb 19             	cmp    $0x19,%bl
  80ef3a:	77 08                	ja     80ef44 <strtol+0xc1>
			dig = *s - 'A' + 10;
  80ef3c:	0f be d2             	movsbl %dl,%edx
  80ef3f:	83 ea 37             	sub    $0x37,%edx
  80ef42:	eb cb                	jmp    80ef0f <strtol+0x8c>
		// we don't properly detect overflow!
	}

	if (endptr)
  80ef44:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80ef48:	74 05                	je     80ef4f <strtol+0xcc>
		*endptr = (char *) s;
  80ef4a:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ef4d:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80ef4f:	89 c2                	mov    %eax,%edx
  80ef51:	f7 da                	neg    %edx
  80ef53:	85 ff                	test   %edi,%edi
  80ef55:	0f 45 c2             	cmovne %edx,%eax
}
  80ef58:	5b                   	pop    %ebx
  80ef59:	5e                   	pop    %esi
  80ef5a:	5f                   	pop    %edi
  80ef5b:	5d                   	pop    %ebp
  80ef5c:	c3                   	ret    

0080ef5d <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80ef5d:	55                   	push   %ebp
  80ef5e:	89 e5                	mov    %esp,%ebp
  80ef60:	57                   	push   %edi
  80ef61:	56                   	push   %esi
  80ef62:	53                   	push   %ebx
	asm volatile("int %1\n"
  80ef63:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef68:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef6b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef6e:	89 c3                	mov    %eax,%ebx
  80ef70:	89 c7                	mov    %eax,%edi
  80ef72:	89 c6                	mov    %eax,%esi
  80ef74:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80ef76:	5b                   	pop    %ebx
  80ef77:	5e                   	pop    %esi
  80ef78:	5f                   	pop    %edi
  80ef79:	5d                   	pop    %ebp
  80ef7a:	c3                   	ret    

0080ef7b <sys_cgetc>:

int
sys_cgetc(void)
{
  80ef7b:	55                   	push   %ebp
  80ef7c:	89 e5                	mov    %esp,%ebp
  80ef7e:	57                   	push   %edi
  80ef7f:	56                   	push   %esi
  80ef80:	53                   	push   %ebx
	asm volatile("int %1\n"
  80ef81:	ba 00 00 00 00       	mov    $0x0,%edx
  80ef86:	b8 01 00 00 00       	mov    $0x1,%eax
  80ef8b:	89 d1                	mov    %edx,%ecx
  80ef8d:	89 d3                	mov    %edx,%ebx
  80ef8f:	89 d7                	mov    %edx,%edi
  80ef91:	89 d6                	mov    %edx,%esi
  80ef93:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80ef95:	5b                   	pop    %ebx
  80ef96:	5e                   	pop    %esi
  80ef97:	5f                   	pop    %edi
  80ef98:	5d                   	pop    %ebp
  80ef99:	c3                   	ret    

0080ef9a <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80ef9a:	55                   	push   %ebp
  80ef9b:	89 e5                	mov    %esp,%ebp
  80ef9d:	57                   	push   %edi
  80ef9e:	56                   	push   %esi
  80ef9f:	53                   	push   %ebx
  80efa0:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80efa3:	b9 00 00 00 00       	mov    $0x0,%ecx
  80efa8:	8b 55 08             	mov    0x8(%ebp),%edx
  80efab:	b8 03 00 00 00       	mov    $0x3,%eax
  80efb0:	89 cb                	mov    %ecx,%ebx
  80efb2:	89 cf                	mov    %ecx,%edi
  80efb4:	89 ce                	mov    %ecx,%esi
  80efb6:	cd 30                	int    $0x30
	if(check && ret > 0)
  80efb8:	85 c0                	test   %eax,%eax
  80efba:	7f 08                	jg     80efc4 <sys_env_destroy+0x2a>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80efbc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80efbf:	5b                   	pop    %ebx
  80efc0:	5e                   	pop    %esi
  80efc1:	5f                   	pop    %edi
  80efc2:	5d                   	pop    %ebp
  80efc3:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80efc4:	83 ec 0c             	sub    $0xc,%esp
  80efc7:	50                   	push   %eax
  80efc8:	6a 03                	push   $0x3
  80efca:	68 df 36 81 00       	push   $0x8136df
  80efcf:	6a 23                	push   $0x23
  80efd1:	68 fc 36 81 00       	push   $0x8136fc
  80efd6:	e8 95 f5 ff ff       	call   80e570 <_panic>

0080efdb <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80efdb:	55                   	push   %ebp
  80efdc:	89 e5                	mov    %esp,%ebp
  80efde:	57                   	push   %edi
  80efdf:	56                   	push   %esi
  80efe0:	53                   	push   %ebx
	asm volatile("int %1\n"
  80efe1:	ba 00 00 00 00       	mov    $0x0,%edx
  80efe6:	b8 02 00 00 00       	mov    $0x2,%eax
  80efeb:	89 d1                	mov    %edx,%ecx
  80efed:	89 d3                	mov    %edx,%ebx
  80efef:	89 d7                	mov    %edx,%edi
  80eff1:	89 d6                	mov    %edx,%esi
  80eff3:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80eff5:	5b                   	pop    %ebx
  80eff6:	5e                   	pop    %esi
  80eff7:	5f                   	pop    %edi
  80eff8:	5d                   	pop    %ebp
  80eff9:	c3                   	ret    

0080effa <sys_yield>:

void
sys_yield(void)
{
  80effa:	55                   	push   %ebp
  80effb:	89 e5                	mov    %esp,%ebp
  80effd:	57                   	push   %edi
  80effe:	56                   	push   %esi
  80efff:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f000:	ba 00 00 00 00       	mov    $0x0,%edx
  80f005:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f00a:	89 d1                	mov    %edx,%ecx
  80f00c:	89 d3                	mov    %edx,%ebx
  80f00e:	89 d7                	mov    %edx,%edi
  80f010:	89 d6                	mov    %edx,%esi
  80f012:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f014:	5b                   	pop    %ebx
  80f015:	5e                   	pop    %esi
  80f016:	5f                   	pop    %edi
  80f017:	5d                   	pop    %ebp
  80f018:	c3                   	ret    

0080f019 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f019:	55                   	push   %ebp
  80f01a:	89 e5                	mov    %esp,%ebp
  80f01c:	57                   	push   %edi
  80f01d:	56                   	push   %esi
  80f01e:	53                   	push   %ebx
  80f01f:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f022:	be 00 00 00 00       	mov    $0x0,%esi
  80f027:	8b 55 08             	mov    0x8(%ebp),%edx
  80f02a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f02d:	b8 04 00 00 00       	mov    $0x4,%eax
  80f032:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f035:	89 f7                	mov    %esi,%edi
  80f037:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f039:	85 c0                	test   %eax,%eax
  80f03b:	7f 08                	jg     80f045 <sys_page_alloc+0x2c>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f03d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f040:	5b                   	pop    %ebx
  80f041:	5e                   	pop    %esi
  80f042:	5f                   	pop    %edi
  80f043:	5d                   	pop    %ebp
  80f044:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f045:	83 ec 0c             	sub    $0xc,%esp
  80f048:	50                   	push   %eax
  80f049:	6a 04                	push   $0x4
  80f04b:	68 df 36 81 00       	push   $0x8136df
  80f050:	6a 23                	push   $0x23
  80f052:	68 fc 36 81 00       	push   $0x8136fc
  80f057:	e8 14 f5 ff ff       	call   80e570 <_panic>

0080f05c <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f05c:	55                   	push   %ebp
  80f05d:	89 e5                	mov    %esp,%ebp
  80f05f:	57                   	push   %edi
  80f060:	56                   	push   %esi
  80f061:	53                   	push   %ebx
  80f062:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f065:	8b 55 08             	mov    0x8(%ebp),%edx
  80f068:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f06b:	b8 05 00 00 00       	mov    $0x5,%eax
  80f070:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f073:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f076:	8b 75 18             	mov    0x18(%ebp),%esi
  80f079:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f07b:	85 c0                	test   %eax,%eax
  80f07d:	7f 08                	jg     80f087 <sys_page_map+0x2b>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f07f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f082:	5b                   	pop    %ebx
  80f083:	5e                   	pop    %esi
  80f084:	5f                   	pop    %edi
  80f085:	5d                   	pop    %ebp
  80f086:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f087:	83 ec 0c             	sub    $0xc,%esp
  80f08a:	50                   	push   %eax
  80f08b:	6a 05                	push   $0x5
  80f08d:	68 df 36 81 00       	push   $0x8136df
  80f092:	6a 23                	push   $0x23
  80f094:	68 fc 36 81 00       	push   $0x8136fc
  80f099:	e8 d2 f4 ff ff       	call   80e570 <_panic>

0080f09e <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f09e:	55                   	push   %ebp
  80f09f:	89 e5                	mov    %esp,%ebp
  80f0a1:	57                   	push   %edi
  80f0a2:	56                   	push   %esi
  80f0a3:	53                   	push   %ebx
  80f0a4:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f0a7:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f0ac:	8b 55 08             	mov    0x8(%ebp),%edx
  80f0af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0b2:	b8 06 00 00 00       	mov    $0x6,%eax
  80f0b7:	89 df                	mov    %ebx,%edi
  80f0b9:	89 de                	mov    %ebx,%esi
  80f0bb:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f0bd:	85 c0                	test   %eax,%eax
  80f0bf:	7f 08                	jg     80f0c9 <sys_page_unmap+0x2b>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f0c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f0c4:	5b                   	pop    %ebx
  80f0c5:	5e                   	pop    %esi
  80f0c6:	5f                   	pop    %edi
  80f0c7:	5d                   	pop    %ebp
  80f0c8:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f0c9:	83 ec 0c             	sub    $0xc,%esp
  80f0cc:	50                   	push   %eax
  80f0cd:	6a 06                	push   $0x6
  80f0cf:	68 df 36 81 00       	push   $0x8136df
  80f0d4:	6a 23                	push   $0x23
  80f0d6:	68 fc 36 81 00       	push   $0x8136fc
  80f0db:	e8 90 f4 ff ff       	call   80e570 <_panic>

0080f0e0 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f0e0:	55                   	push   %ebp
  80f0e1:	89 e5                	mov    %esp,%ebp
  80f0e3:	57                   	push   %edi
  80f0e4:	56                   	push   %esi
  80f0e5:	53                   	push   %ebx
  80f0e6:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f0e9:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f0ee:	8b 55 08             	mov    0x8(%ebp),%edx
  80f0f1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0f4:	b8 08 00 00 00       	mov    $0x8,%eax
  80f0f9:	89 df                	mov    %ebx,%edi
  80f0fb:	89 de                	mov    %ebx,%esi
  80f0fd:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f0ff:	85 c0                	test   %eax,%eax
  80f101:	7f 08                	jg     80f10b <sys_env_set_status+0x2b>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f103:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f106:	5b                   	pop    %ebx
  80f107:	5e                   	pop    %esi
  80f108:	5f                   	pop    %edi
  80f109:	5d                   	pop    %ebp
  80f10a:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f10b:	83 ec 0c             	sub    $0xc,%esp
  80f10e:	50                   	push   %eax
  80f10f:	6a 08                	push   $0x8
  80f111:	68 df 36 81 00       	push   $0x8136df
  80f116:	6a 23                	push   $0x23
  80f118:	68 fc 36 81 00       	push   $0x8136fc
  80f11d:	e8 4e f4 ff ff       	call   80e570 <_panic>

0080f122 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f122:	55                   	push   %ebp
  80f123:	89 e5                	mov    %esp,%ebp
  80f125:	57                   	push   %edi
  80f126:	56                   	push   %esi
  80f127:	53                   	push   %ebx
  80f128:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f12b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f130:	8b 55 08             	mov    0x8(%ebp),%edx
  80f133:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f136:	b8 09 00 00 00       	mov    $0x9,%eax
  80f13b:	89 df                	mov    %ebx,%edi
  80f13d:	89 de                	mov    %ebx,%esi
  80f13f:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f141:	85 c0                	test   %eax,%eax
  80f143:	7f 08                	jg     80f14d <sys_env_set_trapframe+0x2b>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f145:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f148:	5b                   	pop    %ebx
  80f149:	5e                   	pop    %esi
  80f14a:	5f                   	pop    %edi
  80f14b:	5d                   	pop    %ebp
  80f14c:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f14d:	83 ec 0c             	sub    $0xc,%esp
  80f150:	50                   	push   %eax
  80f151:	6a 09                	push   $0x9
  80f153:	68 df 36 81 00       	push   $0x8136df
  80f158:	6a 23                	push   $0x23
  80f15a:	68 fc 36 81 00       	push   $0x8136fc
  80f15f:	e8 0c f4 ff ff       	call   80e570 <_panic>

0080f164 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f164:	55                   	push   %ebp
  80f165:	89 e5                	mov    %esp,%ebp
  80f167:	57                   	push   %edi
  80f168:	56                   	push   %esi
  80f169:	53                   	push   %ebx
  80f16a:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f16d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f172:	8b 55 08             	mov    0x8(%ebp),%edx
  80f175:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f178:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f17d:	89 df                	mov    %ebx,%edi
  80f17f:	89 de                	mov    %ebx,%esi
  80f181:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f183:	85 c0                	test   %eax,%eax
  80f185:	7f 08                	jg     80f18f <sys_env_set_pgfault_upcall+0x2b>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f187:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f18a:	5b                   	pop    %ebx
  80f18b:	5e                   	pop    %esi
  80f18c:	5f                   	pop    %edi
  80f18d:	5d                   	pop    %ebp
  80f18e:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f18f:	83 ec 0c             	sub    $0xc,%esp
  80f192:	50                   	push   %eax
  80f193:	6a 0a                	push   $0xa
  80f195:	68 df 36 81 00       	push   $0x8136df
  80f19a:	6a 23                	push   $0x23
  80f19c:	68 fc 36 81 00       	push   $0x8136fc
  80f1a1:	e8 ca f3 ff ff       	call   80e570 <_panic>

0080f1a6 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f1a6:	55                   	push   %ebp
  80f1a7:	89 e5                	mov    %esp,%ebp
  80f1a9:	57                   	push   %edi
  80f1aa:	56                   	push   %esi
  80f1ab:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f1ac:	8b 55 08             	mov    0x8(%ebp),%edx
  80f1af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f1b2:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f1b7:	be 00 00 00 00       	mov    $0x0,%esi
  80f1bc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f1bf:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f1c2:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f1c4:	5b                   	pop    %ebx
  80f1c5:	5e                   	pop    %esi
  80f1c6:	5f                   	pop    %edi
  80f1c7:	5d                   	pop    %ebp
  80f1c8:	c3                   	ret    

0080f1c9 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f1c9:	55                   	push   %ebp
  80f1ca:	89 e5                	mov    %esp,%ebp
  80f1cc:	57                   	push   %edi
  80f1cd:	56                   	push   %esi
  80f1ce:	53                   	push   %ebx
  80f1cf:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f1d2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f1d7:	8b 55 08             	mov    0x8(%ebp),%edx
  80f1da:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f1df:	89 cb                	mov    %ecx,%ebx
  80f1e1:	89 cf                	mov    %ecx,%edi
  80f1e3:	89 ce                	mov    %ecx,%esi
  80f1e5:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f1e7:	85 c0                	test   %eax,%eax
  80f1e9:	7f 08                	jg     80f1f3 <sys_ipc_recv+0x2a>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f1eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f1ee:	5b                   	pop    %ebx
  80f1ef:	5e                   	pop    %esi
  80f1f0:	5f                   	pop    %edi
  80f1f1:	5d                   	pop    %ebp
  80f1f2:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f1f3:	83 ec 0c             	sub    $0xc,%esp
  80f1f6:	50                   	push   %eax
  80f1f7:	6a 0d                	push   $0xd
  80f1f9:	68 df 36 81 00       	push   $0x8136df
  80f1fe:	6a 23                	push   $0x23
  80f200:	68 fc 36 81 00       	push   $0x8136fc
  80f205:	e8 66 f3 ff ff       	call   80e570 <_panic>

0080f20a <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f20a:	55                   	push   %ebp
  80f20b:	89 e5                	mov    %esp,%ebp
  80f20d:	57                   	push   %edi
  80f20e:	56                   	push   %esi
  80f20f:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f210:	ba 00 00 00 00       	mov    $0x0,%edx
  80f215:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f21a:	89 d1                	mov    %edx,%ecx
  80f21c:	89 d3                	mov    %edx,%ebx
  80f21e:	89 d7                	mov    %edx,%edi
  80f220:	89 d6                	mov    %edx,%esi
  80f222:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f224:	5b                   	pop    %ebx
  80f225:	5e                   	pop    %esi
  80f226:	5f                   	pop    %edi
  80f227:	5d                   	pop    %ebp
  80f228:	c3                   	ret    

0080f229 <pgfault>:
	return uvpt[PGNUM((uintptr_t)addr)];
}

static void
pgfault(struct UTrapframe *utf)
{
  80f229:	55                   	push   %ebp
  80f22a:	89 e5                	mov    %esp,%ebp
  80f22c:	57                   	push   %edi
  80f22d:	56                   	push   %esi
  80f22e:	53                   	push   %ebx
  80f22f:	83 ec 0c             	sub    $0xc,%esp
  80f232:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80f235:	8b 18                	mov    (%eax),%ebx
	uint32_t err = utf->utf_err;
  80f237:	8b 50 04             	mov    0x4(%eax),%edx
	if((uvpd[PDX((uintptr_t)addr)] & PTE_P) == 0)
  80f23a:	89 d9                	mov    %ebx,%ecx
  80f23c:	c1 e9 16             	shr    $0x16,%ecx
  80f23f:	8b 0c 8d 00 d0 7b ef 	mov    -0x10843000(,%ecx,4),%ecx
		return 0;
  80f246:	be 00 00 00 00       	mov    $0x0,%esi
	if((uvpd[PDX((uintptr_t)addr)] & PTE_P) == 0)
  80f24b:	f6 c1 01             	test   $0x1,%cl
  80f24e:	74 0c                	je     80f25c <pgfault+0x33>
	return uvpt[PGNUM((uintptr_t)addr)];
  80f250:	89 d9                	mov    %ebx,%ecx
  80f252:	c1 e9 0c             	shr    $0xc,%ecx
  80f255:	8b 34 8d 00 00 40 ef 	mov    -0x10c00000(,%ecx,4),%esi
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
  if ((err & FEC_WR) == 0) {
  80f25c:	f6 c2 02             	test   $0x2,%dl
  80f25f:	0f 84 a3 00 00 00    	je     80f308 <pgfault+0xdf>
    cprintf("[%08x] user fault va %08x ip %08x\n", sys_getenvid(), addr, utf->utf_eip);
    panic("pgfault: invalid UtrapFrame that not write err.\n");
  }
  if ((uvpt[PGNUM(addr)] & PTE_COW) == 0) {
  80f265:	89 da                	mov    %ebx,%edx
  80f267:	c1 ea 0c             	shr    $0xc,%edx
  80f26a:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f271:	f6 c6 08             	test   $0x8,%dh
  80f274:	0f 84 b7 00 00 00    	je     80f331 <pgfault+0x108>
	// LAB 4: Your code here.
  // 对于某一页来说,父进程必须在子进程标记为cow后才能进行写操作
  // 而且在写操作之前它（父进程）的该页标记必须是cow，否则父进程
  // 会对子进程指向的页进行写操作而不是触发写时复制错误，这会导致
  // 父进程触发了cow后两个进程还指向相同的物理页。
  envid_t envid = sys_getenvid();
  80f27a:	e8 5c fd ff ff       	call   80efdb <sys_getenvid>
  80f27f:	89 c6                	mov    %eax,%esi
  if ((r = sys_page_alloc(envid, (void *)PFTEMP, PTE_P | PTE_W | PTE_U)) < 0)
  80f281:	83 ec 04             	sub    $0x4,%esp
  80f284:	6a 07                	push   $0x7
  80f286:	68 00 f0 7f 00       	push   $0x7ff000
  80f28b:	50                   	push   %eax
  80f28c:	e8 88 fd ff ff       	call   80f019 <sys_page_alloc>
  80f291:	83 c4 10             	add    $0x10,%esp
  80f294:	85 c0                	test   %eax,%eax
  80f296:	0f 88 bc 00 00 00    	js     80f358 <pgfault+0x12f>
      panic("pgfault: page allocation failed %e", r);

  addr = ROUNDDOWN(addr, PGSIZE);
  80f29c:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  memmove(PFTEMP, addr, PGSIZE);
  80f2a2:	83 ec 04             	sub    $0x4,%esp
  80f2a5:	68 00 10 00 00       	push   $0x1000
  80f2aa:	53                   	push   %ebx
  80f2ab:	68 00 f0 7f 00       	push   $0x7ff000
  80f2b0:	e8 00 fb ff ff       	call   80edb5 <memmove>
  if ((r = sys_page_unmap(envid, addr)) < 0)
  80f2b5:	83 c4 08             	add    $0x8,%esp
  80f2b8:	53                   	push   %ebx
  80f2b9:	56                   	push   %esi
  80f2ba:	e8 df fd ff ff       	call   80f09e <sys_page_unmap>
  80f2bf:	83 c4 10             	add    $0x10,%esp
  80f2c2:	85 c0                	test   %eax,%eax
  80f2c4:	0f 88 a0 00 00 00    	js     80f36a <pgfault+0x141>
      panic("pgfault: page unmap failed (%e)", r);
  if ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) < 0)
  80f2ca:	83 ec 0c             	sub    $0xc,%esp
  80f2cd:	6a 07                	push   $0x7
  80f2cf:	53                   	push   %ebx
  80f2d0:	56                   	push   %esi
  80f2d1:	68 00 f0 7f 00       	push   $0x7ff000
  80f2d6:	56                   	push   %esi
  80f2d7:	e8 80 fd ff ff       	call   80f05c <sys_page_map>
  80f2dc:	83 c4 20             	add    $0x20,%esp
  80f2df:	85 c0                	test   %eax,%eax
  80f2e1:	0f 88 95 00 00 00    	js     80f37c <pgfault+0x153>
      panic("pgfault: page map failed (%e)", r);
  if ((r = sys_page_unmap(envid, PFTEMP)) < 0)
  80f2e7:	83 ec 08             	sub    $0x8,%esp
  80f2ea:	68 00 f0 7f 00       	push   $0x7ff000
  80f2ef:	56                   	push   %esi
  80f2f0:	e8 a9 fd ff ff       	call   80f09e <sys_page_unmap>
  80f2f5:	83 c4 10             	add    $0x10,%esp
  80f2f8:	85 c0                	test   %eax,%eax
  80f2fa:	0f 88 8e 00 00 00    	js     80f38e <pgfault+0x165>
      panic("pgfault: page unmap failed (%e)", r);

}
  80f300:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f303:	5b                   	pop    %ebx
  80f304:	5e                   	pop    %esi
  80f305:	5f                   	pop    %edi
  80f306:	5d                   	pop    %ebp
  80f307:	c3                   	ret    
    cprintf("[%08x] user fault va %08x ip %08x\n", sys_getenvid(), addr, utf->utf_eip);
  80f308:	8b 70 28             	mov    0x28(%eax),%esi
  80f30b:	e8 cb fc ff ff       	call   80efdb <sys_getenvid>
  80f310:	56                   	push   %esi
  80f311:	53                   	push   %ebx
  80f312:	50                   	push   %eax
  80f313:	68 0c 37 81 00       	push   $0x81370c
  80f318:	e8 2e f3 ff ff       	call   80e64b <cprintf>
    panic("pgfault: invalid UtrapFrame that not write err.\n");
  80f31d:	83 c4 0c             	add    $0xc,%esp
  80f320:	68 30 37 81 00       	push   $0x813730
  80f325:	6a 27                	push   $0x27
  80f327:	68 04 38 81 00       	push   $0x813804
  80f32c:	e8 3f f2 ff ff       	call   80e570 <_panic>
    cprintf("[%08x] user fault va %08x ip %08x\n", sys_getenvid(), addr, utf->utf_eip);
  80f331:	8b 78 28             	mov    0x28(%eax),%edi
  80f334:	e8 a2 fc ff ff       	call   80efdb <sys_getenvid>
  80f339:	57                   	push   %edi
  80f33a:	53                   	push   %ebx
  80f33b:	50                   	push   %eax
  80f33c:	68 0c 37 81 00       	push   $0x81370c
  80f341:	e8 05 f3 ff ff       	call   80e64b <cprintf>
    panic("pgfault: invalid UtrapFrame that not cow and pte=%08x.\n", pte);
  80f346:	56                   	push   %esi
  80f347:	68 64 37 81 00       	push   $0x813764
  80f34c:	6a 2b                	push   $0x2b
  80f34e:	68 04 38 81 00       	push   $0x813804
  80f353:	e8 18 f2 ff ff       	call   80e570 <_panic>
      panic("pgfault: page allocation failed %e", r);
  80f358:	50                   	push   %eax
  80f359:	68 9c 37 81 00       	push   $0x81379c
  80f35e:	6a 39                	push   $0x39
  80f360:	68 04 38 81 00       	push   $0x813804
  80f365:	e8 06 f2 ff ff       	call   80e570 <_panic>
      panic("pgfault: page unmap failed (%e)", r);
  80f36a:	50                   	push   %eax
  80f36b:	68 c0 37 81 00       	push   $0x8137c0
  80f370:	6a 3e                	push   $0x3e
  80f372:	68 04 38 81 00       	push   $0x813804
  80f377:	e8 f4 f1 ff ff       	call   80e570 <_panic>
      panic("pgfault: page map failed (%e)", r);
  80f37c:	50                   	push   %eax
  80f37d:	68 0f 38 81 00       	push   $0x81380f
  80f382:	6a 40                	push   $0x40
  80f384:	68 04 38 81 00       	push   $0x813804
  80f389:	e8 e2 f1 ff ff       	call   80e570 <_panic>
      panic("pgfault: page unmap failed (%e)", r);
  80f38e:	50                   	push   %eax
  80f38f:	68 c0 37 81 00       	push   $0x8137c0
  80f394:	6a 42                	push   $0x42
  80f396:	68 04 38 81 00       	push   $0x813804
  80f39b:	e8 d0 f1 ff ff       	call   80e570 <_panic>

0080f3a0 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f3a0:	55                   	push   %ebp
  80f3a1:	89 e5                	mov    %esp,%ebp
  80f3a3:	57                   	push   %edi
  80f3a4:	56                   	push   %esi
  80f3a5:	53                   	push   %ebx
  80f3a6:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
  set_pgfault_handler(pgfault);
  80f3a9:	68 29 f2 80 00       	push   $0x80f229
  80f3ae:	e8 33 17 00 00       	call   810ae6 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f3b3:	b8 07 00 00 00       	mov    $0x7,%eax
  80f3b8:	cd 30                	int    $0x30
  80f3ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  envid_t e_id = sys_exofork();
  if (e_id < 0) panic("fork: %e", e_id);
  80f3bd:	83 c4 10             	add    $0x10,%esp
  80f3c0:	85 c0                	test   %eax,%eax
  80f3c2:	78 2d                	js     80f3f1 <fork+0x51>
  80f3c4:	89 c7                	mov    %eax,%edi
      thisenv = &envs[ENVX(sys_getenvid())];
      return 0;
  }

  // parent
  for (uintptr_t addr = 0; addr < USTACKTOP; addr += PGSIZE) {
  80f3c6:	bb 00 00 00 00       	mov    $0x0,%ebx
  if (e_id == 0) {
  80f3cb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f3cf:	0f 85 a6 00 00 00    	jne    80f47b <fork+0xdb>
      thisenv = &envs[ENVX(sys_getenvid())];
  80f3d5:	e8 01 fc ff ff       	call   80efdb <sys_getenvid>
  80f3da:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f3df:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f3e2:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f3e7:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
      return 0;
  80f3ec:	e9 79 01 00 00       	jmp    80f56a <fork+0x1ca>
  if (e_id < 0) panic("fork: %e", e_id);
  80f3f1:	50                   	push   %eax
  80f3f2:	68 2d 38 81 00       	push   $0x81382d
  80f3f7:	68 aa 00 00 00       	push   $0xaa
  80f3fc:	68 04 38 81 00       	push   $0x813804
  80f401:	e8 6a f1 ff ff       	call   80e570 <_panic>
		if((error_code = sys_page_map(0, addr, envid, addr, PTE_U | PTE_P)) < 0)
  80f406:	83 ec 0c             	sub    $0xc,%esp
  80f409:	6a 05                	push   $0x5
  80f40b:	53                   	push   %ebx
  80f40c:	57                   	push   %edi
  80f40d:	53                   	push   %ebx
  80f40e:	6a 00                	push   $0x0
  80f410:	e8 47 fc ff ff       	call   80f05c <sys_page_map>
  80f415:	83 c4 20             	add    $0x20,%esp
  80f418:	85 c0                	test   %eax,%eax
  80f41a:	79 4d                	jns    80f469 <fork+0xc9>
			panic("Page Map Failed: %e", error_code);
  80f41c:	50                   	push   %eax
  80f41d:	68 36 38 81 00       	push   $0x813836
  80f422:	6a 61                	push   $0x61
  80f424:	68 04 38 81 00       	push   $0x813804
  80f429:	e8 42 f1 ff ff       	call   80e570 <_panic>
		if((error_code = sys_page_map(0, addr, envid, addr, PTE_U | PTE_COW | PTE_P)) < 0)
  80f42e:	83 ec 0c             	sub    $0xc,%esp
  80f431:	68 05 08 00 00       	push   $0x805
  80f436:	53                   	push   %ebx
  80f437:	57                   	push   %edi
  80f438:	53                   	push   %ebx
  80f439:	6a 00                	push   $0x0
  80f43b:	e8 1c fc ff ff       	call   80f05c <sys_page_map>
  80f440:	83 c4 20             	add    $0x20,%esp
  80f443:	85 c0                	test   %eax,%eax
  80f445:	0f 88 b7 00 00 00    	js     80f502 <fork+0x162>
		if((error_code = sys_page_map(0, addr, 0, addr, PTE_U | PTE_COW | PTE_P)) < 0)
  80f44b:	83 ec 0c             	sub    $0xc,%esp
  80f44e:	68 05 08 00 00       	push   $0x805
  80f453:	53                   	push   %ebx
  80f454:	6a 00                	push   $0x0
  80f456:	53                   	push   %ebx
  80f457:	6a 00                	push   $0x0
  80f459:	e8 fe fb ff ff       	call   80f05c <sys_page_map>
  80f45e:	83 c4 20             	add    $0x20,%esp
  80f461:	85 c0                	test   %eax,%eax
  80f463:	0f 88 ab 00 00 00    	js     80f514 <fork+0x174>
  for (uintptr_t addr = 0; addr < USTACKTOP; addr += PGSIZE) {
  80f469:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f46f:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f475:	0f 84 ab 00 00 00    	je     80f526 <fork+0x186>
      if ( (uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P) ) {
  80f47b:	89 d8                	mov    %ebx,%eax
  80f47d:	c1 e8 16             	shr    $0x16,%eax
  80f480:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f487:	a8 01                	test   $0x1,%al
  80f489:	74 de                	je     80f469 <fork+0xc9>
  80f48b:	89 d8                	mov    %ebx,%eax
  80f48d:	c1 e8 0c             	shr    $0xc,%eax
  80f490:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f497:	f6 c2 01             	test   $0x1,%dl
  80f49a:	74 cd                	je     80f469 <fork+0xc9>
	pte_t pte = get_pte((void*)(pn * PGSIZE));
  80f49c:	c1 e0 0c             	shl    $0xc,%eax
	if((uvpd[PDX((uintptr_t)addr)] & PTE_P) == 0)
  80f49f:	89 c2                	mov    %eax,%edx
  80f4a1:	c1 ea 16             	shr    $0x16,%edx
  80f4a4:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f4ab:	f6 c2 01             	test   $0x1,%dl
  80f4ae:	74 b9                	je     80f469 <fork+0xc9>
	return uvpt[PGNUM((uintptr_t)addr)];
  80f4b0:	c1 e8 0c             	shr    $0xc,%eax
  80f4b3:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if(!(pte & PTE_P))
  80f4ba:	a8 01                	test   $0x1,%al
  80f4bc:	74 ab                	je     80f469 <fork+0xc9>
	if(!(pte & PTE_W) && !(pte & PTE_COW))
  80f4be:	a9 02 08 00 00       	test   $0x802,%eax
  80f4c3:	0f 84 3d ff ff ff    	je     80f406 <fork+0x66>
	else if(pte & PTE_SHARE)
  80f4c9:	f6 c4 04             	test   $0x4,%ah
  80f4cc:	0f 84 5c ff ff ff    	je     80f42e <fork+0x8e>
		if((error_code = sys_page_map(0, addr, envid, addr, pte & PTE_SYSCALL)) < 0)
  80f4d2:	83 ec 0c             	sub    $0xc,%esp
  80f4d5:	25 07 0e 00 00       	and    $0xe07,%eax
  80f4da:	50                   	push   %eax
  80f4db:	53                   	push   %ebx
  80f4dc:	57                   	push   %edi
  80f4dd:	53                   	push   %ebx
  80f4de:	6a 00                	push   $0x0
  80f4e0:	e8 77 fb ff ff       	call   80f05c <sys_page_map>
  80f4e5:	83 c4 20             	add    $0x20,%esp
  80f4e8:	85 c0                	test   %eax,%eax
  80f4ea:	0f 89 79 ff ff ff    	jns    80f469 <fork+0xc9>
			panic("Page Map Failed: %e", error_code);
  80f4f0:	50                   	push   %eax
  80f4f1:	68 36 38 81 00       	push   $0x813836
  80f4f6:	6a 67                	push   $0x67
  80f4f8:	68 04 38 81 00       	push   $0x813804
  80f4fd:	e8 6e f0 ff ff       	call   80e570 <_panic>
			panic("Page Map Failed: %e", error_code);
  80f502:	50                   	push   %eax
  80f503:	68 36 38 81 00       	push   $0x813836
  80f508:	6a 6d                	push   $0x6d
  80f50a:	68 04 38 81 00       	push   $0x813804
  80f50f:	e8 5c f0 ff ff       	call   80e570 <_panic>
			panic("Page Map Failed: %e", error_code);
  80f514:	50                   	push   %eax
  80f515:	68 36 38 81 00       	push   $0x813836
  80f51a:	6a 70                	push   $0x70
  80f51c:	68 04 38 81 00       	push   $0x813804
  80f521:	e8 4a f0 ff ff       	call   80e570 <_panic>
          // dup page to child
          duppage(e_id, PGNUM(addr));
      }
  }
  // alloc page for exception stack
  int r = sys_page_alloc(e_id, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);
  80f526:	83 ec 04             	sub    $0x4,%esp
  80f529:	6a 07                	push   $0x7
  80f52b:	68 00 f0 bf ee       	push   $0xeebff000
  80f530:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f533:	e8 e1 fa ff ff       	call   80f019 <sys_page_alloc>
  if (r < 0) panic("fork: %e",r);
  80f538:	83 c4 10             	add    $0x10,%esp
  80f53b:	85 c0                	test   %eax,%eax
  80f53d:	78 36                	js     80f575 <fork+0x1d5>

  // DO NOT FORGET
  extern void _pgfault_upcall();
  r = sys_env_set_pgfault_upcall(e_id, _pgfault_upcall);
  80f53f:	83 ec 08             	sub    $0x8,%esp
  80f542:	68 5c 0b 81 00       	push   $0x810b5c
  80f547:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f54a:	e8 15 fc ff ff       	call   80f164 <sys_env_set_pgfault_upcall>
  if (r < 0) panic("fork: set upcall for child fail, %e", r);
  80f54f:	83 c4 10             	add    $0x10,%esp
  80f552:	85 c0                	test   %eax,%eax
  80f554:	78 34                	js     80f58a <fork+0x1ea>

  // mark the child environment runnable
  if ((r = sys_env_set_status(e_id, ENV_RUNNABLE)) < 0)
  80f556:	83 ec 08             	sub    $0x8,%esp
  80f559:	6a 02                	push   $0x2
  80f55b:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f55e:	e8 7d fb ff ff       	call   80f0e0 <sys_env_set_status>
  80f563:	83 c4 10             	add    $0x10,%esp
  80f566:	85 c0                	test   %eax,%eax
  80f568:	78 35                	js     80f59f <fork+0x1ff>
      panic("sys_env_set_status: %e", r);

  return e_id;
}
  80f56a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f56d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f570:	5b                   	pop    %ebx
  80f571:	5e                   	pop    %esi
  80f572:	5f                   	pop    %edi
  80f573:	5d                   	pop    %ebp
  80f574:	c3                   	ret    
  if (r < 0) panic("fork: %e",r);
  80f575:	50                   	push   %eax
  80f576:	68 2d 38 81 00       	push   $0x81382d
  80f57b:	68 ba 00 00 00       	push   $0xba
  80f580:	68 04 38 81 00       	push   $0x813804
  80f585:	e8 e6 ef ff ff       	call   80e570 <_panic>
  if (r < 0) panic("fork: set upcall for child fail, %e", r);
  80f58a:	50                   	push   %eax
  80f58b:	68 e0 37 81 00       	push   $0x8137e0
  80f590:	68 bf 00 00 00       	push   $0xbf
  80f595:	68 04 38 81 00       	push   $0x813804
  80f59a:	e8 d1 ef ff ff       	call   80e570 <_panic>
      panic("sys_env_set_status: %e", r);
  80f59f:	50                   	push   %eax
  80f5a0:	68 4a 38 81 00       	push   $0x81384a
  80f5a5:	68 c3 00 00 00       	push   $0xc3
  80f5aa:	68 04 38 81 00       	push   $0x813804
  80f5af:	e8 bc ef ff ff       	call   80e570 <_panic>

0080f5b4 <sfork>:

// Challenge!
int
sfork(void)
{
  80f5b4:	55                   	push   %ebp
  80f5b5:	89 e5                	mov    %esp,%ebp
  80f5b7:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f5ba:	68 61 38 81 00       	push   $0x813861
  80f5bf:	68 cc 00 00 00       	push   $0xcc
  80f5c4:	68 04 38 81 00       	push   $0x813804
  80f5c9:	e8 a2 ef ff ff       	call   80e570 <_panic>

0080f5ce <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f5ce:	55                   	push   %ebp
  80f5cf:	89 e5                	mov    %esp,%ebp
  80f5d1:	56                   	push   %esi
  80f5d2:	53                   	push   %ebx
  80f5d3:	8b 75 08             	mov    0x8(%ebp),%esi
  80f5d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f5d9:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	//panic("ipc_recv not implemented");
 	int32_t retval = (pg == NULL) ? sys_ipc_recv((void*)UTOP) : sys_ipc_recv(pg);
  80f5dc:	85 c0                	test   %eax,%eax
  80f5de:	74 4f                	je     80f62f <ipc_recv+0x61>
  80f5e0:	83 ec 0c             	sub    $0xc,%esp
  80f5e3:	50                   	push   %eax
  80f5e4:	e8 e0 fb ff ff       	call   80f1c9 <sys_ipc_recv>
  80f5e9:	83 c4 10             	add    $0x10,%esp
	// If page fault fails
	if(from_env_store != NULL)
  80f5ec:	85 f6                	test   %esi,%esi
  80f5ee:	74 14                	je     80f604 <ipc_recv+0x36>
		*from_env_store = (retval == 0) ? thisenv->env_ipc_from : 0;
  80f5f0:	ba 00 00 00 00       	mov    $0x0,%edx
  80f5f5:	85 c0                	test   %eax,%eax
  80f5f7:	75 09                	jne    80f602 <ipc_recv+0x34>
  80f5f9:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80f5ff:	8b 52 74             	mov    0x74(%edx),%edx
  80f602:	89 16                	mov    %edx,(%esi)
	if(perm_store != NULL)
  80f604:	85 db                	test   %ebx,%ebx
  80f606:	74 14                	je     80f61c <ipc_recv+0x4e>
		*perm_store = (retval == 0) ? thisenv->env_ipc_perm : 0;
  80f608:	ba 00 00 00 00       	mov    $0x0,%edx
  80f60d:	85 c0                	test   %eax,%eax
  80f60f:	75 09                	jne    80f61a <ipc_recv+0x4c>
  80f611:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80f617:	8b 52 78             	mov    0x78(%edx),%edx
  80f61a:	89 13                	mov    %edx,(%ebx)
	return (retval == 0) ? thisenv->env_ipc_value : retval;
  80f61c:	85 c0                	test   %eax,%eax
  80f61e:	75 08                	jne    80f628 <ipc_recv+0x5a>
  80f620:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f625:	8b 40 70             	mov    0x70(%eax),%eax
}
  80f628:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f62b:	5b                   	pop    %ebx
  80f62c:	5e                   	pop    %esi
  80f62d:	5d                   	pop    %ebp
  80f62e:	c3                   	ret    
 	int32_t retval = (pg == NULL) ? sys_ipc_recv((void*)UTOP) : sys_ipc_recv(pg);
  80f62f:	83 ec 0c             	sub    $0xc,%esp
  80f632:	68 00 00 c0 ee       	push   $0xeec00000
  80f637:	e8 8d fb ff ff       	call   80f1c9 <sys_ipc_recv>
  80f63c:	83 c4 10             	add    $0x10,%esp
  80f63f:	eb ab                	jmp    80f5ec <ipc_recv+0x1e>

0080f641 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f641:	55                   	push   %ebp
  80f642:	89 e5                	mov    %esp,%ebp
  80f644:	57                   	push   %edi
  80f645:	56                   	push   %esi
  80f646:	53                   	push   %ebx
  80f647:	83 ec 0c             	sub    $0xc,%esp
  80f64a:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f64d:	8b 75 10             	mov    0x10(%ebp),%esi
  80f650:	eb 20                	jmp    80f672 <ipc_send+0x31>
	// LAB 4: Your code here.
	//panic("ipc_send not implemented");
  int32_t retval = -1;
	while(retval != 0) {
		retval = (pg == NULL) ? sys_ipc_try_send(to_env, val, (void*)UTOP, 0) : sys_ipc_try_send(to_env, val, pg, perm);
  80f652:	6a 00                	push   $0x0
  80f654:	68 00 00 c0 ee       	push   $0xeec00000
  80f659:	ff 75 0c             	pushl  0xc(%ebp)
  80f65c:	57                   	push   %edi
  80f65d:	e8 44 fb ff ff       	call   80f1a6 <sys_ipc_try_send>
  80f662:	89 c3                	mov    %eax,%ebx
  80f664:	83 c4 10             	add    $0x10,%esp
  80f667:	eb 1f                	jmp    80f688 <ipc_send+0x47>
		if(retval != -E_IPC_NOT_RECV && retval != 0)
			panic("Receving wrong return value of sys_ipc_try_send");
    sys_yield();
  80f669:	e8 8c f9 ff ff       	call   80effa <sys_yield>
	while(retval != 0) {
  80f66e:	85 db                	test   %ebx,%ebx
  80f670:	74 33                	je     80f6a5 <ipc_send+0x64>
		retval = (pg == NULL) ? sys_ipc_try_send(to_env, val, (void*)UTOP, 0) : sys_ipc_try_send(to_env, val, pg, perm);
  80f672:	85 f6                	test   %esi,%esi
  80f674:	74 dc                	je     80f652 <ipc_send+0x11>
  80f676:	ff 75 14             	pushl  0x14(%ebp)
  80f679:	56                   	push   %esi
  80f67a:	ff 75 0c             	pushl  0xc(%ebp)
  80f67d:	57                   	push   %edi
  80f67e:	e8 23 fb ff ff       	call   80f1a6 <sys_ipc_try_send>
  80f683:	89 c3                	mov    %eax,%ebx
  80f685:	83 c4 10             	add    $0x10,%esp
		if(retval != -E_IPC_NOT_RECV && retval != 0)
  80f688:	83 fb f9             	cmp    $0xfffffff9,%ebx
  80f68b:	74 dc                	je     80f669 <ipc_send+0x28>
  80f68d:	85 db                	test   %ebx,%ebx
  80f68f:	74 d8                	je     80f669 <ipc_send+0x28>
			panic("Receving wrong return value of sys_ipc_try_send");
  80f691:	83 ec 04             	sub    $0x4,%esp
  80f694:	68 78 38 81 00       	push   $0x813878
  80f699:	6a 35                	push   $0x35
  80f69b:	68 a8 38 81 00       	push   $0x8138a8
  80f6a0:	e8 cb ee ff ff       	call   80e570 <_panic>
	}
}
  80f6a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f6a8:	5b                   	pop    %ebx
  80f6a9:	5e                   	pop    %esi
  80f6aa:	5f                   	pop    %edi
  80f6ab:	5d                   	pop    %ebp
  80f6ac:	c3                   	ret    

0080f6ad <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f6ad:	55                   	push   %ebp
  80f6ae:	89 e5                	mov    %esp,%ebp
  80f6b0:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f6b3:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f6b8:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f6bb:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f6c1:	8b 52 50             	mov    0x50(%edx),%edx
  80f6c4:	39 ca                	cmp    %ecx,%edx
  80f6c6:	74 11                	je     80f6d9 <ipc_find_env+0x2c>
	for (i = 0; i < NENV; i++)
  80f6c8:	83 c0 01             	add    $0x1,%eax
  80f6cb:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f6d0:	75 e6                	jne    80f6b8 <ipc_find_env+0xb>
			return envs[i].env_id;
	return 0;
  80f6d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80f6d7:	eb 0b                	jmp    80f6e4 <ipc_find_env+0x37>
			return envs[i].env_id;
  80f6d9:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f6dc:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f6e1:	8b 40 48             	mov    0x48(%eax),%eax
}
  80f6e4:	5d                   	pop    %ebp
  80f6e5:	c3                   	ret    

0080f6e6 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f6e6:	55                   	push   %ebp
  80f6e7:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f6e9:	8b 45 08             	mov    0x8(%ebp),%eax
  80f6ec:	05 00 00 00 30       	add    $0x30000000,%eax
  80f6f1:	c1 e8 0c             	shr    $0xc,%eax
}
  80f6f4:	5d                   	pop    %ebp
  80f6f5:	c3                   	ret    

0080f6f6 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f6f6:	55                   	push   %ebp
  80f6f7:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f6f9:	8b 45 08             	mov    0x8(%ebp),%eax
  80f6fc:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80f701:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f706:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f70b:	5d                   	pop    %ebp
  80f70c:	c3                   	ret    

0080f70d <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f70d:	55                   	push   %ebp
  80f70e:	89 e5                	mov    %esp,%ebp
  80f710:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f715:	89 c2                	mov    %eax,%edx
  80f717:	c1 ea 16             	shr    $0x16,%edx
  80f71a:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f721:	f6 c2 01             	test   $0x1,%dl
  80f724:	74 2d                	je     80f753 <fd_alloc+0x46>
  80f726:	89 c2                	mov    %eax,%edx
  80f728:	c1 ea 0c             	shr    $0xc,%edx
  80f72b:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f732:	f6 c2 01             	test   $0x1,%dl
  80f735:	74 1c                	je     80f753 <fd_alloc+0x46>
  80f737:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80f73c:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80f741:	75 d2                	jne    80f715 <fd_alloc+0x8>
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80f743:	8b 45 08             	mov    0x8(%ebp),%eax
  80f746:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_MAX_OPEN;
  80f74c:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80f751:	eb 0a                	jmp    80f75d <fd_alloc+0x50>
			*fd_store = fd;
  80f753:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f756:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f758:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f75d:	5d                   	pop    %ebp
  80f75e:	c3                   	ret    

0080f75f <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80f75f:	55                   	push   %ebp
  80f760:	89 e5                	mov    %esp,%ebp
  80f762:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80f765:	83 f8 1f             	cmp    $0x1f,%eax
  80f768:	77 30                	ja     80f79a <fd_lookup+0x3b>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80f76a:	c1 e0 0c             	shl    $0xc,%eax
  80f76d:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80f772:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80f778:	f6 c2 01             	test   $0x1,%dl
  80f77b:	74 24                	je     80f7a1 <fd_lookup+0x42>
  80f77d:	89 c2                	mov    %eax,%edx
  80f77f:	c1 ea 0c             	shr    $0xc,%edx
  80f782:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f789:	f6 c2 01             	test   $0x1,%dl
  80f78c:	74 1a                	je     80f7a8 <fd_lookup+0x49>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80f78e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f791:	89 02                	mov    %eax,(%edx)
	return 0;
  80f793:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f798:	5d                   	pop    %ebp
  80f799:	c3                   	ret    
		return -E_INVAL;
  80f79a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f79f:	eb f7                	jmp    80f798 <fd_lookup+0x39>
		return -E_INVAL;
  80f7a1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f7a6:	eb f0                	jmp    80f798 <fd_lookup+0x39>
  80f7a8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f7ad:	eb e9                	jmp    80f798 <fd_lookup+0x39>

0080f7af <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80f7af:	55                   	push   %ebp
  80f7b0:	89 e5                	mov    %esp,%ebp
  80f7b2:	83 ec 08             	sub    $0x8,%esp
  80f7b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80f7b8:	ba 00 00 00 00       	mov    $0x0,%edx
  80f7bd:	b8 ec 42 81 00       	mov    $0x8142ec,%eax
		if (devtab[i]->dev_id == dev_id) {
  80f7c2:	39 08                	cmp    %ecx,(%eax)
  80f7c4:	74 38                	je     80f7fe <dev_lookup+0x4f>
	for (i = 0; devtab[i]; i++)
  80f7c6:	83 c2 01             	add    $0x1,%edx
  80f7c9:	8b 04 95 30 39 81 00 	mov    0x813930(,%edx,4),%eax
  80f7d0:	85 c0                	test   %eax,%eax
  80f7d2:	75 ee                	jne    80f7c2 <dev_lookup+0x13>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80f7d4:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f7d9:	8b 40 48             	mov    0x48(%eax),%eax
  80f7dc:	83 ec 04             	sub    $0x4,%esp
  80f7df:	51                   	push   %ecx
  80f7e0:	50                   	push   %eax
  80f7e1:	68 b4 38 81 00       	push   $0x8138b4
  80f7e6:	e8 60 ee ff ff       	call   80e64b <cprintf>
	*dev = 0;
  80f7eb:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f7ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80f7f4:	83 c4 10             	add    $0x10,%esp
  80f7f7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80f7fc:	c9                   	leave  
  80f7fd:	c3                   	ret    
			*dev = devtab[i];
  80f7fe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f801:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f803:	b8 00 00 00 00       	mov    $0x0,%eax
  80f808:	eb f2                	jmp    80f7fc <dev_lookup+0x4d>

0080f80a <fd_close>:
{
  80f80a:	55                   	push   %ebp
  80f80b:	89 e5                	mov    %esp,%ebp
  80f80d:	57                   	push   %edi
  80f80e:	56                   	push   %esi
  80f80f:	53                   	push   %ebx
  80f810:	83 ec 24             	sub    $0x24,%esp
  80f813:	8b 75 08             	mov    0x8(%ebp),%esi
  80f816:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f819:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f81c:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f81d:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80f823:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f826:	50                   	push   %eax
  80f827:	e8 33 ff ff ff       	call   80f75f <fd_lookup>
  80f82c:	89 c3                	mov    %eax,%ebx
  80f82e:	83 c4 10             	add    $0x10,%esp
  80f831:	85 c0                	test   %eax,%eax
  80f833:	78 05                	js     80f83a <fd_close+0x30>
	    || fd != fd2)
  80f835:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80f838:	74 16                	je     80f850 <fd_close+0x46>
		return (must_exist ? r : 0);
  80f83a:	89 f8                	mov    %edi,%eax
  80f83c:	84 c0                	test   %al,%al
  80f83e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f843:	0f 44 d8             	cmove  %eax,%ebx
}
  80f846:	89 d8                	mov    %ebx,%eax
  80f848:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f84b:	5b                   	pop    %ebx
  80f84c:	5e                   	pop    %esi
  80f84d:	5f                   	pop    %edi
  80f84e:	5d                   	pop    %ebp
  80f84f:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80f850:	83 ec 08             	sub    $0x8,%esp
  80f853:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80f856:	50                   	push   %eax
  80f857:	ff 36                	pushl  (%esi)
  80f859:	e8 51 ff ff ff       	call   80f7af <dev_lookup>
  80f85e:	89 c3                	mov    %eax,%ebx
  80f860:	83 c4 10             	add    $0x10,%esp
  80f863:	85 c0                	test   %eax,%eax
  80f865:	78 1a                	js     80f881 <fd_close+0x77>
		if (dev->dev_close)
  80f867:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f86a:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80f86d:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80f872:	85 c0                	test   %eax,%eax
  80f874:	74 0b                	je     80f881 <fd_close+0x77>
			r = (*dev->dev_close)(fd);
  80f876:	83 ec 0c             	sub    $0xc,%esp
  80f879:	56                   	push   %esi
  80f87a:	ff d0                	call   *%eax
  80f87c:	89 c3                	mov    %eax,%ebx
  80f87e:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80f881:	83 ec 08             	sub    $0x8,%esp
  80f884:	56                   	push   %esi
  80f885:	6a 00                	push   $0x0
  80f887:	e8 12 f8 ff ff       	call   80f09e <sys_page_unmap>
	return r;
  80f88c:	83 c4 10             	add    $0x10,%esp
  80f88f:	eb b5                	jmp    80f846 <fd_close+0x3c>

0080f891 <close>:

int
close(int fdnum)
{
  80f891:	55                   	push   %ebp
  80f892:	89 e5                	mov    %esp,%ebp
  80f894:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f897:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f89a:	50                   	push   %eax
  80f89b:	ff 75 08             	pushl  0x8(%ebp)
  80f89e:	e8 bc fe ff ff       	call   80f75f <fd_lookup>
  80f8a3:	83 c4 10             	add    $0x10,%esp
  80f8a6:	85 c0                	test   %eax,%eax
  80f8a8:	79 02                	jns    80f8ac <close+0x1b>
		return r;
	else
		return fd_close(fd, 1);
}
  80f8aa:	c9                   	leave  
  80f8ab:	c3                   	ret    
		return fd_close(fd, 1);
  80f8ac:	83 ec 08             	sub    $0x8,%esp
  80f8af:	6a 01                	push   $0x1
  80f8b1:	ff 75 f4             	pushl  -0xc(%ebp)
  80f8b4:	e8 51 ff ff ff       	call   80f80a <fd_close>
  80f8b9:	83 c4 10             	add    $0x10,%esp
  80f8bc:	eb ec                	jmp    80f8aa <close+0x19>

0080f8be <close_all>:

void
close_all(void)
{
  80f8be:	55                   	push   %ebp
  80f8bf:	89 e5                	mov    %esp,%ebp
  80f8c1:	53                   	push   %ebx
  80f8c2:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80f8c5:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80f8ca:	83 ec 0c             	sub    $0xc,%esp
  80f8cd:	53                   	push   %ebx
  80f8ce:	e8 be ff ff ff       	call   80f891 <close>
	for (i = 0; i < MAXFD; i++)
  80f8d3:	83 c3 01             	add    $0x1,%ebx
  80f8d6:	83 c4 10             	add    $0x10,%esp
  80f8d9:	83 fb 20             	cmp    $0x20,%ebx
  80f8dc:	75 ec                	jne    80f8ca <close_all+0xc>
}
  80f8de:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f8e1:	c9                   	leave  
  80f8e2:	c3                   	ret    

0080f8e3 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80f8e3:	55                   	push   %ebp
  80f8e4:	89 e5                	mov    %esp,%ebp
  80f8e6:	57                   	push   %edi
  80f8e7:	56                   	push   %esi
  80f8e8:	53                   	push   %ebx
  80f8e9:	83 ec 24             	sub    $0x24,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80f8ec:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f8ef:	50                   	push   %eax
  80f8f0:	ff 75 08             	pushl  0x8(%ebp)
  80f8f3:	e8 67 fe ff ff       	call   80f75f <fd_lookup>
  80f8f8:	89 c3                	mov    %eax,%ebx
  80f8fa:	83 c4 10             	add    $0x10,%esp
  80f8fd:	85 c0                	test   %eax,%eax
  80f8ff:	0f 88 81 00 00 00    	js     80f986 <dup+0xa3>
		return r;
	close(newfdnum);
  80f905:	83 ec 0c             	sub    $0xc,%esp
  80f908:	ff 75 0c             	pushl  0xc(%ebp)
  80f90b:	e8 81 ff ff ff       	call   80f891 <close>

	newfd = INDEX2FD(newfdnum);
  80f910:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f913:	c1 e6 0c             	shl    $0xc,%esi
  80f916:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80f91c:	83 c4 04             	add    $0x4,%esp
  80f91f:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f922:	e8 cf fd ff ff       	call   80f6f6 <fd2data>
  80f927:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80f929:	89 34 24             	mov    %esi,(%esp)
  80f92c:	e8 c5 fd ff ff       	call   80f6f6 <fd2data>
  80f931:	83 c4 10             	add    $0x10,%esp
  80f934:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80f936:	89 d8                	mov    %ebx,%eax
  80f938:	c1 e8 16             	shr    $0x16,%eax
  80f93b:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f942:	a8 01                	test   $0x1,%al
  80f944:	74 11                	je     80f957 <dup+0x74>
  80f946:	89 d8                	mov    %ebx,%eax
  80f948:	c1 e8 0c             	shr    $0xc,%eax
  80f94b:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f952:	f6 c2 01             	test   $0x1,%dl
  80f955:	75 39                	jne    80f990 <dup+0xad>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f957:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f95a:	89 d0                	mov    %edx,%eax
  80f95c:	c1 e8 0c             	shr    $0xc,%eax
  80f95f:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f966:	83 ec 0c             	sub    $0xc,%esp
  80f969:	25 07 0e 00 00       	and    $0xe07,%eax
  80f96e:	50                   	push   %eax
  80f96f:	56                   	push   %esi
  80f970:	6a 00                	push   $0x0
  80f972:	52                   	push   %edx
  80f973:	6a 00                	push   $0x0
  80f975:	e8 e2 f6 ff ff       	call   80f05c <sys_page_map>
  80f97a:	89 c3                	mov    %eax,%ebx
  80f97c:	83 c4 20             	add    $0x20,%esp
  80f97f:	85 c0                	test   %eax,%eax
  80f981:	78 31                	js     80f9b4 <dup+0xd1>
		goto err;

	return newfdnum;
  80f983:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80f986:	89 d8                	mov    %ebx,%eax
  80f988:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f98b:	5b                   	pop    %ebx
  80f98c:	5e                   	pop    %esi
  80f98d:	5f                   	pop    %edi
  80f98e:	5d                   	pop    %ebp
  80f98f:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80f990:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f997:	83 ec 0c             	sub    $0xc,%esp
  80f99a:	25 07 0e 00 00       	and    $0xe07,%eax
  80f99f:	50                   	push   %eax
  80f9a0:	57                   	push   %edi
  80f9a1:	6a 00                	push   $0x0
  80f9a3:	53                   	push   %ebx
  80f9a4:	6a 00                	push   $0x0
  80f9a6:	e8 b1 f6 ff ff       	call   80f05c <sys_page_map>
  80f9ab:	89 c3                	mov    %eax,%ebx
  80f9ad:	83 c4 20             	add    $0x20,%esp
  80f9b0:	85 c0                	test   %eax,%eax
  80f9b2:	79 a3                	jns    80f957 <dup+0x74>
	sys_page_unmap(0, newfd);
  80f9b4:	83 ec 08             	sub    $0x8,%esp
  80f9b7:	56                   	push   %esi
  80f9b8:	6a 00                	push   $0x0
  80f9ba:	e8 df f6 ff ff       	call   80f09e <sys_page_unmap>
	sys_page_unmap(0, nva);
  80f9bf:	83 c4 08             	add    $0x8,%esp
  80f9c2:	57                   	push   %edi
  80f9c3:	6a 00                	push   $0x0
  80f9c5:	e8 d4 f6 ff ff       	call   80f09e <sys_page_unmap>
	return r;
  80f9ca:	83 c4 10             	add    $0x10,%esp
  80f9cd:	eb b7                	jmp    80f986 <dup+0xa3>

0080f9cf <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80f9cf:	55                   	push   %ebp
  80f9d0:	89 e5                	mov    %esp,%ebp
  80f9d2:	53                   	push   %ebx
  80f9d3:	83 ec 1c             	sub    $0x1c,%esp
  80f9d6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f9d9:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f9dc:	50                   	push   %eax
  80f9dd:	53                   	push   %ebx
  80f9de:	e8 7c fd ff ff       	call   80f75f <fd_lookup>
  80f9e3:	83 c4 10             	add    $0x10,%esp
  80f9e6:	85 c0                	test   %eax,%eax
  80f9e8:	78 3f                	js     80fa29 <read+0x5a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f9ea:	83 ec 08             	sub    $0x8,%esp
  80f9ed:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f9f0:	50                   	push   %eax
  80f9f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f9f4:	ff 30                	pushl  (%eax)
  80f9f6:	e8 b4 fd ff ff       	call   80f7af <dev_lookup>
  80f9fb:	83 c4 10             	add    $0x10,%esp
  80f9fe:	85 c0                	test   %eax,%eax
  80fa00:	78 27                	js     80fa29 <read+0x5a>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80fa02:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80fa05:	8b 42 08             	mov    0x8(%edx),%eax
  80fa08:	83 e0 03             	and    $0x3,%eax
  80fa0b:	83 f8 01             	cmp    $0x1,%eax
  80fa0e:	74 1e                	je     80fa2e <read+0x5f>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80fa10:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fa13:	8b 40 08             	mov    0x8(%eax),%eax
  80fa16:	85 c0                	test   %eax,%eax
  80fa18:	74 35                	je     80fa4f <read+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80fa1a:	83 ec 04             	sub    $0x4,%esp
  80fa1d:	ff 75 10             	pushl  0x10(%ebp)
  80fa20:	ff 75 0c             	pushl  0xc(%ebp)
  80fa23:	52                   	push   %edx
  80fa24:	ff d0                	call   *%eax
  80fa26:	83 c4 10             	add    $0x10,%esp
}
  80fa29:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fa2c:	c9                   	leave  
  80fa2d:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80fa2e:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fa33:	8b 40 48             	mov    0x48(%eax),%eax
  80fa36:	83 ec 04             	sub    $0x4,%esp
  80fa39:	53                   	push   %ebx
  80fa3a:	50                   	push   %eax
  80fa3b:	68 f5 38 81 00       	push   $0x8138f5
  80fa40:	e8 06 ec ff ff       	call   80e64b <cprintf>
		return -E_INVAL;
  80fa45:	83 c4 10             	add    $0x10,%esp
  80fa48:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fa4d:	eb da                	jmp    80fa29 <read+0x5a>
		return -E_NOT_SUPP;
  80fa4f:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fa54:	eb d3                	jmp    80fa29 <read+0x5a>

0080fa56 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80fa56:	55                   	push   %ebp
  80fa57:	89 e5                	mov    %esp,%ebp
  80fa59:	57                   	push   %edi
  80fa5a:	56                   	push   %esi
  80fa5b:	53                   	push   %ebx
  80fa5c:	83 ec 0c             	sub    $0xc,%esp
  80fa5f:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fa62:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80fa65:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fa6a:	39 f3                	cmp    %esi,%ebx
  80fa6c:	73 23                	jae    80fa91 <readn+0x3b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fa6e:	83 ec 04             	sub    $0x4,%esp
  80fa71:	89 f0                	mov    %esi,%eax
  80fa73:	29 d8                	sub    %ebx,%eax
  80fa75:	50                   	push   %eax
  80fa76:	89 d8                	mov    %ebx,%eax
  80fa78:	03 45 0c             	add    0xc(%ebp),%eax
  80fa7b:	50                   	push   %eax
  80fa7c:	57                   	push   %edi
  80fa7d:	e8 4d ff ff ff       	call   80f9cf <read>
		if (m < 0)
  80fa82:	83 c4 10             	add    $0x10,%esp
  80fa85:	85 c0                	test   %eax,%eax
  80fa87:	78 06                	js     80fa8f <readn+0x39>
			return m;
		if (m == 0)
  80fa89:	74 06                	je     80fa91 <readn+0x3b>
	for (tot = 0; tot < n; tot += m) {
  80fa8b:	01 c3                	add    %eax,%ebx
  80fa8d:	eb db                	jmp    80fa6a <readn+0x14>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fa8f:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  80fa91:	89 d8                	mov    %ebx,%eax
  80fa93:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fa96:	5b                   	pop    %ebx
  80fa97:	5e                   	pop    %esi
  80fa98:	5f                   	pop    %edi
  80fa99:	5d                   	pop    %ebp
  80fa9a:	c3                   	ret    

0080fa9b <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80fa9b:	55                   	push   %ebp
  80fa9c:	89 e5                	mov    %esp,%ebp
  80fa9e:	53                   	push   %ebx
  80fa9f:	83 ec 1c             	sub    $0x1c,%esp
  80faa2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80faa5:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80faa8:	50                   	push   %eax
  80faa9:	53                   	push   %ebx
  80faaa:	e8 b0 fc ff ff       	call   80f75f <fd_lookup>
  80faaf:	83 c4 10             	add    $0x10,%esp
  80fab2:	85 c0                	test   %eax,%eax
  80fab4:	78 3a                	js     80faf0 <write+0x55>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fab6:	83 ec 08             	sub    $0x8,%esp
  80fab9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fabc:	50                   	push   %eax
  80fabd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fac0:	ff 30                	pushl  (%eax)
  80fac2:	e8 e8 fc ff ff       	call   80f7af <dev_lookup>
  80fac7:	83 c4 10             	add    $0x10,%esp
  80faca:	85 c0                	test   %eax,%eax
  80facc:	78 22                	js     80faf0 <write+0x55>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80face:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fad1:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80fad5:	74 1e                	je     80faf5 <write+0x5a>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80fad7:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fada:	8b 52 0c             	mov    0xc(%edx),%edx
  80fadd:	85 d2                	test   %edx,%edx
  80fadf:	74 35                	je     80fb16 <write+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80fae1:	83 ec 04             	sub    $0x4,%esp
  80fae4:	ff 75 10             	pushl  0x10(%ebp)
  80fae7:	ff 75 0c             	pushl  0xc(%ebp)
  80faea:	50                   	push   %eax
  80faeb:	ff d2                	call   *%edx
  80faed:	83 c4 10             	add    $0x10,%esp
}
  80faf0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80faf3:	c9                   	leave  
  80faf4:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80faf5:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fafa:	8b 40 48             	mov    0x48(%eax),%eax
  80fafd:	83 ec 04             	sub    $0x4,%esp
  80fb00:	53                   	push   %ebx
  80fb01:	50                   	push   %eax
  80fb02:	68 11 39 81 00       	push   $0x813911
  80fb07:	e8 3f eb ff ff       	call   80e64b <cprintf>
		return -E_INVAL;
  80fb0c:	83 c4 10             	add    $0x10,%esp
  80fb0f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fb14:	eb da                	jmp    80faf0 <write+0x55>
		return -E_NOT_SUPP;
  80fb16:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fb1b:	eb d3                	jmp    80faf0 <write+0x55>

0080fb1d <seek>:

int
seek(int fdnum, off_t offset)
{
  80fb1d:	55                   	push   %ebp
  80fb1e:	89 e5                	mov    %esp,%ebp
  80fb20:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fb23:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fb26:	50                   	push   %eax
  80fb27:	ff 75 08             	pushl  0x8(%ebp)
  80fb2a:	e8 30 fc ff ff       	call   80f75f <fd_lookup>
  80fb2f:	83 c4 10             	add    $0x10,%esp
  80fb32:	85 c0                	test   %eax,%eax
  80fb34:	78 0e                	js     80fb44 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80fb36:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fb39:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fb3c:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80fb3f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fb44:	c9                   	leave  
  80fb45:	c3                   	ret    

0080fb46 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80fb46:	55                   	push   %ebp
  80fb47:	89 e5                	mov    %esp,%ebp
  80fb49:	53                   	push   %ebx
  80fb4a:	83 ec 1c             	sub    $0x1c,%esp
  80fb4d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fb50:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fb53:	50                   	push   %eax
  80fb54:	53                   	push   %ebx
  80fb55:	e8 05 fc ff ff       	call   80f75f <fd_lookup>
  80fb5a:	83 c4 10             	add    $0x10,%esp
  80fb5d:	85 c0                	test   %eax,%eax
  80fb5f:	78 37                	js     80fb98 <ftruncate+0x52>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fb61:	83 ec 08             	sub    $0x8,%esp
  80fb64:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fb67:	50                   	push   %eax
  80fb68:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fb6b:	ff 30                	pushl  (%eax)
  80fb6d:	e8 3d fc ff ff       	call   80f7af <dev_lookup>
  80fb72:	83 c4 10             	add    $0x10,%esp
  80fb75:	85 c0                	test   %eax,%eax
  80fb77:	78 1f                	js     80fb98 <ftruncate+0x52>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80fb79:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fb7c:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80fb80:	74 1b                	je     80fb9d <ftruncate+0x57>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  80fb82:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fb85:	8b 52 18             	mov    0x18(%edx),%edx
  80fb88:	85 d2                	test   %edx,%edx
  80fb8a:	74 32                	je     80fbbe <ftruncate+0x78>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80fb8c:	83 ec 08             	sub    $0x8,%esp
  80fb8f:	ff 75 0c             	pushl  0xc(%ebp)
  80fb92:	50                   	push   %eax
  80fb93:	ff d2                	call   *%edx
  80fb95:	83 c4 10             	add    $0x10,%esp
}
  80fb98:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fb9b:	c9                   	leave  
  80fb9c:	c3                   	ret    
			thisenv->env_id, fdnum);
  80fb9d:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80fba2:	8b 40 48             	mov    0x48(%eax),%eax
  80fba5:	83 ec 04             	sub    $0x4,%esp
  80fba8:	53                   	push   %ebx
  80fba9:	50                   	push   %eax
  80fbaa:	68 d4 38 81 00       	push   $0x8138d4
  80fbaf:	e8 97 ea ff ff       	call   80e64b <cprintf>
		return -E_INVAL;
  80fbb4:	83 c4 10             	add    $0x10,%esp
  80fbb7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fbbc:	eb da                	jmp    80fb98 <ftruncate+0x52>
		return -E_NOT_SUPP;
  80fbbe:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fbc3:	eb d3                	jmp    80fb98 <ftruncate+0x52>

0080fbc5 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80fbc5:	55                   	push   %ebp
  80fbc6:	89 e5                	mov    %esp,%ebp
  80fbc8:	53                   	push   %ebx
  80fbc9:	83 ec 1c             	sub    $0x1c,%esp
  80fbcc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fbcf:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fbd2:	50                   	push   %eax
  80fbd3:	ff 75 08             	pushl  0x8(%ebp)
  80fbd6:	e8 84 fb ff ff       	call   80f75f <fd_lookup>
  80fbdb:	83 c4 10             	add    $0x10,%esp
  80fbde:	85 c0                	test   %eax,%eax
  80fbe0:	78 4b                	js     80fc2d <fstat+0x68>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fbe2:	83 ec 08             	sub    $0x8,%esp
  80fbe5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fbe8:	50                   	push   %eax
  80fbe9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fbec:	ff 30                	pushl  (%eax)
  80fbee:	e8 bc fb ff ff       	call   80f7af <dev_lookup>
  80fbf3:	83 c4 10             	add    $0x10,%esp
  80fbf6:	85 c0                	test   %eax,%eax
  80fbf8:	78 33                	js     80fc2d <fstat+0x68>
		return r;
	if (!dev->dev_stat)
  80fbfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fbfd:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80fc01:	74 2f                	je     80fc32 <fstat+0x6d>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80fc03:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80fc06:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80fc0d:	00 00 00 
	stat->st_isdir = 0;
  80fc10:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80fc17:	00 00 00 
	stat->st_dev = dev;
  80fc1a:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80fc20:	83 ec 08             	sub    $0x8,%esp
  80fc23:	53                   	push   %ebx
  80fc24:	ff 75 f0             	pushl  -0x10(%ebp)
  80fc27:	ff 50 14             	call   *0x14(%eax)
  80fc2a:	83 c4 10             	add    $0x10,%esp
}
  80fc2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fc30:	c9                   	leave  
  80fc31:	c3                   	ret    
		return -E_NOT_SUPP;
  80fc32:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fc37:	eb f4                	jmp    80fc2d <fstat+0x68>

0080fc39 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80fc39:	55                   	push   %ebp
  80fc3a:	89 e5                	mov    %esp,%ebp
  80fc3c:	56                   	push   %esi
  80fc3d:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80fc3e:	83 ec 08             	sub    $0x8,%esp
  80fc41:	6a 00                	push   $0x0
  80fc43:	ff 75 08             	pushl  0x8(%ebp)
  80fc46:	e8 2f 02 00 00       	call   80fe7a <open>
  80fc4b:	89 c3                	mov    %eax,%ebx
  80fc4d:	83 c4 10             	add    $0x10,%esp
  80fc50:	85 c0                	test   %eax,%eax
  80fc52:	78 1b                	js     80fc6f <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  80fc54:	83 ec 08             	sub    $0x8,%esp
  80fc57:	ff 75 0c             	pushl  0xc(%ebp)
  80fc5a:	50                   	push   %eax
  80fc5b:	e8 65 ff ff ff       	call   80fbc5 <fstat>
  80fc60:	89 c6                	mov    %eax,%esi
	close(fd);
  80fc62:	89 1c 24             	mov    %ebx,(%esp)
  80fc65:	e8 27 fc ff ff       	call   80f891 <close>
	return r;
  80fc6a:	83 c4 10             	add    $0x10,%esp
  80fc6d:	89 f3                	mov    %esi,%ebx
}
  80fc6f:	89 d8                	mov    %ebx,%eax
  80fc71:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fc74:	5b                   	pop    %ebx
  80fc75:	5e                   	pop    %esi
  80fc76:	5d                   	pop    %ebp
  80fc77:	c3                   	ret    

0080fc78 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80fc78:	55                   	push   %ebp
  80fc79:	89 e5                	mov    %esp,%ebp
  80fc7b:	56                   	push   %esi
  80fc7c:	53                   	push   %ebx
  80fc7d:	89 c6                	mov    %eax,%esi
  80fc7f:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80fc81:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  80fc88:	74 27                	je     80fcb1 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80fc8a:	6a 07                	push   $0x7
  80fc8c:	68 00 c0 b3 00       	push   $0xb3c000
  80fc91:	56                   	push   %esi
  80fc92:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  80fc98:	e8 a4 f9 ff ff       	call   80f641 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80fc9d:	83 c4 0c             	add    $0xc,%esp
  80fca0:	6a 00                	push   $0x0
  80fca2:	53                   	push   %ebx
  80fca3:	6a 00                	push   $0x0
  80fca5:	e8 24 f9 ff ff       	call   80f5ce <ipc_recv>
}
  80fcaa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fcad:	5b                   	pop    %ebx
  80fcae:	5e                   	pop    %esi
  80fcaf:	5d                   	pop    %ebp
  80fcb0:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80fcb1:	83 ec 0c             	sub    $0xc,%esp
  80fcb4:	6a 01                	push   $0x1
  80fcb6:	e8 f2 f9 ff ff       	call   80f6ad <ipc_find_env>
  80fcbb:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  80fcc0:	83 c4 10             	add    $0x10,%esp
  80fcc3:	eb c5                	jmp    80fc8a <fsipc+0x12>

0080fcc5 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80fcc5:	55                   	push   %ebp
  80fcc6:	89 e5                	mov    %esp,%ebp
  80fcc8:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80fccb:	8b 45 08             	mov    0x8(%ebp),%eax
  80fcce:	8b 40 0c             	mov    0xc(%eax),%eax
  80fcd1:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80fcd6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fcd9:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80fcde:	ba 00 00 00 00       	mov    $0x0,%edx
  80fce3:	b8 02 00 00 00       	mov    $0x2,%eax
  80fce8:	e8 8b ff ff ff       	call   80fc78 <fsipc>
}
  80fced:	c9                   	leave  
  80fcee:	c3                   	ret    

0080fcef <devfile_flush>:
{
  80fcef:	55                   	push   %ebp
  80fcf0:	89 e5                	mov    %esp,%ebp
  80fcf2:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80fcf5:	8b 45 08             	mov    0x8(%ebp),%eax
  80fcf8:	8b 40 0c             	mov    0xc(%eax),%eax
  80fcfb:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  80fd00:	ba 00 00 00 00       	mov    $0x0,%edx
  80fd05:	b8 06 00 00 00       	mov    $0x6,%eax
  80fd0a:	e8 69 ff ff ff       	call   80fc78 <fsipc>
}
  80fd0f:	c9                   	leave  
  80fd10:	c3                   	ret    

0080fd11 <devfile_stat>:
{
  80fd11:	55                   	push   %ebp
  80fd12:	89 e5                	mov    %esp,%ebp
  80fd14:	53                   	push   %ebx
  80fd15:	83 ec 04             	sub    $0x4,%esp
  80fd18:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80fd1b:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd1e:	8b 40 0c             	mov    0xc(%eax),%eax
  80fd21:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80fd26:	ba 00 00 00 00       	mov    $0x0,%edx
  80fd2b:	b8 05 00 00 00       	mov    $0x5,%eax
  80fd30:	e8 43 ff ff ff       	call   80fc78 <fsipc>
  80fd35:	85 c0                	test   %eax,%eax
  80fd37:	78 2c                	js     80fd65 <devfile_stat+0x54>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80fd39:	83 ec 08             	sub    $0x8,%esp
  80fd3c:	68 00 c0 b3 00       	push   $0xb3c000
  80fd41:	53                   	push   %ebx
  80fd42:	e8 e0 ee ff ff       	call   80ec27 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  80fd47:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  80fd4c:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80fd52:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  80fd57:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  80fd5d:	83 c4 10             	add    $0x10,%esp
  80fd60:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fd65:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd68:	c9                   	leave  
  80fd69:	c3                   	ret    

0080fd6a <devfile_write>:
{
  80fd6a:	55                   	push   %ebp
  80fd6b:	89 e5                	mov    %esp,%ebp
  80fd6d:	53                   	push   %ebx
  80fd6e:	83 ec 04             	sub    $0x4,%esp
  80fd71:	8b 5d 10             	mov    0x10(%ebp),%ebx
  if (n_left > 0) {
  80fd74:	85 db                	test   %ebx,%ebx
  80fd76:	75 07                	jne    80fd7f <devfile_write+0x15>
	return n_all;
  80fd78:	89 d8                	mov    %ebx,%eax
}
  80fd7a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd7d:	c9                   	leave  
  80fd7e:	c3                   	ret    
	  fsipcbuf.write.req_fileid = fd->fd_file.id;
  80fd7f:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd82:	8b 40 0c             	mov    0xc(%eax),%eax
  80fd85:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	  fsipcbuf.write.req_n = n_left;
  80fd8a:	89 1d 04 c0 b3 00    	mov    %ebx,0xb3c004
    memmove(fsipcbuf.write.req_buf, buf, n);
  80fd90:	83 ec 04             	sub    $0x4,%esp
  80fd93:	53                   	push   %ebx
  80fd94:	ff 75 0c             	pushl  0xc(%ebp)
  80fd97:	68 08 c0 b3 00       	push   $0xb3c008
  80fd9c:	e8 14 f0 ff ff       	call   80edb5 <memmove>
	  if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  80fda1:	ba 00 00 00 00       	mov    $0x0,%edx
  80fda6:	b8 04 00 00 00       	mov    $0x4,%eax
  80fdab:	e8 c8 fe ff ff       	call   80fc78 <fsipc>
  80fdb0:	83 c4 10             	add    $0x10,%esp
  80fdb3:	85 c0                	test   %eax,%eax
  80fdb5:	78 c3                	js     80fd7a <devfile_write+0x10>
	  assert(r <= n_left);
  80fdb7:	39 d8                	cmp    %ebx,%eax
  80fdb9:	77 0b                	ja     80fdc6 <devfile_write+0x5c>
	  assert(r <= PGSIZE);
  80fdbb:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80fdc0:	7f 1d                	jg     80fddf <devfile_write+0x75>
    n_all += r;
  80fdc2:	89 c3                	mov    %eax,%ebx
  80fdc4:	eb b2                	jmp    80fd78 <devfile_write+0xe>
	  assert(r <= n_left);
  80fdc6:	68 44 39 81 00       	push   $0x813944
  80fdcb:	68 ab 25 81 00       	push   $0x8125ab
  80fdd0:	68 9f 00 00 00       	push   $0x9f
  80fdd5:	68 50 39 81 00       	push   $0x813950
  80fdda:	e8 91 e7 ff ff       	call   80e570 <_panic>
	  assert(r <= PGSIZE);
  80fddf:	68 5b 39 81 00       	push   $0x81395b
  80fde4:	68 ab 25 81 00       	push   $0x8125ab
  80fde9:	68 a0 00 00 00       	push   $0xa0
  80fdee:	68 50 39 81 00       	push   $0x813950
  80fdf3:	e8 78 e7 ff ff       	call   80e570 <_panic>

0080fdf8 <devfile_read>:
{
  80fdf8:	55                   	push   %ebp
  80fdf9:	89 e5                	mov    %esp,%ebp
  80fdfb:	56                   	push   %esi
  80fdfc:	53                   	push   %ebx
  80fdfd:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80fe00:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe03:	8b 40 0c             	mov    0xc(%eax),%eax
  80fe06:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  80fe0b:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80fe11:	ba 00 00 00 00       	mov    $0x0,%edx
  80fe16:	b8 03 00 00 00       	mov    $0x3,%eax
  80fe1b:	e8 58 fe ff ff       	call   80fc78 <fsipc>
  80fe20:	89 c3                	mov    %eax,%ebx
  80fe22:	85 c0                	test   %eax,%eax
  80fe24:	78 1f                	js     80fe45 <devfile_read+0x4d>
	assert(r <= n);
  80fe26:	39 f0                	cmp    %esi,%eax
  80fe28:	77 24                	ja     80fe4e <devfile_read+0x56>
	assert(r <= PGSIZE);
  80fe2a:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80fe2f:	7f 33                	jg     80fe64 <devfile_read+0x6c>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80fe31:	83 ec 04             	sub    $0x4,%esp
  80fe34:	50                   	push   %eax
  80fe35:	68 00 c0 b3 00       	push   $0xb3c000
  80fe3a:	ff 75 0c             	pushl  0xc(%ebp)
  80fe3d:	e8 73 ef ff ff       	call   80edb5 <memmove>
	return r;
  80fe42:	83 c4 10             	add    $0x10,%esp
}
  80fe45:	89 d8                	mov    %ebx,%eax
  80fe47:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fe4a:	5b                   	pop    %ebx
  80fe4b:	5e                   	pop    %esi
  80fe4c:	5d                   	pop    %ebp
  80fe4d:	c3                   	ret    
	assert(r <= n);
  80fe4e:	68 67 39 81 00       	push   $0x813967
  80fe53:	68 ab 25 81 00       	push   $0x8125ab
  80fe58:	6a 7c                	push   $0x7c
  80fe5a:	68 50 39 81 00       	push   $0x813950
  80fe5f:	e8 0c e7 ff ff       	call   80e570 <_panic>
	assert(r <= PGSIZE);
  80fe64:	68 5b 39 81 00       	push   $0x81395b
  80fe69:	68 ab 25 81 00       	push   $0x8125ab
  80fe6e:	6a 7d                	push   $0x7d
  80fe70:	68 50 39 81 00       	push   $0x813950
  80fe75:	e8 f6 e6 ff ff       	call   80e570 <_panic>

0080fe7a <open>:
{
  80fe7a:	55                   	push   %ebp
  80fe7b:	89 e5                	mov    %esp,%ebp
  80fe7d:	56                   	push   %esi
  80fe7e:	53                   	push   %ebx
  80fe7f:	83 ec 1c             	sub    $0x1c,%esp
  80fe82:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  80fe85:	56                   	push   %esi
  80fe86:	e8 63 ed ff ff       	call   80ebee <strlen>
  80fe8b:	83 c4 10             	add    $0x10,%esp
  80fe8e:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80fe93:	7f 6c                	jg     80ff01 <open+0x87>
	if ((r = fd_alloc(&fd)) < 0)
  80fe95:	83 ec 0c             	sub    $0xc,%esp
  80fe98:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fe9b:	50                   	push   %eax
  80fe9c:	e8 6c f8 ff ff       	call   80f70d <fd_alloc>
  80fea1:	89 c3                	mov    %eax,%ebx
  80fea3:	83 c4 10             	add    $0x10,%esp
  80fea6:	85 c0                	test   %eax,%eax
  80fea8:	78 3c                	js     80fee6 <open+0x6c>
	strcpy(fsipcbuf.open.req_path, path);
  80feaa:	83 ec 08             	sub    $0x8,%esp
  80fead:	56                   	push   %esi
  80feae:	68 00 c0 b3 00       	push   $0xb3c000
  80feb3:	e8 6f ed ff ff       	call   80ec27 <strcpy>
	fsipcbuf.open.req_omode = mode;
  80feb8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80febb:	a3 00 c4 b3 00       	mov    %eax,0xb3c400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  80fec0:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fec3:	b8 01 00 00 00       	mov    $0x1,%eax
  80fec8:	e8 ab fd ff ff       	call   80fc78 <fsipc>
  80fecd:	89 c3                	mov    %eax,%ebx
  80fecf:	83 c4 10             	add    $0x10,%esp
  80fed2:	85 c0                	test   %eax,%eax
  80fed4:	78 19                	js     80feef <open+0x75>
	return fd2num(fd);
  80fed6:	83 ec 0c             	sub    $0xc,%esp
  80fed9:	ff 75 f4             	pushl  -0xc(%ebp)
  80fedc:	e8 05 f8 ff ff       	call   80f6e6 <fd2num>
  80fee1:	89 c3                	mov    %eax,%ebx
  80fee3:	83 c4 10             	add    $0x10,%esp
}
  80fee6:	89 d8                	mov    %ebx,%eax
  80fee8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80feeb:	5b                   	pop    %ebx
  80feec:	5e                   	pop    %esi
  80feed:	5d                   	pop    %ebp
  80feee:	c3                   	ret    
		fd_close(fd, 0);
  80feef:	83 ec 08             	sub    $0x8,%esp
  80fef2:	6a 00                	push   $0x0
  80fef4:	ff 75 f4             	pushl  -0xc(%ebp)
  80fef7:	e8 0e f9 ff ff       	call   80f80a <fd_close>
		return r;
  80fefc:	83 c4 10             	add    $0x10,%esp
  80feff:	eb e5                	jmp    80fee6 <open+0x6c>
		return -E_BAD_PATH;
  80ff01:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  80ff06:	eb de                	jmp    80fee6 <open+0x6c>

0080ff08 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  80ff08:	55                   	push   %ebp
  80ff09:	89 e5                	mov    %esp,%ebp
  80ff0b:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  80ff0e:	ba 00 00 00 00       	mov    $0x0,%edx
  80ff13:	b8 08 00 00 00       	mov    $0x8,%eax
  80ff18:	e8 5b fd ff ff       	call   80fc78 <fsipc>
}
  80ff1d:	c9                   	leave  
  80ff1e:	c3                   	ret    

0080ff1f <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  80ff1f:	55                   	push   %ebp
  80ff20:	89 e5                	mov    %esp,%ebp
  80ff22:	56                   	push   %esi
  80ff23:	53                   	push   %ebx
  80ff24:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  80ff27:	83 ec 0c             	sub    $0xc,%esp
  80ff2a:	ff 75 08             	pushl  0x8(%ebp)
  80ff2d:	e8 c4 f7 ff ff       	call   80f6f6 <fd2data>
  80ff32:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  80ff34:	83 c4 08             	add    $0x8,%esp
  80ff37:	68 6e 39 81 00       	push   $0x81396e
  80ff3c:	53                   	push   %ebx
  80ff3d:	e8 e5 ec ff ff       	call   80ec27 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  80ff42:	8b 46 04             	mov    0x4(%esi),%eax
  80ff45:	2b 06                	sub    (%esi),%eax
  80ff47:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  80ff4d:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80ff54:	00 00 00 
	stat->st_dev = &devpipe;
  80ff57:	c7 83 88 00 00 00 08 	movl   $0x814308,0x88(%ebx)
  80ff5e:	43 81 00 
	return 0;
}
  80ff61:	b8 00 00 00 00       	mov    $0x0,%eax
  80ff66:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ff69:	5b                   	pop    %ebx
  80ff6a:	5e                   	pop    %esi
  80ff6b:	5d                   	pop    %ebp
  80ff6c:	c3                   	ret    

0080ff6d <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  80ff6d:	55                   	push   %ebp
  80ff6e:	89 e5                	mov    %esp,%ebp
  80ff70:	53                   	push   %ebx
  80ff71:	83 ec 0c             	sub    $0xc,%esp
  80ff74:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  80ff77:	53                   	push   %ebx
  80ff78:	6a 00                	push   $0x0
  80ff7a:	e8 1f f1 ff ff       	call   80f09e <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  80ff7f:	89 1c 24             	mov    %ebx,(%esp)
  80ff82:	e8 6f f7 ff ff       	call   80f6f6 <fd2data>
  80ff87:	83 c4 08             	add    $0x8,%esp
  80ff8a:	50                   	push   %eax
  80ff8b:	6a 00                	push   $0x0
  80ff8d:	e8 0c f1 ff ff       	call   80f09e <sys_page_unmap>
}
  80ff92:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff95:	c9                   	leave  
  80ff96:	c3                   	ret    

0080ff97 <_pipeisclosed>:
{
  80ff97:	55                   	push   %ebp
  80ff98:	89 e5                	mov    %esp,%ebp
  80ff9a:	57                   	push   %edi
  80ff9b:	56                   	push   %esi
  80ff9c:	53                   	push   %ebx
  80ff9d:	83 ec 1c             	sub    $0x1c,%esp
  80ffa0:	89 c7                	mov    %eax,%edi
  80ffa2:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  80ffa4:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80ffa9:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  80ffac:	83 ec 0c             	sub    $0xc,%esp
  80ffaf:	57                   	push   %edi
  80ffb0:	e8 ce 0b 00 00       	call   810b83 <pageref>
  80ffb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ffb8:	89 34 24             	mov    %esi,(%esp)
  80ffbb:	e8 c3 0b 00 00       	call   810b83 <pageref>
		nn = thisenv->env_runs;
  80ffc0:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80ffc6:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  80ffc9:	83 c4 10             	add    $0x10,%esp
  80ffcc:	39 cb                	cmp    %ecx,%ebx
  80ffce:	74 1b                	je     80ffeb <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  80ffd0:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  80ffd3:	75 cf                	jne    80ffa4 <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  80ffd5:	8b 42 58             	mov    0x58(%edx),%eax
  80ffd8:	6a 01                	push   $0x1
  80ffda:	50                   	push   %eax
  80ffdb:	53                   	push   %ebx
  80ffdc:	68 75 39 81 00       	push   $0x813975
  80ffe1:	e8 65 e6 ff ff       	call   80e64b <cprintf>
  80ffe6:	83 c4 10             	add    $0x10,%esp
  80ffe9:	eb b9                	jmp    80ffa4 <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  80ffeb:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  80ffee:	0f 94 c0             	sete   %al
  80fff1:	0f b6 c0             	movzbl %al,%eax
}
  80fff4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fff7:	5b                   	pop    %ebx
  80fff8:	5e                   	pop    %esi
  80fff9:	5f                   	pop    %edi
  80fffa:	5d                   	pop    %ebp
  80fffb:	c3                   	ret    

0080fffc <devpipe_write>:
{
  80fffc:	55                   	push   %ebp
  80fffd:	89 e5                	mov    %esp,%ebp
  80ffff:	57                   	push   %edi
  810000:	56                   	push   %esi
  810001:	53                   	push   %ebx
  810002:	83 ec 28             	sub    $0x28,%esp
  810005:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810008:	56                   	push   %esi
  810009:	e8 e8 f6 ff ff       	call   80f6f6 <fd2data>
  81000e:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810010:	83 c4 10             	add    $0x10,%esp
  810013:	bf 00 00 00 00       	mov    $0x0,%edi
  810018:	3b 7d 10             	cmp    0x10(%ebp),%edi
  81001b:	74 4f                	je     81006c <devpipe_write+0x70>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  81001d:	8b 43 04             	mov    0x4(%ebx),%eax
  810020:	8b 0b                	mov    (%ebx),%ecx
  810022:	8d 51 20             	lea    0x20(%ecx),%edx
  810025:	39 d0                	cmp    %edx,%eax
  810027:	72 14                	jb     81003d <devpipe_write+0x41>
			if (_pipeisclosed(fd, p))
  810029:	89 da                	mov    %ebx,%edx
  81002b:	89 f0                	mov    %esi,%eax
  81002d:	e8 65 ff ff ff       	call   80ff97 <_pipeisclosed>
  810032:	85 c0                	test   %eax,%eax
  810034:	75 3b                	jne    810071 <devpipe_write+0x75>
			sys_yield();
  810036:	e8 bf ef ff ff       	call   80effa <sys_yield>
  81003b:	eb e0                	jmp    81001d <devpipe_write+0x21>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  81003d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810040:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810044:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810047:	89 c2                	mov    %eax,%edx
  810049:	c1 fa 1f             	sar    $0x1f,%edx
  81004c:	89 d1                	mov    %edx,%ecx
  81004e:	c1 e9 1b             	shr    $0x1b,%ecx
  810051:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810054:	83 e2 1f             	and    $0x1f,%edx
  810057:	29 ca                	sub    %ecx,%edx
  810059:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  81005d:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810061:	83 c0 01             	add    $0x1,%eax
  810064:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810067:	83 c7 01             	add    $0x1,%edi
  81006a:	eb ac                	jmp    810018 <devpipe_write+0x1c>
	return i;
  81006c:	8b 45 10             	mov    0x10(%ebp),%eax
  81006f:	eb 05                	jmp    810076 <devpipe_write+0x7a>
				return 0;
  810071:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810076:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810079:	5b                   	pop    %ebx
  81007a:	5e                   	pop    %esi
  81007b:	5f                   	pop    %edi
  81007c:	5d                   	pop    %ebp
  81007d:	c3                   	ret    

0081007e <devpipe_read>:
{
  81007e:	55                   	push   %ebp
  81007f:	89 e5                	mov    %esp,%ebp
  810081:	57                   	push   %edi
  810082:	56                   	push   %esi
  810083:	53                   	push   %ebx
  810084:	83 ec 18             	sub    $0x18,%esp
  810087:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  81008a:	57                   	push   %edi
  81008b:	e8 66 f6 ff ff       	call   80f6f6 <fd2data>
  810090:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810092:	83 c4 10             	add    $0x10,%esp
  810095:	be 00 00 00 00       	mov    $0x0,%esi
  81009a:	3b 75 10             	cmp    0x10(%ebp),%esi
  81009d:	75 14                	jne    8100b3 <devpipe_read+0x35>
	return i;
  81009f:	8b 45 10             	mov    0x10(%ebp),%eax
  8100a2:	eb 02                	jmp    8100a6 <devpipe_read+0x28>
				return i;
  8100a4:	89 f0                	mov    %esi,%eax
}
  8100a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8100a9:	5b                   	pop    %ebx
  8100aa:	5e                   	pop    %esi
  8100ab:	5f                   	pop    %edi
  8100ac:	5d                   	pop    %ebp
  8100ad:	c3                   	ret    
			sys_yield();
  8100ae:	e8 47 ef ff ff       	call   80effa <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  8100b3:	8b 03                	mov    (%ebx),%eax
  8100b5:	3b 43 04             	cmp    0x4(%ebx),%eax
  8100b8:	75 18                	jne    8100d2 <devpipe_read+0x54>
			if (i > 0)
  8100ba:	85 f6                	test   %esi,%esi
  8100bc:	75 e6                	jne    8100a4 <devpipe_read+0x26>
			if (_pipeisclosed(fd, p))
  8100be:	89 da                	mov    %ebx,%edx
  8100c0:	89 f8                	mov    %edi,%eax
  8100c2:	e8 d0 fe ff ff       	call   80ff97 <_pipeisclosed>
  8100c7:	85 c0                	test   %eax,%eax
  8100c9:	74 e3                	je     8100ae <devpipe_read+0x30>
				return 0;
  8100cb:	b8 00 00 00 00       	mov    $0x0,%eax
  8100d0:	eb d4                	jmp    8100a6 <devpipe_read+0x28>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8100d2:	99                   	cltd   
  8100d3:	c1 ea 1b             	shr    $0x1b,%edx
  8100d6:	01 d0                	add    %edx,%eax
  8100d8:	83 e0 1f             	and    $0x1f,%eax
  8100db:	29 d0                	sub    %edx,%eax
  8100dd:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  8100e2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8100e5:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  8100e8:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  8100eb:	83 c6 01             	add    $0x1,%esi
  8100ee:	eb aa                	jmp    81009a <devpipe_read+0x1c>

008100f0 <pipe>:
{
  8100f0:	55                   	push   %ebp
  8100f1:	89 e5                	mov    %esp,%ebp
  8100f3:	56                   	push   %esi
  8100f4:	53                   	push   %ebx
  8100f5:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  8100f8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8100fb:	50                   	push   %eax
  8100fc:	e8 0c f6 ff ff       	call   80f70d <fd_alloc>
  810101:	89 c3                	mov    %eax,%ebx
  810103:	83 c4 10             	add    $0x10,%esp
  810106:	85 c0                	test   %eax,%eax
  810108:	0f 88 23 01 00 00    	js     810231 <pipe+0x141>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81010e:	83 ec 04             	sub    $0x4,%esp
  810111:	68 07 04 00 00       	push   $0x407
  810116:	ff 75 f4             	pushl  -0xc(%ebp)
  810119:	6a 00                	push   $0x0
  81011b:	e8 f9 ee ff ff       	call   80f019 <sys_page_alloc>
  810120:	89 c3                	mov    %eax,%ebx
  810122:	83 c4 10             	add    $0x10,%esp
  810125:	85 c0                	test   %eax,%eax
  810127:	0f 88 04 01 00 00    	js     810231 <pipe+0x141>
	if ((r = fd_alloc(&fd1)) < 0
  81012d:	83 ec 0c             	sub    $0xc,%esp
  810130:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810133:	50                   	push   %eax
  810134:	e8 d4 f5 ff ff       	call   80f70d <fd_alloc>
  810139:	89 c3                	mov    %eax,%ebx
  81013b:	83 c4 10             	add    $0x10,%esp
  81013e:	85 c0                	test   %eax,%eax
  810140:	0f 88 db 00 00 00    	js     810221 <pipe+0x131>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810146:	83 ec 04             	sub    $0x4,%esp
  810149:	68 07 04 00 00       	push   $0x407
  81014e:	ff 75 f0             	pushl  -0x10(%ebp)
  810151:	6a 00                	push   $0x0
  810153:	e8 c1 ee ff ff       	call   80f019 <sys_page_alloc>
  810158:	89 c3                	mov    %eax,%ebx
  81015a:	83 c4 10             	add    $0x10,%esp
  81015d:	85 c0                	test   %eax,%eax
  81015f:	0f 88 bc 00 00 00    	js     810221 <pipe+0x131>
	va = fd2data(fd0);
  810165:	83 ec 0c             	sub    $0xc,%esp
  810168:	ff 75 f4             	pushl  -0xc(%ebp)
  81016b:	e8 86 f5 ff ff       	call   80f6f6 <fd2data>
  810170:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810172:	83 c4 0c             	add    $0xc,%esp
  810175:	68 07 04 00 00       	push   $0x407
  81017a:	50                   	push   %eax
  81017b:	6a 00                	push   $0x0
  81017d:	e8 97 ee ff ff       	call   80f019 <sys_page_alloc>
  810182:	89 c3                	mov    %eax,%ebx
  810184:	83 c4 10             	add    $0x10,%esp
  810187:	85 c0                	test   %eax,%eax
  810189:	0f 88 82 00 00 00    	js     810211 <pipe+0x121>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81018f:	83 ec 0c             	sub    $0xc,%esp
  810192:	ff 75 f0             	pushl  -0x10(%ebp)
  810195:	e8 5c f5 ff ff       	call   80f6f6 <fd2data>
  81019a:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  8101a1:	50                   	push   %eax
  8101a2:	6a 00                	push   $0x0
  8101a4:	56                   	push   %esi
  8101a5:	6a 00                	push   $0x0
  8101a7:	e8 b0 ee ff ff       	call   80f05c <sys_page_map>
  8101ac:	89 c3                	mov    %eax,%ebx
  8101ae:	83 c4 20             	add    $0x20,%esp
  8101b1:	85 c0                	test   %eax,%eax
  8101b3:	78 4e                	js     810203 <pipe+0x113>
	fd0->fd_dev_id = devpipe.dev_id;
  8101b5:	a1 08 43 81 00       	mov    0x814308,%eax
  8101ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8101bd:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  8101bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8101c2:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  8101c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8101cc:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  8101ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8101d1:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  8101d8:	83 ec 0c             	sub    $0xc,%esp
  8101db:	ff 75 f4             	pushl  -0xc(%ebp)
  8101de:	e8 03 f5 ff ff       	call   80f6e6 <fd2num>
  8101e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8101e6:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  8101e8:	83 c4 04             	add    $0x4,%esp
  8101eb:	ff 75 f0             	pushl  -0x10(%ebp)
  8101ee:	e8 f3 f4 ff ff       	call   80f6e6 <fd2num>
  8101f3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8101f6:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  8101f9:	83 c4 10             	add    $0x10,%esp
  8101fc:	bb 00 00 00 00       	mov    $0x0,%ebx
  810201:	eb 2e                	jmp    810231 <pipe+0x141>
	sys_page_unmap(0, va);
  810203:	83 ec 08             	sub    $0x8,%esp
  810206:	56                   	push   %esi
  810207:	6a 00                	push   $0x0
  810209:	e8 90 ee ff ff       	call   80f09e <sys_page_unmap>
  81020e:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810211:	83 ec 08             	sub    $0x8,%esp
  810214:	ff 75 f0             	pushl  -0x10(%ebp)
  810217:	6a 00                	push   $0x0
  810219:	e8 80 ee ff ff       	call   80f09e <sys_page_unmap>
  81021e:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810221:	83 ec 08             	sub    $0x8,%esp
  810224:	ff 75 f4             	pushl  -0xc(%ebp)
  810227:	6a 00                	push   $0x0
  810229:	e8 70 ee ff ff       	call   80f09e <sys_page_unmap>
  81022e:	83 c4 10             	add    $0x10,%esp
}
  810231:	89 d8                	mov    %ebx,%eax
  810233:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810236:	5b                   	pop    %ebx
  810237:	5e                   	pop    %esi
  810238:	5d                   	pop    %ebp
  810239:	c3                   	ret    

0081023a <pipeisclosed>:
{
  81023a:	55                   	push   %ebp
  81023b:	89 e5                	mov    %esp,%ebp
  81023d:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810240:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810243:	50                   	push   %eax
  810244:	ff 75 08             	pushl  0x8(%ebp)
  810247:	e8 13 f5 ff ff       	call   80f75f <fd_lookup>
  81024c:	83 c4 10             	add    $0x10,%esp
  81024f:	85 c0                	test   %eax,%eax
  810251:	78 18                	js     81026b <pipeisclosed+0x31>
	p = (struct Pipe*) fd2data(fd);
  810253:	83 ec 0c             	sub    $0xc,%esp
  810256:	ff 75 f4             	pushl  -0xc(%ebp)
  810259:	e8 98 f4 ff ff       	call   80f6f6 <fd2data>
	return _pipeisclosed(fd, p);
  81025e:	89 c2                	mov    %eax,%edx
  810260:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810263:	e8 2f fd ff ff       	call   80ff97 <_pipeisclosed>
  810268:	83 c4 10             	add    $0x10,%esp
}
  81026b:	c9                   	leave  
  81026c:	c3                   	ret    

0081026d <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  81026d:	55                   	push   %ebp
  81026e:	89 e5                	mov    %esp,%ebp
  810270:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  810273:	68 8d 39 81 00       	push   $0x81398d
  810278:	ff 75 0c             	pushl  0xc(%ebp)
  81027b:	e8 a7 e9 ff ff       	call   80ec27 <strcpy>
	return 0;
}
  810280:	b8 00 00 00 00       	mov    $0x0,%eax
  810285:	c9                   	leave  
  810286:	c3                   	ret    

00810287 <devsock_close>:
{
  810287:	55                   	push   %ebp
  810288:	89 e5                	mov    %esp,%ebp
  81028a:	53                   	push   %ebx
  81028b:	83 ec 10             	sub    $0x10,%esp
  81028e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  810291:	53                   	push   %ebx
  810292:	e8 ec 08 00 00       	call   810b83 <pageref>
  810297:	83 c4 10             	add    $0x10,%esp
		return 0;
  81029a:	ba 00 00 00 00       	mov    $0x0,%edx
	if (pageref(fd) == 1)
  81029f:	83 f8 01             	cmp    $0x1,%eax
  8102a2:	74 07                	je     8102ab <devsock_close+0x24>
}
  8102a4:	89 d0                	mov    %edx,%eax
  8102a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8102a9:	c9                   	leave  
  8102aa:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  8102ab:	83 ec 0c             	sub    $0xc,%esp
  8102ae:	ff 73 0c             	pushl  0xc(%ebx)
  8102b1:	e8 b9 02 00 00       	call   81056f <nsipc_close>
  8102b6:	89 c2                	mov    %eax,%edx
  8102b8:	83 c4 10             	add    $0x10,%esp
  8102bb:	eb e7                	jmp    8102a4 <devsock_close+0x1d>

008102bd <devsock_write>:
{
  8102bd:	55                   	push   %ebp
  8102be:	89 e5                	mov    %esp,%ebp
  8102c0:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  8102c3:	6a 00                	push   $0x0
  8102c5:	ff 75 10             	pushl  0x10(%ebp)
  8102c8:	ff 75 0c             	pushl  0xc(%ebp)
  8102cb:	8b 45 08             	mov    0x8(%ebp),%eax
  8102ce:	ff 70 0c             	pushl  0xc(%eax)
  8102d1:	e8 76 03 00 00       	call   81064c <nsipc_send>
}
  8102d6:	c9                   	leave  
  8102d7:	c3                   	ret    

008102d8 <devsock_read>:
{
  8102d8:	55                   	push   %ebp
  8102d9:	89 e5                	mov    %esp,%ebp
  8102db:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8102de:	6a 00                	push   $0x0
  8102e0:	ff 75 10             	pushl  0x10(%ebp)
  8102e3:	ff 75 0c             	pushl  0xc(%ebp)
  8102e6:	8b 45 08             	mov    0x8(%ebp),%eax
  8102e9:	ff 70 0c             	pushl  0xc(%eax)
  8102ec:	e8 ef 02 00 00       	call   8105e0 <nsipc_recv>
}
  8102f1:	c9                   	leave  
  8102f2:	c3                   	ret    

008102f3 <fd2sockid>:
{
  8102f3:	55                   	push   %ebp
  8102f4:	89 e5                	mov    %esp,%ebp
  8102f6:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  8102f9:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8102fc:	52                   	push   %edx
  8102fd:	50                   	push   %eax
  8102fe:	e8 5c f4 ff ff       	call   80f75f <fd_lookup>
  810303:	83 c4 10             	add    $0x10,%esp
  810306:	85 c0                	test   %eax,%eax
  810308:	78 10                	js     81031a <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  81030a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81030d:	8b 0d 24 43 81 00    	mov    0x814324,%ecx
  810313:	39 08                	cmp    %ecx,(%eax)
  810315:	75 05                	jne    81031c <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  810317:	8b 40 0c             	mov    0xc(%eax),%eax
}
  81031a:	c9                   	leave  
  81031b:	c3                   	ret    
		return -E_NOT_SUPP;
  81031c:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  810321:	eb f7                	jmp    81031a <fd2sockid+0x27>

00810323 <alloc_sockfd>:
{
  810323:	55                   	push   %ebp
  810324:	89 e5                	mov    %esp,%ebp
  810326:	56                   	push   %esi
  810327:	53                   	push   %ebx
  810328:	83 ec 1c             	sub    $0x1c,%esp
  81032b:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  81032d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810330:	50                   	push   %eax
  810331:	e8 d7 f3 ff ff       	call   80f70d <fd_alloc>
  810336:	89 c3                	mov    %eax,%ebx
  810338:	83 c4 10             	add    $0x10,%esp
  81033b:	85 c0                	test   %eax,%eax
  81033d:	78 43                	js     810382 <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  81033f:	83 ec 04             	sub    $0x4,%esp
  810342:	68 07 04 00 00       	push   $0x407
  810347:	ff 75 f4             	pushl  -0xc(%ebp)
  81034a:	6a 00                	push   $0x0
  81034c:	e8 c8 ec ff ff       	call   80f019 <sys_page_alloc>
  810351:	89 c3                	mov    %eax,%ebx
  810353:	83 c4 10             	add    $0x10,%esp
  810356:	85 c0                	test   %eax,%eax
  810358:	78 28                	js     810382 <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  81035a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81035d:	8b 15 24 43 81 00    	mov    0x814324,%edx
  810363:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  810365:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810368:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  81036f:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  810372:	83 ec 0c             	sub    $0xc,%esp
  810375:	50                   	push   %eax
  810376:	e8 6b f3 ff ff       	call   80f6e6 <fd2num>
  81037b:	89 c3                	mov    %eax,%ebx
  81037d:	83 c4 10             	add    $0x10,%esp
  810380:	eb 0c                	jmp    81038e <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  810382:	83 ec 0c             	sub    $0xc,%esp
  810385:	56                   	push   %esi
  810386:	e8 e4 01 00 00       	call   81056f <nsipc_close>
		return r;
  81038b:	83 c4 10             	add    $0x10,%esp
}
  81038e:	89 d8                	mov    %ebx,%eax
  810390:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810393:	5b                   	pop    %ebx
  810394:	5e                   	pop    %esi
  810395:	5d                   	pop    %ebp
  810396:	c3                   	ret    

00810397 <accept>:
{
  810397:	55                   	push   %ebp
  810398:	89 e5                	mov    %esp,%ebp
  81039a:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81039d:	8b 45 08             	mov    0x8(%ebp),%eax
  8103a0:	e8 4e ff ff ff       	call   8102f3 <fd2sockid>
  8103a5:	85 c0                	test   %eax,%eax
  8103a7:	78 1b                	js     8103c4 <accept+0x2d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  8103a9:	83 ec 04             	sub    $0x4,%esp
  8103ac:	ff 75 10             	pushl  0x10(%ebp)
  8103af:	ff 75 0c             	pushl  0xc(%ebp)
  8103b2:	50                   	push   %eax
  8103b3:	e8 0e 01 00 00       	call   8104c6 <nsipc_accept>
  8103b8:	83 c4 10             	add    $0x10,%esp
  8103bb:	85 c0                	test   %eax,%eax
  8103bd:	78 05                	js     8103c4 <accept+0x2d>
	return alloc_sockfd(r);
  8103bf:	e8 5f ff ff ff       	call   810323 <alloc_sockfd>
}
  8103c4:	c9                   	leave  
  8103c5:	c3                   	ret    

008103c6 <bind>:
{
  8103c6:	55                   	push   %ebp
  8103c7:	89 e5                	mov    %esp,%ebp
  8103c9:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8103cc:	8b 45 08             	mov    0x8(%ebp),%eax
  8103cf:	e8 1f ff ff ff       	call   8102f3 <fd2sockid>
  8103d4:	85 c0                	test   %eax,%eax
  8103d6:	78 12                	js     8103ea <bind+0x24>
	return nsipc_bind(r, name, namelen);
  8103d8:	83 ec 04             	sub    $0x4,%esp
  8103db:	ff 75 10             	pushl  0x10(%ebp)
  8103de:	ff 75 0c             	pushl  0xc(%ebp)
  8103e1:	50                   	push   %eax
  8103e2:	e8 31 01 00 00       	call   810518 <nsipc_bind>
  8103e7:	83 c4 10             	add    $0x10,%esp
}
  8103ea:	c9                   	leave  
  8103eb:	c3                   	ret    

008103ec <shutdown>:
{
  8103ec:	55                   	push   %ebp
  8103ed:	89 e5                	mov    %esp,%ebp
  8103ef:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8103f2:	8b 45 08             	mov    0x8(%ebp),%eax
  8103f5:	e8 f9 fe ff ff       	call   8102f3 <fd2sockid>
  8103fa:	85 c0                	test   %eax,%eax
  8103fc:	78 0f                	js     81040d <shutdown+0x21>
	return nsipc_shutdown(r, how);
  8103fe:	83 ec 08             	sub    $0x8,%esp
  810401:	ff 75 0c             	pushl  0xc(%ebp)
  810404:	50                   	push   %eax
  810405:	e8 43 01 00 00       	call   81054d <nsipc_shutdown>
  81040a:	83 c4 10             	add    $0x10,%esp
}
  81040d:	c9                   	leave  
  81040e:	c3                   	ret    

0081040f <connect>:
{
  81040f:	55                   	push   %ebp
  810410:	89 e5                	mov    %esp,%ebp
  810412:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810415:	8b 45 08             	mov    0x8(%ebp),%eax
  810418:	e8 d6 fe ff ff       	call   8102f3 <fd2sockid>
  81041d:	85 c0                	test   %eax,%eax
  81041f:	78 12                	js     810433 <connect+0x24>
	return nsipc_connect(r, name, namelen);
  810421:	83 ec 04             	sub    $0x4,%esp
  810424:	ff 75 10             	pushl  0x10(%ebp)
  810427:	ff 75 0c             	pushl  0xc(%ebp)
  81042a:	50                   	push   %eax
  81042b:	e8 59 01 00 00       	call   810589 <nsipc_connect>
  810430:	83 c4 10             	add    $0x10,%esp
}
  810433:	c9                   	leave  
  810434:	c3                   	ret    

00810435 <listen>:
{
  810435:	55                   	push   %ebp
  810436:	89 e5                	mov    %esp,%ebp
  810438:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81043b:	8b 45 08             	mov    0x8(%ebp),%eax
  81043e:	e8 b0 fe ff ff       	call   8102f3 <fd2sockid>
  810443:	85 c0                	test   %eax,%eax
  810445:	78 0f                	js     810456 <listen+0x21>
	return nsipc_listen(r, backlog);
  810447:	83 ec 08             	sub    $0x8,%esp
  81044a:	ff 75 0c             	pushl  0xc(%ebp)
  81044d:	50                   	push   %eax
  81044e:	e8 6b 01 00 00       	call   8105be <nsipc_listen>
  810453:	83 c4 10             	add    $0x10,%esp
}
  810456:	c9                   	leave  
  810457:	c3                   	ret    

00810458 <socket>:

int
socket(int domain, int type, int protocol)
{
  810458:	55                   	push   %ebp
  810459:	89 e5                	mov    %esp,%ebp
  81045b:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  81045e:	ff 75 10             	pushl  0x10(%ebp)
  810461:	ff 75 0c             	pushl  0xc(%ebp)
  810464:	ff 75 08             	pushl  0x8(%ebp)
  810467:	e8 3e 02 00 00       	call   8106aa <nsipc_socket>
  81046c:	83 c4 10             	add    $0x10,%esp
  81046f:	85 c0                	test   %eax,%eax
  810471:	78 05                	js     810478 <socket+0x20>
		return r;
	return alloc_sockfd(r);
  810473:	e8 ab fe ff ff       	call   810323 <alloc_sockfd>
}
  810478:	c9                   	leave  
  810479:	c3                   	ret    

0081047a <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  81047a:	55                   	push   %ebp
  81047b:	89 e5                	mov    %esp,%ebp
  81047d:	53                   	push   %ebx
  81047e:	83 ec 04             	sub    $0x4,%esp
  810481:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  810483:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  81048a:	74 26                	je     8104b2 <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  81048c:	6a 07                	push   $0x7
  81048e:	68 00 d0 b3 00       	push   $0xb3d000
  810493:	53                   	push   %ebx
  810494:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  81049a:	e8 a2 f1 ff ff       	call   80f641 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  81049f:	83 c4 0c             	add    $0xc,%esp
  8104a2:	6a 00                	push   $0x0
  8104a4:	6a 00                	push   $0x0
  8104a6:	6a 00                	push   $0x0
  8104a8:	e8 21 f1 ff ff       	call   80f5ce <ipc_recv>
}
  8104ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8104b0:	c9                   	leave  
  8104b1:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8104b2:	83 ec 0c             	sub    $0xc,%esp
  8104b5:	6a 02                	push   $0x2
  8104b7:	e8 f1 f1 ff ff       	call   80f6ad <ipc_find_env>
  8104bc:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  8104c1:	83 c4 10             	add    $0x10,%esp
  8104c4:	eb c6                	jmp    81048c <nsipc+0x12>

008104c6 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8104c6:	55                   	push   %ebp
  8104c7:	89 e5                	mov    %esp,%ebp
  8104c9:	56                   	push   %esi
  8104ca:	53                   	push   %ebx
  8104cb:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  8104ce:	8b 45 08             	mov    0x8(%ebp),%eax
  8104d1:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  8104d6:	8b 06                	mov    (%esi),%eax
  8104d8:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8104dd:	b8 01 00 00 00       	mov    $0x1,%eax
  8104e2:	e8 93 ff ff ff       	call   81047a <nsipc>
  8104e7:	89 c3                	mov    %eax,%ebx
  8104e9:	85 c0                	test   %eax,%eax
  8104eb:	79 09                	jns    8104f6 <nsipc_accept+0x30>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  8104ed:	89 d8                	mov    %ebx,%eax
  8104ef:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8104f2:	5b                   	pop    %ebx
  8104f3:	5e                   	pop    %esi
  8104f4:	5d                   	pop    %ebp
  8104f5:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8104f6:	83 ec 04             	sub    $0x4,%esp
  8104f9:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  8104ff:	68 00 d0 b3 00       	push   $0xb3d000
  810504:	ff 75 0c             	pushl  0xc(%ebp)
  810507:	e8 a9 e8 ff ff       	call   80edb5 <memmove>
		*addrlen = ret->ret_addrlen;
  81050c:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  810511:	89 06                	mov    %eax,(%esi)
  810513:	83 c4 10             	add    $0x10,%esp
	return r;
  810516:	eb d5                	jmp    8104ed <nsipc_accept+0x27>

00810518 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810518:	55                   	push   %ebp
  810519:	89 e5                	mov    %esp,%ebp
  81051b:	53                   	push   %ebx
  81051c:	83 ec 08             	sub    $0x8,%esp
  81051f:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  810522:	8b 45 08             	mov    0x8(%ebp),%eax
  810525:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  81052a:	53                   	push   %ebx
  81052b:	ff 75 0c             	pushl  0xc(%ebp)
  81052e:	68 04 d0 b3 00       	push   $0xb3d004
  810533:	e8 7d e8 ff ff       	call   80edb5 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  810538:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  81053e:	b8 02 00 00 00       	mov    $0x2,%eax
  810543:	e8 32 ff ff ff       	call   81047a <nsipc>
}
  810548:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81054b:	c9                   	leave  
  81054c:	c3                   	ret    

0081054d <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  81054d:	55                   	push   %ebp
  81054e:	89 e5                	mov    %esp,%ebp
  810550:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  810553:	8b 45 08             	mov    0x8(%ebp),%eax
  810556:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  81055b:	8b 45 0c             	mov    0xc(%ebp),%eax
  81055e:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  810563:	b8 03 00 00 00       	mov    $0x3,%eax
  810568:	e8 0d ff ff ff       	call   81047a <nsipc>
}
  81056d:	c9                   	leave  
  81056e:	c3                   	ret    

0081056f <nsipc_close>:

int
nsipc_close(int s)
{
  81056f:	55                   	push   %ebp
  810570:	89 e5                	mov    %esp,%ebp
  810572:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  810575:	8b 45 08             	mov    0x8(%ebp),%eax
  810578:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  81057d:	b8 04 00 00 00       	mov    $0x4,%eax
  810582:	e8 f3 fe ff ff       	call   81047a <nsipc>
}
  810587:	c9                   	leave  
  810588:	c3                   	ret    

00810589 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810589:	55                   	push   %ebp
  81058a:	89 e5                	mov    %esp,%ebp
  81058c:	53                   	push   %ebx
  81058d:	83 ec 08             	sub    $0x8,%esp
  810590:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  810593:	8b 45 08             	mov    0x8(%ebp),%eax
  810596:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  81059b:	53                   	push   %ebx
  81059c:	ff 75 0c             	pushl  0xc(%ebp)
  81059f:	68 04 d0 b3 00       	push   $0xb3d004
  8105a4:	e8 0c e8 ff ff       	call   80edb5 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  8105a9:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  8105af:	b8 05 00 00 00       	mov    $0x5,%eax
  8105b4:	e8 c1 fe ff ff       	call   81047a <nsipc>
}
  8105b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8105bc:	c9                   	leave  
  8105bd:	c3                   	ret    

008105be <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  8105be:	55                   	push   %ebp
  8105bf:	89 e5                	mov    %esp,%ebp
  8105c1:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8105c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8105c7:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  8105cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8105cf:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  8105d4:	b8 06 00 00 00       	mov    $0x6,%eax
  8105d9:	e8 9c fe ff ff       	call   81047a <nsipc>
}
  8105de:	c9                   	leave  
  8105df:	c3                   	ret    

008105e0 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8105e0:	55                   	push   %ebp
  8105e1:	89 e5                	mov    %esp,%ebp
  8105e3:	56                   	push   %esi
  8105e4:	53                   	push   %ebx
  8105e5:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8105e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8105eb:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  8105f0:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  8105f6:	8b 45 14             	mov    0x14(%ebp),%eax
  8105f9:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8105fe:	b8 07 00 00 00       	mov    $0x7,%eax
  810603:	e8 72 fe ff ff       	call   81047a <nsipc>
  810608:	89 c3                	mov    %eax,%ebx
  81060a:	85 c0                	test   %eax,%eax
  81060c:	78 1f                	js     81062d <nsipc_recv+0x4d>
		assert(r < 1600 && r <= len);
  81060e:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  810613:	7f 21                	jg     810636 <nsipc_recv+0x56>
  810615:	39 c6                	cmp    %eax,%esi
  810617:	7c 1d                	jl     810636 <nsipc_recv+0x56>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810619:	83 ec 04             	sub    $0x4,%esp
  81061c:	50                   	push   %eax
  81061d:	68 00 d0 b3 00       	push   $0xb3d000
  810622:	ff 75 0c             	pushl  0xc(%ebp)
  810625:	e8 8b e7 ff ff       	call   80edb5 <memmove>
  81062a:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  81062d:	89 d8                	mov    %ebx,%eax
  81062f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810632:	5b                   	pop    %ebx
  810633:	5e                   	pop    %esi
  810634:	5d                   	pop    %ebp
  810635:	c3                   	ret    
		assert(r < 1600 && r <= len);
  810636:	68 99 39 81 00       	push   $0x813999
  81063b:	68 ab 25 81 00       	push   $0x8125ab
  810640:	6a 62                	push   $0x62
  810642:	68 ae 39 81 00       	push   $0x8139ae
  810647:	e8 24 df ff ff       	call   80e570 <_panic>

0081064c <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  81064c:	55                   	push   %ebp
  81064d:	89 e5                	mov    %esp,%ebp
  81064f:	53                   	push   %ebx
  810650:	83 ec 04             	sub    $0x4,%esp
  810653:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  810656:	8b 45 08             	mov    0x8(%ebp),%eax
  810659:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  81065e:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  810664:	7f 2e                	jg     810694 <nsipc_send+0x48>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  810666:	83 ec 04             	sub    $0x4,%esp
  810669:	53                   	push   %ebx
  81066a:	ff 75 0c             	pushl  0xc(%ebp)
  81066d:	68 0c d0 b3 00       	push   $0xb3d00c
  810672:	e8 3e e7 ff ff       	call   80edb5 <memmove>
	nsipcbuf.send.req_size = size;
  810677:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  81067d:	8b 45 14             	mov    0x14(%ebp),%eax
  810680:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  810685:	b8 08 00 00 00       	mov    $0x8,%eax
  81068a:	e8 eb fd ff ff       	call   81047a <nsipc>
}
  81068f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810692:	c9                   	leave  
  810693:	c3                   	ret    
	assert(size < 1600);
  810694:	68 ba 39 81 00       	push   $0x8139ba
  810699:	68 ab 25 81 00       	push   $0x8125ab
  81069e:	6a 6d                	push   $0x6d
  8106a0:	68 ae 39 81 00       	push   $0x8139ae
  8106a5:	e8 c6 de ff ff       	call   80e570 <_panic>

008106aa <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  8106aa:	55                   	push   %ebp
  8106ab:	89 e5                	mov    %esp,%ebp
  8106ad:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8106b0:	8b 45 08             	mov    0x8(%ebp),%eax
  8106b3:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  8106b8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106bb:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  8106c0:	8b 45 10             	mov    0x10(%ebp),%eax
  8106c3:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  8106c8:	b8 09 00 00 00       	mov    $0x9,%eax
  8106cd:	e8 a8 fd ff ff       	call   81047a <nsipc>
}
  8106d2:	c9                   	leave  
  8106d3:	c3                   	ret    

008106d4 <free>:
	return v;
}

void
free(void *v)
{
  8106d4:	55                   	push   %ebp
  8106d5:	89 e5                	mov    %esp,%ebp
  8106d7:	53                   	push   %ebx
  8106d8:	83 ec 04             	sub    $0x4,%esp
  8106db:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8106de:	85 db                	test   %ebx,%ebx
  8106e0:	0f 84 85 00 00 00    	je     81076b <free+0x97>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8106e6:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8106ec:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8106f1:	77 51                	ja     810744 <free+0x70>

	c = ROUNDDOWN(v, PGSIZE);
  8106f3:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8106f9:	89 d8                	mov    %ebx,%eax
  8106fb:	c1 e8 0c             	shr    $0xc,%eax
  8106fe:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810705:	f6 c4 02             	test   $0x2,%ah
  810708:	74 50                	je     81075a <free+0x86>
		sys_page_unmap(0, c);
  81070a:	83 ec 08             	sub    $0x8,%esp
  81070d:	53                   	push   %ebx
  81070e:	6a 00                	push   $0x0
  810710:	e8 89 e9 ff ff       	call   80f09e <sys_page_unmap>
		c += PGSIZE;
  810715:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  81071b:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810721:	83 c4 10             	add    $0x10,%esp
  810724:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810729:	76 ce                	jbe    8106f9 <free+0x25>
  81072b:	68 05 3a 81 00       	push   $0x813a05
  810730:	68 ab 25 81 00       	push   $0x8125ab
  810735:	68 81 00 00 00       	push   $0x81
  81073a:	68 f8 39 81 00       	push   $0x8139f8
  81073f:	e8 2c de ff ff       	call   80e570 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810744:	68 c8 39 81 00       	push   $0x8139c8
  810749:	68 ab 25 81 00       	push   $0x8125ab
  81074e:	6a 7a                	push   $0x7a
  810750:	68 f8 39 81 00       	push   $0x8139f8
  810755:	e8 16 de ff ff       	call   80e570 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  81075a:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  810760:	83 e8 01             	sub    $0x1,%eax
  810763:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810769:	74 05                	je     810770 <free+0x9c>
		sys_page_unmap(0, c);
}
  81076b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81076e:	c9                   	leave  
  81076f:	c3                   	ret    
		sys_page_unmap(0, c);
  810770:	83 ec 08             	sub    $0x8,%esp
  810773:	53                   	push   %ebx
  810774:	6a 00                	push   $0x0
  810776:	e8 23 e9 ff ff       	call   80f09e <sys_page_unmap>
  81077b:	83 c4 10             	add    $0x10,%esp
  81077e:	eb eb                	jmp    81076b <free+0x97>

00810780 <malloc>:
{
  810780:	55                   	push   %ebp
  810781:	89 e5                	mov    %esp,%ebp
  810783:	57                   	push   %edi
  810784:	56                   	push   %esi
  810785:	53                   	push   %ebx
  810786:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  810789:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  81078e:	85 c0                	test   %eax,%eax
  810790:	74 74                	je     810806 <malloc+0x86>
	n = ROUNDUP(n, 4);
  810792:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810795:	8d 51 03             	lea    0x3(%ecx),%edx
  810798:	83 e2 fc             	and    $0xfffffffc,%edx
  81079b:	89 d6                	mov    %edx,%esi
  81079d:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  8107a0:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  8107a6:	0f 87 59 01 00 00    	ja     810905 <malloc+0x185>
	if ((uintptr_t) mptr % PGSIZE){
  8107ac:	89 c1                	mov    %eax,%ecx
  8107ae:	a9 ff 0f 00 00       	test   $0xfff,%eax
  8107b3:	74 30                	je     8107e5 <malloc+0x65>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8107b5:	89 c3                	mov    %eax,%ebx
  8107b7:	c1 eb 0c             	shr    $0xc,%ebx
  8107ba:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  8107be:	c1 ea 0c             	shr    $0xc,%edx
  8107c1:	39 d3                	cmp    %edx,%ebx
  8107c3:	74 68                	je     81082d <malloc+0xad>
		free(mptr);	/* drop reference to this page */
  8107c5:	83 ec 0c             	sub    $0xc,%esp
  8107c8:	50                   	push   %eax
  8107c9:	e8 06 ff ff ff       	call   8106d4 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8107ce:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  8107d3:	05 00 10 00 00       	add    $0x1000,%eax
  8107d8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  8107dd:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  8107e2:	83 c4 10             	add    $0x10,%esp
  8107e5:	8b 15 d4 b1 b3 00    	mov    0xb3b1d4,%edx
{
  8107eb:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  8107f2:	be 00 00 00 00       	mov    $0x0,%esi
		if (isfree(mptr, n + 4))
  8107f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8107fa:	8d 78 04             	lea    0x4(%eax),%edi
  8107fd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
  810801:	e9 8a 00 00 00       	jmp    810890 <malloc+0x110>
		mptr = mbegin;
  810806:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  81080d:	00 00 08 
	n = ROUNDUP(n, 4);
  810810:	8b 45 08             	mov    0x8(%ebp),%eax
  810813:	83 c0 03             	add    $0x3,%eax
  810816:	83 e0 fc             	and    $0xfffffffc,%eax
  810819:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (n >= MAXMALLOC)
  81081c:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  810821:	76 c2                	jbe    8107e5 <malloc+0x65>
		return 0;
  810823:	b8 00 00 00 00       	mov    $0x0,%eax
  810828:	e9 fd 00 00 00       	jmp    81092a <malloc+0x1aa>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  81082d:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  810833:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
			(*ref)++;
  810839:	83 41 fc 01          	addl   $0x1,-0x4(%ecx)
			mptr += n;
  81083d:	89 f2                	mov    %esi,%edx
  81083f:	01 c2                	add    %eax,%edx
  810841:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  810847:	e9 de 00 00 00       	jmp    81092a <malloc+0x1aa>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81084c:	05 00 10 00 00       	add    $0x1000,%eax
  810851:	39 c8                	cmp    %ecx,%eax
  810853:	73 66                	jae    8108bb <malloc+0x13b>
		if (va >= (uintptr_t) mend
  810855:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  81085a:	77 22                	ja     81087e <malloc+0xfe>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  81085c:	89 c3                	mov    %eax,%ebx
  81085e:	c1 eb 16             	shr    $0x16,%ebx
  810861:	8b 1c 9d 00 d0 7b ef 	mov    -0x10843000(,%ebx,4),%ebx
  810868:	f6 c3 01             	test   $0x1,%bl
  81086b:	74 df                	je     81084c <malloc+0xcc>
  81086d:	89 c3                	mov    %eax,%ebx
  81086f:	c1 eb 0c             	shr    $0xc,%ebx
  810872:	8b 1c 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%ebx
  810879:	f6 c3 01             	test   $0x1,%bl
  81087c:	74 ce                	je     81084c <malloc+0xcc>
  81087e:	81 c2 00 10 00 00    	add    $0x1000,%edx
  810884:	0f b6 75 e3          	movzbl -0x1d(%ebp),%esi
		if (mptr == mend) {
  810888:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  81088e:	74 0a                	je     81089a <malloc+0x11a>
  810890:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810893:	89 d0                	mov    %edx,%eax
  810895:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
  810898:	eb b7                	jmp    810851 <malloc+0xd1>
			mptr = mbegin;
  81089a:	ba 00 00 00 08       	mov    $0x8000000,%edx
  81089f:	be 01 00 00 00       	mov    $0x1,%esi
			if (++nwrap == 2)
  8108a4:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  8108a8:	75 e6                	jne    810890 <malloc+0x110>
  8108aa:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8108b1:	00 00 08 
				return 0;	/* out of address space */
  8108b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8108b9:	eb 6f                	jmp    81092a <malloc+0x1aa>
  8108bb:	89 f0                	mov    %esi,%eax
  8108bd:	84 c0                	test   %al,%al
  8108bf:	74 08                	je     8108c9 <malloc+0x149>
  8108c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8108c4:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
	for (i = 0; i < n + 4; i += PGSIZE){
  8108c9:	bb 00 00 00 00       	mov    $0x0,%ebx
  8108ce:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8108d1:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  8108d7:	39 f7                	cmp    %esi,%edi
  8108d9:	76 57                	jbe    810932 <malloc+0x1b2>
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8108db:	83 ec 04             	sub    $0x4,%esp
  8108de:	68 07 02 00 00       	push   $0x207
  8108e3:	89 d8                	mov    %ebx,%eax
  8108e5:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  8108eb:	50                   	push   %eax
  8108ec:	6a 00                	push   $0x0
  8108ee:	e8 26 e7 ff ff       	call   80f019 <sys_page_alloc>
  8108f3:	83 c4 10             	add    $0x10,%esp
  8108f6:	85 c0                	test   %eax,%eax
  8108f8:	78 55                	js     81094f <malloc+0x1cf>
	for (i = 0; i < n + 4; i += PGSIZE){
  8108fa:	89 f3                	mov    %esi,%ebx
  8108fc:	eb d0                	jmp    8108ce <malloc+0x14e>
			return 0;	/* out of physical memory */
  8108fe:	b8 00 00 00 00       	mov    $0x0,%eax
  810903:	eb 25                	jmp    81092a <malloc+0x1aa>
		return 0;
  810905:	b8 00 00 00 00       	mov    $0x0,%eax
  81090a:	eb 1e                	jmp    81092a <malloc+0x1aa>
	ref = (uint32_t*) (mptr + i - 4);
  81090c:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810911:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  810914:	c7 84 08 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%ecx,1)
  81091b:	02 00 00 00 
	mptr += n;
  81091f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810922:	01 c2                	add    %eax,%edx
  810924:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
}
  81092a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  81092d:	5b                   	pop    %ebx
  81092e:	5e                   	pop    %esi
  81092f:	5f                   	pop    %edi
  810930:	5d                   	pop    %ebp
  810931:	c3                   	ret    
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810932:	83 ec 04             	sub    $0x4,%esp
  810935:	6a 07                	push   $0x7
  810937:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81093a:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810940:	50                   	push   %eax
  810941:	6a 00                	push   $0x0
  810943:	e8 d1 e6 ff ff       	call   80f019 <sys_page_alloc>
  810948:	83 c4 10             	add    $0x10,%esp
  81094b:	85 c0                	test   %eax,%eax
  81094d:	79 bd                	jns    81090c <malloc+0x18c>
			for (; i >= 0; i -= PGSIZE)
  81094f:	85 db                	test   %ebx,%ebx
  810951:	78 ab                	js     8108fe <malloc+0x17e>
				sys_page_unmap(0, mptr + i);
  810953:	83 ec 08             	sub    $0x8,%esp
  810956:	89 d8                	mov    %ebx,%eax
  810958:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  81095e:	50                   	push   %eax
  81095f:	6a 00                	push   $0x0
  810961:	e8 38 e7 ff ff       	call   80f09e <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  810966:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  81096c:	83 c4 10             	add    $0x10,%esp
  81096f:	eb de                	jmp    81094f <malloc+0x1cf>

00810971 <devcons_close>:
devcons_close(struct Fd *fd)
{
	USED(fd);

	return 0;
}
  810971:	b8 00 00 00 00       	mov    $0x0,%eax
  810976:	c3                   	ret    

00810977 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810977:	55                   	push   %ebp
  810978:	89 e5                	mov    %esp,%ebp
  81097a:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  81097d:	68 1d 3a 81 00       	push   $0x813a1d
  810982:	ff 75 0c             	pushl  0xc(%ebp)
  810985:	e8 9d e2 ff ff       	call   80ec27 <strcpy>
	return 0;
}
  81098a:	b8 00 00 00 00       	mov    $0x0,%eax
  81098f:	c9                   	leave  
  810990:	c3                   	ret    

00810991 <devcons_write>:
{
  810991:	55                   	push   %ebp
  810992:	89 e5                	mov    %esp,%ebp
  810994:	57                   	push   %edi
  810995:	56                   	push   %esi
  810996:	53                   	push   %ebx
  810997:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  81099d:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  8109a2:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  8109a8:	3b 75 10             	cmp    0x10(%ebp),%esi
  8109ab:	73 31                	jae    8109de <devcons_write+0x4d>
		m = n - tot;
  8109ad:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8109b0:	29 f3                	sub    %esi,%ebx
  8109b2:	83 fb 7f             	cmp    $0x7f,%ebx
  8109b5:	b8 7f 00 00 00       	mov    $0x7f,%eax
  8109ba:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  8109bd:	83 ec 04             	sub    $0x4,%esp
  8109c0:	53                   	push   %ebx
  8109c1:	89 f0                	mov    %esi,%eax
  8109c3:	03 45 0c             	add    0xc(%ebp),%eax
  8109c6:	50                   	push   %eax
  8109c7:	57                   	push   %edi
  8109c8:	e8 e8 e3 ff ff       	call   80edb5 <memmove>
		sys_cputs(buf, m);
  8109cd:	83 c4 08             	add    $0x8,%esp
  8109d0:	53                   	push   %ebx
  8109d1:	57                   	push   %edi
  8109d2:	e8 86 e5 ff ff       	call   80ef5d <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  8109d7:	01 de                	add    %ebx,%esi
  8109d9:	83 c4 10             	add    $0x10,%esp
  8109dc:	eb ca                	jmp    8109a8 <devcons_write+0x17>
}
  8109de:	89 f0                	mov    %esi,%eax
  8109e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8109e3:	5b                   	pop    %ebx
  8109e4:	5e                   	pop    %esi
  8109e5:	5f                   	pop    %edi
  8109e6:	5d                   	pop    %ebp
  8109e7:	c3                   	ret    

008109e8 <devcons_read>:
{
  8109e8:	55                   	push   %ebp
  8109e9:	89 e5                	mov    %esp,%ebp
  8109eb:	83 ec 08             	sub    $0x8,%esp
  8109ee:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  8109f3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8109f7:	74 21                	je     810a1a <devcons_read+0x32>
	while ((c = sys_cgetc()) == 0)
  8109f9:	e8 7d e5 ff ff       	call   80ef7b <sys_cgetc>
  8109fe:	85 c0                	test   %eax,%eax
  810a00:	75 07                	jne    810a09 <devcons_read+0x21>
		sys_yield();
  810a02:	e8 f3 e5 ff ff       	call   80effa <sys_yield>
  810a07:	eb f0                	jmp    8109f9 <devcons_read+0x11>
	if (c < 0)
  810a09:	78 0f                	js     810a1a <devcons_read+0x32>
	if (c == 0x04)	// ctl-d is eof
  810a0b:	83 f8 04             	cmp    $0x4,%eax
  810a0e:	74 0c                	je     810a1c <devcons_read+0x34>
	*(char*)vbuf = c;
  810a10:	8b 55 0c             	mov    0xc(%ebp),%edx
  810a13:	88 02                	mov    %al,(%edx)
	return 1;
  810a15:	b8 01 00 00 00       	mov    $0x1,%eax
}
  810a1a:	c9                   	leave  
  810a1b:	c3                   	ret    
		return 0;
  810a1c:	b8 00 00 00 00       	mov    $0x0,%eax
  810a21:	eb f7                	jmp    810a1a <devcons_read+0x32>

00810a23 <cputchar>:
{
  810a23:	55                   	push   %ebp
  810a24:	89 e5                	mov    %esp,%ebp
  810a26:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810a29:	8b 45 08             	mov    0x8(%ebp),%eax
  810a2c:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  810a2f:	6a 01                	push   $0x1
  810a31:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810a34:	50                   	push   %eax
  810a35:	e8 23 e5 ff ff       	call   80ef5d <sys_cputs>
}
  810a3a:	83 c4 10             	add    $0x10,%esp
  810a3d:	c9                   	leave  
  810a3e:	c3                   	ret    

00810a3f <getchar>:
{
  810a3f:	55                   	push   %ebp
  810a40:	89 e5                	mov    %esp,%ebp
  810a42:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810a45:	6a 01                	push   $0x1
  810a47:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810a4a:	50                   	push   %eax
  810a4b:	6a 00                	push   $0x0
  810a4d:	e8 7d ef ff ff       	call   80f9cf <read>
	if (r < 0)
  810a52:	83 c4 10             	add    $0x10,%esp
  810a55:	85 c0                	test   %eax,%eax
  810a57:	78 06                	js     810a5f <getchar+0x20>
	if (r < 1)
  810a59:	74 06                	je     810a61 <getchar+0x22>
	return c;
  810a5b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  810a5f:	c9                   	leave  
  810a60:	c3                   	ret    
		return -E_EOF;
  810a61:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810a66:	eb f7                	jmp    810a5f <getchar+0x20>

00810a68 <iscons>:
{
  810a68:	55                   	push   %ebp
  810a69:	89 e5                	mov    %esp,%ebp
  810a6b:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810a6e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810a71:	50                   	push   %eax
  810a72:	ff 75 08             	pushl  0x8(%ebp)
  810a75:	e8 e5 ec ff ff       	call   80f75f <fd_lookup>
  810a7a:	83 c4 10             	add    $0x10,%esp
  810a7d:	85 c0                	test   %eax,%eax
  810a7f:	78 11                	js     810a92 <iscons+0x2a>
	return fd->fd_dev_id == devcons.dev_id;
  810a81:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810a84:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810a8a:	39 10                	cmp    %edx,(%eax)
  810a8c:	0f 94 c0             	sete   %al
  810a8f:	0f b6 c0             	movzbl %al,%eax
}
  810a92:	c9                   	leave  
  810a93:	c3                   	ret    

00810a94 <opencons>:
{
  810a94:	55                   	push   %ebp
  810a95:	89 e5                	mov    %esp,%ebp
  810a97:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  810a9a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810a9d:	50                   	push   %eax
  810a9e:	e8 6a ec ff ff       	call   80f70d <fd_alloc>
  810aa3:	83 c4 10             	add    $0x10,%esp
  810aa6:	85 c0                	test   %eax,%eax
  810aa8:	78 3a                	js     810ae4 <opencons+0x50>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810aaa:	83 ec 04             	sub    $0x4,%esp
  810aad:	68 07 04 00 00       	push   $0x407
  810ab2:	ff 75 f4             	pushl  -0xc(%ebp)
  810ab5:	6a 00                	push   $0x0
  810ab7:	e8 5d e5 ff ff       	call   80f019 <sys_page_alloc>
  810abc:	83 c4 10             	add    $0x10,%esp
  810abf:	85 c0                	test   %eax,%eax
  810ac1:	78 21                	js     810ae4 <opencons+0x50>
	fd->fd_dev_id = devcons.dev_id;
  810ac3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810ac6:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810acc:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  810ace:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810ad1:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810ad8:	83 ec 0c             	sub    $0xc,%esp
  810adb:	50                   	push   %eax
  810adc:	e8 05 ec ff ff       	call   80f6e6 <fd2num>
  810ae1:	83 c4 10             	add    $0x10,%esp
}
  810ae4:	c9                   	leave  
  810ae5:	c3                   	ret    

00810ae6 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810ae6:	55                   	push   %ebp
  810ae7:	89 e5                	mov    %esp,%ebp
  810ae9:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  810aec:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  810af3:	74 0a                	je     810aff <set_pgfault_handler+0x19>
    r = sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);
    if (r < 0) panic("set_pgfault_handler: %e", r);
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  810af5:	8b 45 08             	mov    0x8(%ebp),%eax
  810af8:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  810afd:	c9                   	leave  
  810afe:	c3                   	ret    
    r = sys_page_alloc(thisenv->env_id, (void*)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P);
  810aff:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810b04:	8b 40 48             	mov    0x48(%eax),%eax
  810b07:	83 ec 04             	sub    $0x4,%esp
  810b0a:	6a 07                	push   $0x7
  810b0c:	68 00 f0 bf ee       	push   $0xeebff000
  810b11:	50                   	push   %eax
  810b12:	e8 02 e5 ff ff       	call   80f019 <sys_page_alloc>
    if (r < 0) panic("set_pgfault_handler: %e", r);
  810b17:	83 c4 10             	add    $0x10,%esp
  810b1a:	85 c0                	test   %eax,%eax
  810b1c:	78 2c                	js     810b4a <set_pgfault_handler+0x64>
    r = sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);
  810b1e:	e8 b8 e4 ff ff       	call   80efdb <sys_getenvid>
  810b23:	83 ec 08             	sub    $0x8,%esp
  810b26:	68 5c 0b 81 00       	push   $0x810b5c
  810b2b:	50                   	push   %eax
  810b2c:	e8 33 e6 ff ff       	call   80f164 <sys_env_set_pgfault_upcall>
    if (r < 0) panic("set_pgfault_handler: %e", r);
  810b31:	83 c4 10             	add    $0x10,%esp
  810b34:	85 c0                	test   %eax,%eax
  810b36:	79 bd                	jns    810af5 <set_pgfault_handler+0xf>
  810b38:	50                   	push   %eax
  810b39:	68 29 3a 81 00       	push   $0x813a29
  810b3e:	6a 23                	push   $0x23
  810b40:	68 41 3a 81 00       	push   $0x813a41
  810b45:	e8 26 da ff ff       	call   80e570 <_panic>
    if (r < 0) panic("set_pgfault_handler: %e", r);
  810b4a:	50                   	push   %eax
  810b4b:	68 29 3a 81 00       	push   $0x813a29
  810b50:	6a 21                	push   $0x21
  810b52:	68 41 3a 81 00       	push   $0x813a41
  810b57:	e8 14 da ff ff       	call   80e570 <_panic>

00810b5c <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810b5c:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810b5d:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  810b62:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  810b64:	83 c4 04             	add    $0x4,%esp
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
  //将预留的0置为eip，以便使用ret返回，esp指向此处
	movl 48(%esp),%ebp
  810b67:	8b 6c 24 30          	mov    0x30(%esp),%ebp
	subl $4,%ebp
  810b6b:	83 ed 04             	sub    $0x4,%ebp
	movl %ebp,48(%esp)
  810b6e:	89 6c 24 30          	mov    %ebp,0x30(%esp)
	movl 40(%esp),%eax
  810b72:	8b 44 24 28          	mov    0x28(%esp),%eax
	movl %eax,(%ebp)
  810b76:	89 45 00             	mov    %eax,0x0(%ebp)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $8, %esp
  810b79:	83 c4 08             	add    $0x8,%esp
	popal
  810b7c:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $4,%esp
  810b7d:	83 c4 04             	add    $0x4,%esp
	popfl
  810b80:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  810b81:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  810b82:	c3                   	ret    

00810b83 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810b83:	55                   	push   %ebp
  810b84:	89 e5                	mov    %esp,%ebp
  810b86:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810b89:	89 d0                	mov    %edx,%eax
  810b8b:	c1 e8 16             	shr    $0x16,%eax
  810b8e:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  810b95:	b8 00 00 00 00       	mov    $0x0,%eax
	if (!(uvpd[PDX(v)] & PTE_P))
  810b9a:	f6 c1 01             	test   $0x1,%cl
  810b9d:	74 1d                	je     810bbc <pageref+0x39>
	pte = uvpt[PGNUM(v)];
  810b9f:	c1 ea 0c             	shr    $0xc,%edx
  810ba2:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  810ba9:	f6 c2 01             	test   $0x1,%dl
  810bac:	74 0e                	je     810bbc <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  810bae:	c1 ea 0c             	shr    $0xc,%edx
  810bb1:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  810bb8:	ef 
  810bb9:	0f b7 c0             	movzwl %ax,%eax
}
  810bbc:	5d                   	pop    %ebp
  810bbd:	c3                   	ret    
  810bbe:	66 90                	xchg   %ax,%ax

00810bc0 <__udivdi3>:
  810bc0:	f3 0f 1e fb          	endbr32 
  810bc4:	55                   	push   %ebp
  810bc5:	57                   	push   %edi
  810bc6:	56                   	push   %esi
  810bc7:	53                   	push   %ebx
  810bc8:	83 ec 1c             	sub    $0x1c,%esp
  810bcb:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  810bcf:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  810bd3:	8b 74 24 34          	mov    0x34(%esp),%esi
  810bd7:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  810bdb:	85 d2                	test   %edx,%edx
  810bdd:	75 49                	jne    810c28 <__udivdi3+0x68>
  810bdf:	39 f3                	cmp    %esi,%ebx
  810be1:	76 15                	jbe    810bf8 <__udivdi3+0x38>
  810be3:	31 ff                	xor    %edi,%edi
  810be5:	89 e8                	mov    %ebp,%eax
  810be7:	89 f2                	mov    %esi,%edx
  810be9:	f7 f3                	div    %ebx
  810beb:	89 fa                	mov    %edi,%edx
  810bed:	83 c4 1c             	add    $0x1c,%esp
  810bf0:	5b                   	pop    %ebx
  810bf1:	5e                   	pop    %esi
  810bf2:	5f                   	pop    %edi
  810bf3:	5d                   	pop    %ebp
  810bf4:	c3                   	ret    
  810bf5:	8d 76 00             	lea    0x0(%esi),%esi
  810bf8:	89 d9                	mov    %ebx,%ecx
  810bfa:	85 db                	test   %ebx,%ebx
  810bfc:	75 0b                	jne    810c09 <__udivdi3+0x49>
  810bfe:	b8 01 00 00 00       	mov    $0x1,%eax
  810c03:	31 d2                	xor    %edx,%edx
  810c05:	f7 f3                	div    %ebx
  810c07:	89 c1                	mov    %eax,%ecx
  810c09:	31 d2                	xor    %edx,%edx
  810c0b:	89 f0                	mov    %esi,%eax
  810c0d:	f7 f1                	div    %ecx
  810c0f:	89 c6                	mov    %eax,%esi
  810c11:	89 e8                	mov    %ebp,%eax
  810c13:	89 f7                	mov    %esi,%edi
  810c15:	f7 f1                	div    %ecx
  810c17:	89 fa                	mov    %edi,%edx
  810c19:	83 c4 1c             	add    $0x1c,%esp
  810c1c:	5b                   	pop    %ebx
  810c1d:	5e                   	pop    %esi
  810c1e:	5f                   	pop    %edi
  810c1f:	5d                   	pop    %ebp
  810c20:	c3                   	ret    
  810c21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810c28:	39 f2                	cmp    %esi,%edx
  810c2a:	77 1c                	ja     810c48 <__udivdi3+0x88>
  810c2c:	0f bd fa             	bsr    %edx,%edi
  810c2f:	83 f7 1f             	xor    $0x1f,%edi
  810c32:	75 2c                	jne    810c60 <__udivdi3+0xa0>
  810c34:	39 f2                	cmp    %esi,%edx
  810c36:	72 06                	jb     810c3e <__udivdi3+0x7e>
  810c38:	31 c0                	xor    %eax,%eax
  810c3a:	39 eb                	cmp    %ebp,%ebx
  810c3c:	77 ad                	ja     810beb <__udivdi3+0x2b>
  810c3e:	b8 01 00 00 00       	mov    $0x1,%eax
  810c43:	eb a6                	jmp    810beb <__udivdi3+0x2b>
  810c45:	8d 76 00             	lea    0x0(%esi),%esi
  810c48:	31 ff                	xor    %edi,%edi
  810c4a:	31 c0                	xor    %eax,%eax
  810c4c:	89 fa                	mov    %edi,%edx
  810c4e:	83 c4 1c             	add    $0x1c,%esp
  810c51:	5b                   	pop    %ebx
  810c52:	5e                   	pop    %esi
  810c53:	5f                   	pop    %edi
  810c54:	5d                   	pop    %ebp
  810c55:	c3                   	ret    
  810c56:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810c5d:	8d 76 00             	lea    0x0(%esi),%esi
  810c60:	89 f9                	mov    %edi,%ecx
  810c62:	b8 20 00 00 00       	mov    $0x20,%eax
  810c67:	29 f8                	sub    %edi,%eax
  810c69:	d3 e2                	shl    %cl,%edx
  810c6b:	89 54 24 08          	mov    %edx,0x8(%esp)
  810c6f:	89 c1                	mov    %eax,%ecx
  810c71:	89 da                	mov    %ebx,%edx
  810c73:	d3 ea                	shr    %cl,%edx
  810c75:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  810c79:	09 d1                	or     %edx,%ecx
  810c7b:	89 f2                	mov    %esi,%edx
  810c7d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810c81:	89 f9                	mov    %edi,%ecx
  810c83:	d3 e3                	shl    %cl,%ebx
  810c85:	89 c1                	mov    %eax,%ecx
  810c87:	d3 ea                	shr    %cl,%edx
  810c89:	89 f9                	mov    %edi,%ecx
  810c8b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  810c8f:	89 eb                	mov    %ebp,%ebx
  810c91:	d3 e6                	shl    %cl,%esi
  810c93:	89 c1                	mov    %eax,%ecx
  810c95:	d3 eb                	shr    %cl,%ebx
  810c97:	09 de                	or     %ebx,%esi
  810c99:	89 f0                	mov    %esi,%eax
  810c9b:	f7 74 24 08          	divl   0x8(%esp)
  810c9f:	89 d6                	mov    %edx,%esi
  810ca1:	89 c3                	mov    %eax,%ebx
  810ca3:	f7 64 24 0c          	mull   0xc(%esp)
  810ca7:	39 d6                	cmp    %edx,%esi
  810ca9:	72 15                	jb     810cc0 <__udivdi3+0x100>
  810cab:	89 f9                	mov    %edi,%ecx
  810cad:	d3 e5                	shl    %cl,%ebp
  810caf:	39 c5                	cmp    %eax,%ebp
  810cb1:	73 04                	jae    810cb7 <__udivdi3+0xf7>
  810cb3:	39 d6                	cmp    %edx,%esi
  810cb5:	74 09                	je     810cc0 <__udivdi3+0x100>
  810cb7:	89 d8                	mov    %ebx,%eax
  810cb9:	31 ff                	xor    %edi,%edi
  810cbb:	e9 2b ff ff ff       	jmp    810beb <__udivdi3+0x2b>
  810cc0:	8d 43 ff             	lea    -0x1(%ebx),%eax
  810cc3:	31 ff                	xor    %edi,%edi
  810cc5:	e9 21 ff ff ff       	jmp    810beb <__udivdi3+0x2b>
  810cca:	66 90                	xchg   %ax,%ax
  810ccc:	66 90                	xchg   %ax,%ax
  810cce:	66 90                	xchg   %ax,%ax

00810cd0 <__umoddi3>:
  810cd0:	f3 0f 1e fb          	endbr32 
  810cd4:	55                   	push   %ebp
  810cd5:	57                   	push   %edi
  810cd6:	56                   	push   %esi
  810cd7:	53                   	push   %ebx
  810cd8:	83 ec 1c             	sub    $0x1c,%esp
  810cdb:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  810cdf:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  810ce3:	8b 74 24 30          	mov    0x30(%esp),%esi
  810ce7:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810ceb:	89 da                	mov    %ebx,%edx
  810ced:	85 c0                	test   %eax,%eax
  810cef:	75 3f                	jne    810d30 <__umoddi3+0x60>
  810cf1:	39 df                	cmp    %ebx,%edi
  810cf3:	76 13                	jbe    810d08 <__umoddi3+0x38>
  810cf5:	89 f0                	mov    %esi,%eax
  810cf7:	f7 f7                	div    %edi
  810cf9:	89 d0                	mov    %edx,%eax
  810cfb:	31 d2                	xor    %edx,%edx
  810cfd:	83 c4 1c             	add    $0x1c,%esp
  810d00:	5b                   	pop    %ebx
  810d01:	5e                   	pop    %esi
  810d02:	5f                   	pop    %edi
  810d03:	5d                   	pop    %ebp
  810d04:	c3                   	ret    
  810d05:	8d 76 00             	lea    0x0(%esi),%esi
  810d08:	89 fd                	mov    %edi,%ebp
  810d0a:	85 ff                	test   %edi,%edi
  810d0c:	75 0b                	jne    810d19 <__umoddi3+0x49>
  810d0e:	b8 01 00 00 00       	mov    $0x1,%eax
  810d13:	31 d2                	xor    %edx,%edx
  810d15:	f7 f7                	div    %edi
  810d17:	89 c5                	mov    %eax,%ebp
  810d19:	89 d8                	mov    %ebx,%eax
  810d1b:	31 d2                	xor    %edx,%edx
  810d1d:	f7 f5                	div    %ebp
  810d1f:	89 f0                	mov    %esi,%eax
  810d21:	f7 f5                	div    %ebp
  810d23:	89 d0                	mov    %edx,%eax
  810d25:	eb d4                	jmp    810cfb <__umoddi3+0x2b>
  810d27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810d2e:	66 90                	xchg   %ax,%ax
  810d30:	89 f1                	mov    %esi,%ecx
  810d32:	39 d8                	cmp    %ebx,%eax
  810d34:	76 0a                	jbe    810d40 <__umoddi3+0x70>
  810d36:	89 f0                	mov    %esi,%eax
  810d38:	83 c4 1c             	add    $0x1c,%esp
  810d3b:	5b                   	pop    %ebx
  810d3c:	5e                   	pop    %esi
  810d3d:	5f                   	pop    %edi
  810d3e:	5d                   	pop    %ebp
  810d3f:	c3                   	ret    
  810d40:	0f bd e8             	bsr    %eax,%ebp
  810d43:	83 f5 1f             	xor    $0x1f,%ebp
  810d46:	75 20                	jne    810d68 <__umoddi3+0x98>
  810d48:	39 d8                	cmp    %ebx,%eax
  810d4a:	0f 82 b0 00 00 00    	jb     810e00 <__umoddi3+0x130>
  810d50:	39 f7                	cmp    %esi,%edi
  810d52:	0f 86 a8 00 00 00    	jbe    810e00 <__umoddi3+0x130>
  810d58:	89 c8                	mov    %ecx,%eax
  810d5a:	83 c4 1c             	add    $0x1c,%esp
  810d5d:	5b                   	pop    %ebx
  810d5e:	5e                   	pop    %esi
  810d5f:	5f                   	pop    %edi
  810d60:	5d                   	pop    %ebp
  810d61:	c3                   	ret    
  810d62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810d68:	89 e9                	mov    %ebp,%ecx
  810d6a:	ba 20 00 00 00       	mov    $0x20,%edx
  810d6f:	29 ea                	sub    %ebp,%edx
  810d71:	d3 e0                	shl    %cl,%eax
  810d73:	89 44 24 08          	mov    %eax,0x8(%esp)
  810d77:	89 d1                	mov    %edx,%ecx
  810d79:	89 f8                	mov    %edi,%eax
  810d7b:	d3 e8                	shr    %cl,%eax
  810d7d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  810d81:	89 54 24 04          	mov    %edx,0x4(%esp)
  810d85:	8b 54 24 04          	mov    0x4(%esp),%edx
  810d89:	09 c1                	or     %eax,%ecx
  810d8b:	89 d8                	mov    %ebx,%eax
  810d8d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810d91:	89 e9                	mov    %ebp,%ecx
  810d93:	d3 e7                	shl    %cl,%edi
  810d95:	89 d1                	mov    %edx,%ecx
  810d97:	d3 e8                	shr    %cl,%eax
  810d99:	89 e9                	mov    %ebp,%ecx
  810d9b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  810d9f:	d3 e3                	shl    %cl,%ebx
  810da1:	89 c7                	mov    %eax,%edi
  810da3:	89 d1                	mov    %edx,%ecx
  810da5:	89 f0                	mov    %esi,%eax
  810da7:	d3 e8                	shr    %cl,%eax
  810da9:	89 e9                	mov    %ebp,%ecx
  810dab:	89 fa                	mov    %edi,%edx
  810dad:	d3 e6                	shl    %cl,%esi
  810daf:	09 d8                	or     %ebx,%eax
  810db1:	f7 74 24 08          	divl   0x8(%esp)
  810db5:	89 d1                	mov    %edx,%ecx
  810db7:	89 f3                	mov    %esi,%ebx
  810db9:	f7 64 24 0c          	mull   0xc(%esp)
  810dbd:	89 c6                	mov    %eax,%esi
  810dbf:	89 d7                	mov    %edx,%edi
  810dc1:	39 d1                	cmp    %edx,%ecx
  810dc3:	72 06                	jb     810dcb <__umoddi3+0xfb>
  810dc5:	75 10                	jne    810dd7 <__umoddi3+0x107>
  810dc7:	39 c3                	cmp    %eax,%ebx
  810dc9:	73 0c                	jae    810dd7 <__umoddi3+0x107>
  810dcb:	2b 44 24 0c          	sub    0xc(%esp),%eax
  810dcf:	1b 54 24 08          	sbb    0x8(%esp),%edx
  810dd3:	89 d7                	mov    %edx,%edi
  810dd5:	89 c6                	mov    %eax,%esi
  810dd7:	89 ca                	mov    %ecx,%edx
  810dd9:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  810dde:	29 f3                	sub    %esi,%ebx
  810de0:	19 fa                	sbb    %edi,%edx
  810de2:	89 d0                	mov    %edx,%eax
  810de4:	d3 e0                	shl    %cl,%eax
  810de6:	89 e9                	mov    %ebp,%ecx
  810de8:	d3 eb                	shr    %cl,%ebx
  810dea:	d3 ea                	shr    %cl,%edx
  810dec:	09 d8                	or     %ebx,%eax
  810dee:	83 c4 1c             	add    $0x1c,%esp
  810df1:	5b                   	pop    %ebx
  810df2:	5e                   	pop    %esi
  810df3:	5f                   	pop    %edi
  810df4:	5d                   	pop    %ebp
  810df5:	c3                   	ret    
  810df6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810dfd:	8d 76 00             	lea    0x0(%esi),%esi
  810e00:	89 da                	mov    %ebx,%edx
  810e02:	29 fe                	sub    %edi,%esi
  810e04:	19 c2                	sbb    %eax,%edx
  810e06:	89 f1                	mov    %esi,%ecx
  810e08:	89 c8                	mov    %ecx,%eax
  810e0a:	e9 4b ff ff ff       	jmp    810d5a <__umoddi3+0x8a>
